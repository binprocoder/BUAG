{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar SortedMap_1 = require(\"../util/SortedMap\");\n\nvar SortedMap_2 = require(\"../util/SortedMap\");\n\nvar LOG_2 = Math.log(2);\n/**\r\n * @constructor\r\n */\n\nvar Base12Num =\n/** @class */\nfunction () {\n  /**\r\n   * @param {number} length\r\n   */\n  function Base12Num(length) {\n    var logBase2 = function (num) {\n      return parseInt(Math.log(num) / LOG_2, 10);\n    };\n\n    var bitMask = function (bits) {\n      return parseInt(Array(bits + 1).join('1'), 2);\n    };\n\n    this.count = logBase2(length + 1);\n    this.current_ = this.count - 1;\n    var mask = bitMask(this.count);\n    this.bits_ = length + 1 & mask;\n  }\n  /**\r\n   * @return {boolean}\r\n   */\n\n\n  Base12Num.prototype.nextBitIsOne = function () {\n    //noinspection JSBitwiseOperatorUsage\n    var result = !(this.bits_ & 0x1 << this.current_);\n    this.current_--;\n    return result;\n  };\n\n  return Base12Num;\n}();\n/**\r\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\r\n * function\r\n *\r\n * Uses the algorithm described in the paper linked here:\r\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\r\n *\r\n * @template K, V\r\n * @param {Array.<!NamedNode>} childList Unsorted list of children\r\n * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used\r\n * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's\r\n *                                                        type is not NamedNode\r\n * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map\r\n * @return {SortedMap.<K, V>}\r\n */\n\n\nexports.buildChildSet = function (childList, cmp, keyFn, mapSortFn) {\n  childList.sort(cmp);\n\n  var buildBalancedTree = function (low, high) {\n    var length = high - low;\n    var namedNode;\n    var key;\n\n    if (length == 0) {\n      return null;\n    } else if (length == 1) {\n      namedNode = childList[low];\n      key = keyFn ? keyFn(namedNode) : namedNode;\n      return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, null, null);\n    } else {\n      var middle = parseInt(length / 2, 10) + low;\n      var left = buildBalancedTree(low, middle);\n      var right = buildBalancedTree(middle + 1, high);\n      namedNode = childList[middle];\n      key = keyFn ? keyFn(namedNode) : namedNode;\n      return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, left, right);\n    }\n  };\n\n  var buildFrom12Array = function (base12) {\n    var node = null;\n    var root = null;\n    var index = childList.length;\n\n    var buildPennant = function (chunkSize, color) {\n      var low = index - chunkSize;\n      var high = index;\n      index -= chunkSize;\n      var childTree = buildBalancedTree(low + 1, high);\n      var namedNode = childList[low];\n      var key = keyFn ? keyFn(namedNode) : namedNode;\n      attachPennant(new SortedMap_1.LLRBNode(key, namedNode.node, color, null, childTree));\n    };\n\n    var attachPennant = function (pennant) {\n      if (node) {\n        node.left = pennant;\n        node = pennant;\n      } else {\n        root = pennant;\n        node = pennant;\n      }\n    };\n\n    for (var i = 0; i < base12.count; ++i) {\n      var isOne = base12.nextBitIsOne(); // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n\n      var chunkSize = Math.pow(2, base12.count - (i + 1));\n\n      if (isOne) {\n        buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);\n      } else {\n        // current == 2\n        buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);\n        buildPennant(chunkSize, SortedMap_1.LLRBNode.RED);\n      }\n    }\n\n    return root;\n  };\n\n  var base12 = new Base12Num(childList.length);\n  var root = buildFrom12Array(base12);\n  return new SortedMap_2.SortedMap(mapSortFn || cmp, root);\n};","map":{"version":3,"mappings":"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","names":["LOG_2","Math","log","length","logBase2","num","bitMask","bits","Array","join","count","current_","mask","bits_","Base12Num","result","exports","childList","cmp","keyFn","mapSortFn","sort","buildBalancedTree","low","high","namedNode","key","SortedMap_1","node","BLACK","middle","parseInt","left","right","buildFrom12Array","base12","root","index","buildPennant","chunkSize","color","childTree","attachPennant","pennant","i","isOne","nextBitIsOne","pow","RED","SortedMap_2"],"sources":["../src/core/snap/childSet.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LLRBNode } from '../util/SortedMap';\nimport { SortedMap } from '../util/SortedMap';\nimport { NamedNode } from './Node';\n\nconst LOG_2 = Math.log(2);\n\n/**\n * @constructor\n */\nclass Base12Num {\n  count: number;\n  private current_: number;\n  private bits_: number;\n\n  /**\n   * @param {number} length\n   */\n  constructor(length: number) {\n    const logBase2 = (num: number) =>\n      parseInt((Math.log(num) / LOG_2) as any, 10);\n    const bitMask = (bits: number) => parseInt(Array(bits + 1).join('1'), 2);\n    this.count = logBase2(length + 1);\n    this.current_ = this.count - 1;\n    const mask = bitMask(this.count);\n    this.bits_ = (length + 1) & mask;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  nextBitIsOne(): boolean {\n    //noinspection JSBitwiseOperatorUsage\n    const result = !(this.bits_ & (0x1 << this.current_));\n    this.current_--;\n    return result;\n  }\n}\n\n/**\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\n * function\n *\n * Uses the algorithm described in the paper linked here:\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\n *\n * @template K, V\n * @param {Array.<!NamedNode>} childList Unsorted list of children\n * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used\n * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's\n *                                                        type is not NamedNode\n * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map\n * @return {SortedMap.<K, V>}\n */\nexport const buildChildSet = function<K, V>(\n  childList: NamedNode[],\n  cmp: (a: NamedNode, b: NamedNode) => number,\n  keyFn?: (a: NamedNode) => K,\n  mapSortFn?: (a: K, b: K) => number\n): SortedMap<K, V> {\n  childList.sort(cmp);\n\n  const buildBalancedTree = function(\n    low: number,\n    high: number\n  ): LLRBNode<K, V> | null {\n    const length = high - low;\n    let namedNode: NamedNode;\n    let key: K;\n    if (length == 0) {\n      return null;\n    } else if (length == 1) {\n      namedNode = childList[low];\n      key = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      return new LLRBNode(\n        key,\n        (namedNode.node as any) as V,\n        LLRBNode.BLACK,\n        null,\n        null\n      );\n    } else {\n      const middle = parseInt((length / 2) as any, 10) + low;\n      const left = buildBalancedTree(low, middle);\n      const right = buildBalancedTree(middle + 1, high);\n      namedNode = childList[middle];\n      key = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      return new LLRBNode(\n        key,\n        (namedNode.node as any) as V,\n        LLRBNode.BLACK,\n        left,\n        right\n      );\n    }\n  };\n\n  const buildFrom12Array = function(base12: Base12Num): LLRBNode<K, V> {\n    let node: LLRBNode<K, V> = null;\n    let root = null;\n    let index = childList.length;\n\n    const buildPennant = function(chunkSize: number, color: boolean) {\n      const low = index - chunkSize;\n      const high = index;\n      index -= chunkSize;\n      const childTree = buildBalancedTree(low + 1, high);\n      const namedNode = childList[low];\n      const key: K = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      attachPennant(\n        new LLRBNode(key, (namedNode.node as any) as V, color, null, childTree)\n      );\n    };\n\n    const attachPennant = function(pennant: LLRBNode<K, V>) {\n      if (node) {\n        node.left = pennant;\n        node = pennant;\n      } else {\n        root = pennant;\n        node = pennant;\n      }\n    };\n\n    for (let i = 0; i < base12.count; ++i) {\n      const isOne = base12.nextBitIsOne();\n      // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n      const chunkSize = Math.pow(2, base12.count - (i + 1));\n      if (isOne) {\n        buildPennant(chunkSize, LLRBNode.BLACK);\n      } else {\n        // current == 2\n        buildPennant(chunkSize, LLRBNode.BLACK);\n        buildPennant(chunkSize, LLRBNode.RED);\n      }\n    }\n    return root;\n  };\n\n  const base12 = new Base12Num(childList.length);\n  const root = buildFrom12Array(base12);\n\n  return new SortedMap<K, V>(mapSortFn || (cmp as any), root);\n};\n"]},"metadata":{},"sourceType":"script"}