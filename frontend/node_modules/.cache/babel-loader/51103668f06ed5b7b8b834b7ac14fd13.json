{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as errorsExports from './error';\nexport var StringFormat = {\n  RAW: 'raw',\n  BASE64: 'base64',\n  BASE64URL: 'base64url',\n  DATA_URL: 'data_url'\n};\nexport function formatValidator(stringFormat) {\n  switch (stringFormat) {\n    case StringFormat.RAW:\n    case StringFormat.BASE64:\n    case StringFormat.BASE64URL:\n    case StringFormat.DATA_URL:\n      return;\n\n    default:\n      throw 'Expected one of the event types: [' + StringFormat.RAW + ', ' + StringFormat.BASE64 + ', ' + StringFormat.BASE64URL + ', ' + StringFormat.DATA_URL + '].';\n  }\n}\n/**\n * @struct\n */\n\nvar StringData =\n/** @class */\nfunction () {\n  function StringData(data, opt_contentType) {\n    this.data = data;\n    this.contentType = opt_contentType || null;\n  }\n\n  return StringData;\n}();\n\nexport { StringData };\nexport function dataFromString(format, string) {\n  switch (format) {\n    case StringFormat.RAW:\n      return new StringData(utf8Bytes_(string));\n\n    case StringFormat.BASE64:\n    case StringFormat.BASE64URL:\n      return new StringData(base64Bytes_(format, string));\n\n    case StringFormat.DATA_URL:\n      return new StringData(dataURLBytes_(string), dataURLContentType_(string));\n  } // assert(false);\n\n\n  throw errorsExports.unknown();\n}\nexport function utf8Bytes_(string) {\n  var b = [];\n\n  for (var i = 0; i < string.length; i++) {\n    var c = string.charCodeAt(i);\n\n    if (c <= 127) {\n      b.push(c);\n    } else {\n      if (c <= 2047) {\n        b.push(192 | c >> 6, 128 | c & 63);\n      } else {\n        if ((c & 64512) == 55296) {\n          // The start of a surrogate pair.\n          var valid = i < string.length - 1 && (string.charCodeAt(i + 1) & 64512) == 56320;\n\n          if (!valid) {\n            // The second surrogate wasn't there.\n            b.push(239, 191, 189);\n          } else {\n            var hi = c;\n            var lo = string.charCodeAt(++i);\n            c = 65536 | (hi & 1023) << 10 | lo & 1023;\n            b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);\n          }\n        } else {\n          if ((c & 64512) == 56320) {\n            // Invalid low surrogate.\n            b.push(239, 191, 189);\n          } else {\n            b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);\n          }\n        }\n      }\n    }\n  }\n\n  return new Uint8Array(b);\n}\nexport function percentEncodedBytes_(string) {\n  var decoded;\n\n  try {\n    decoded = decodeURIComponent(string);\n  } catch (e) {\n    throw errorsExports.invalidFormat(StringFormat.DATA_URL, 'Malformed data URL.');\n  }\n\n  return utf8Bytes_(decoded);\n}\nexport function base64Bytes_(format, string) {\n  switch (format) {\n    case StringFormat.BASE64:\n      {\n        var hasMinus = string.indexOf('-') !== -1;\n        var hasUnder = string.indexOf('_') !== -1;\n\n        if (hasMinus || hasUnder) {\n          var invalidChar = hasMinus ? '-' : '_';\n          throw errorsExports.invalidFormat(format, \"Invalid character '\" + invalidChar + \"' found: is it base64url encoded?\");\n        }\n\n        break;\n      }\n\n    case StringFormat.BASE64URL:\n      {\n        var hasPlus = string.indexOf('+') !== -1;\n        var hasSlash = string.indexOf('/') !== -1;\n\n        if (hasPlus || hasSlash) {\n          var invalidChar = hasPlus ? '+' : '/';\n          throw errorsExports.invalidFormat(format, \"Invalid character '\" + invalidChar + \"' found: is it base64 encoded?\");\n        }\n\n        string = string.replace(/-/g, '+').replace(/_/g, '/');\n        break;\n      }\n  }\n\n  var bytes;\n\n  try {\n    bytes = atob(string);\n  } catch (e) {\n    throw errorsExports.invalidFormat(format, 'Invalid character found');\n  }\n\n  var array = new Uint8Array(bytes.length);\n\n  for (var i = 0; i < bytes.length; i++) {\n    array[i] = bytes.charCodeAt(i);\n  }\n\n  return array;\n}\n/**\n * @struct\n */\n\nvar DataURLParts =\n/** @class */\nfunction () {\n  function DataURLParts(dataURL) {\n    this.base64 = false;\n    this.contentType = null;\n    var matches = dataURL.match(/^data:([^,]+)?,/);\n\n    if (matches === null) {\n      throw errorsExports.invalidFormat(StringFormat.DATA_URL, \"Must be formatted 'data:[<mediatype>][;base64],<data>\");\n    }\n\n    var middle = matches[1] || null;\n\n    if (middle != null) {\n      this.base64 = endsWith(middle, ';base64');\n      this.contentType = this.base64 ? middle.substring(0, middle.length - ';base64'.length) : middle;\n    }\n\n    this.rest = dataURL.substring(dataURL.indexOf(',') + 1);\n  }\n\n  return DataURLParts;\n}();\n\nexport function dataURLBytes_(string) {\n  var parts = new DataURLParts(string);\n\n  if (parts.base64) {\n    return base64Bytes_(StringFormat.BASE64, parts.rest);\n  } else {\n    return percentEncodedBytes_(parts.rest);\n  }\n}\nexport function dataURLContentType_(string) {\n  var parts = new DataURLParts(string);\n  return parts.contentType;\n}\n\nfunction endsWith(s, end) {\n  var longEnough = s.length >= end.length;\n\n  if (!longEnough) {\n    return false;\n  }\n\n  return s.substring(s.length - end.length) === end;\n}","map":{"version":3,"mappings":"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","names":["errorsExports","StringFormat","RAW","BASE64","BASE64URL","DATA_URL","stringFormat","data","opt_contentType","contentType","format","string","StringData","utf8Bytes_","base64Bytes_","dataURLBytes_","dataURLContentType_","unknown","b","i","length","c","charCodeAt","push","valid","hi","lo","Uint8Array","decoded","decodeURIComponent","e","invalidFormat","hasMinus","indexOf","hasUnder","invalidChar","hasPlus","hasSlash","replace","bytes","atob","array","dataURL","matches","match","middle","base64","endsWith","substring","rest","parts","DataURLParts","percentEncodedBytes_","s","end","longEnough"],"sources":["../src/implementation/string.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as errorsExports from './error';\nimport { errors } from './error';\n\n/**\n * @enum {string}\n */\nexport type StringFormat = string;\nexport const StringFormat = {\n  RAW: 'raw',\n  BASE64: 'base64',\n  BASE64URL: 'base64url',\n  DATA_URL: 'data_url'\n};\n\nexport function formatValidator(stringFormat: string) {\n  switch (stringFormat) {\n    case StringFormat.RAW:\n    case StringFormat.BASE64:\n    case StringFormat.BASE64URL:\n    case StringFormat.DATA_URL:\n      return;\n    default:\n      throw 'Expected one of the event types: [' +\n        StringFormat.RAW +\n        ', ' +\n        StringFormat.BASE64 +\n        ', ' +\n        StringFormat.BASE64URL +\n        ', ' +\n        StringFormat.DATA_URL +\n        '].';\n  }\n}\n\n/**\n * @struct\n */\nexport class StringData {\n  contentType: string | null;\n\n  constructor(public data: Uint8Array, opt_contentType?: string | null) {\n    this.contentType = opt_contentType || null;\n  }\n}\n\nexport function dataFromString(\n  format: StringFormat,\n  string: string\n): StringData {\n  switch (format) {\n    case StringFormat.RAW:\n      return new StringData(utf8Bytes_(string));\n    case StringFormat.BASE64:\n    case StringFormat.BASE64URL:\n      return new StringData(base64Bytes_(format, string));\n    case StringFormat.DATA_URL:\n      return new StringData(dataURLBytes_(string), dataURLContentType_(string));\n  }\n\n  // assert(false);\n  throw errorsExports.unknown();\n}\n\nexport function utf8Bytes_(string: string): Uint8Array {\n  let b = [];\n  for (let i = 0; i < string.length; i++) {\n    let c = string.charCodeAt(i);\n    if (c <= 127) {\n      b.push(c);\n    } else {\n      if (c <= 2047) {\n        b.push(192 | (c >> 6), 128 | (c & 63));\n      } else {\n        if ((c & 64512) == 55296) {\n          // The start of a surrogate pair.\n          let valid =\n            i < string.length - 1 &&\n            (string.charCodeAt(i + 1) & 64512) == 56320;\n          if (!valid) {\n            // The second surrogate wasn't there.\n            b.push(239, 191, 189);\n          } else {\n            let hi = c;\n            let lo = string.charCodeAt(++i);\n            c = 65536 | ((hi & 1023) << 10) | (lo & 1023);\n            b.push(\n              240 | (c >> 18),\n              128 | ((c >> 12) & 63),\n              128 | ((c >> 6) & 63),\n              128 | (c & 63)\n            );\n          }\n        } else {\n          if ((c & 64512) == 56320) {\n            // Invalid low surrogate.\n            b.push(239, 191, 189);\n          } else {\n            b.push(224 | (c >> 12), 128 | ((c >> 6) & 63), 128 | (c & 63));\n          }\n        }\n      }\n    }\n  }\n  return new Uint8Array(b);\n}\n\nexport function percentEncodedBytes_(string: string): Uint8Array {\n  let decoded;\n  try {\n    decoded = decodeURIComponent(string);\n  } catch (e) {\n    throw errorsExports.invalidFormat(\n      StringFormat.DATA_URL,\n      'Malformed data URL.'\n    );\n  }\n  return utf8Bytes_(decoded);\n}\n\nexport function base64Bytes_(format: StringFormat, string: string): Uint8Array {\n  switch (format) {\n    case StringFormat.BASE64: {\n      let hasMinus = string.indexOf('-') !== -1;\n      let hasUnder = string.indexOf('_') !== -1;\n      if (hasMinus || hasUnder) {\n        let invalidChar = hasMinus ? '-' : '_';\n        throw errorsExports.invalidFormat(\n          format,\n          \"Invalid character '\" +\n            invalidChar +\n            \"' found: is it base64url encoded?\"\n        );\n      }\n      break;\n    }\n    case StringFormat.BASE64URL: {\n      let hasPlus = string.indexOf('+') !== -1;\n      let hasSlash = string.indexOf('/') !== -1;\n      if (hasPlus || hasSlash) {\n        let invalidChar = hasPlus ? '+' : '/';\n        throw errorsExports.invalidFormat(\n          format,\n          \"Invalid character '\" + invalidChar + \"' found: is it base64 encoded?\"\n        );\n      }\n      string = string.replace(/-/g, '+').replace(/_/g, '/');\n      break;\n    }\n  }\n  let bytes;\n  try {\n    bytes = atob(string);\n  } catch (e) {\n    throw errorsExports.invalidFormat(format, 'Invalid character found');\n  }\n  let array = new Uint8Array(bytes.length);\n  for (let i = 0; i < bytes.length; i++) {\n    array[i] = bytes.charCodeAt(i);\n  }\n  return array;\n}\n\n/**\n * @struct\n */\nclass DataURLParts {\n  base64: boolean = false;\n  contentType: string | null = null;\n  rest: string;\n\n  constructor(dataURL: string) {\n    let matches = dataURL.match(/^data:([^,]+)?,/);\n    if (matches === null) {\n      throw errorsExports.invalidFormat(\n        StringFormat.DATA_URL,\n        \"Must be formatted 'data:[<mediatype>][;base64],<data>\"\n      );\n    }\n    let middle = matches[1] || null;\n    if (middle != null) {\n      this.base64 = endsWith(middle, ';base64');\n      this.contentType = this.base64\n        ? middle.substring(0, middle.length - ';base64'.length)\n        : middle;\n    }\n    this.rest = dataURL.substring(dataURL.indexOf(',') + 1);\n  }\n}\n\nexport function dataURLBytes_(string: string): Uint8Array {\n  let parts = new DataURLParts(string);\n  if (parts.base64) {\n    return base64Bytes_(StringFormat.BASE64, parts.rest);\n  } else {\n    return percentEncodedBytes_(parts.rest);\n  }\n}\n\nexport function dataURLContentType_(string: string): string | null {\n  let parts = new DataURLParts(string);\n  return parts.contentType;\n}\n\nfunction endsWith(s: string, end: string): boolean {\n  const longEnough = s.length >= end.length;\n  if (!longEnough) {\n    return false;\n  }\n\n  return s.substring(s.length - end.length) === end;\n}\n"]},"metadata":{},"sourceType":"module"}