{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar RepoInfo_1 = require(\"../core/RepoInfo\");\n\nvar PersistentConnection_1 = require(\"../core/PersistentConnection\");\n\nvar RepoManager_1 = require(\"../core/RepoManager\");\n\nvar Connection_1 = require(\"../realtime/Connection\");\n\nexports.DataConnection = PersistentConnection_1.PersistentConnection;\n/**\r\n * @param {!string} pathString\r\n * @param {function(*)} onComplete\r\n */\n\nPersistentConnection_1.PersistentConnection.prototype.simpleListen = function (pathString, onComplete) {\n  this.sendRequest('q', {\n    p: pathString\n  }, onComplete);\n};\n/**\r\n * @param {*} data\r\n * @param {function(*)} onEcho\r\n */\n\n\nPersistentConnection_1.PersistentConnection.prototype.echo = function (data, onEcho) {\n  this.sendRequest('echo', {\n    d: data\n  }, onEcho);\n}; // RealTimeConnection properties that we use in tests.\n\n\nexports.RealTimeConnection = Connection_1.Connection;\n/**\r\n * @param {function(): string} newHash\r\n * @return {function()}\r\n */\n\nexports.hijackHash = function (newHash) {\n  var oldPut = PersistentConnection_1.PersistentConnection.prototype.put;\n\n  PersistentConnection_1.PersistentConnection.prototype.put = function (pathString, data, opt_onComplete, opt_hash) {\n    if (opt_hash !== undefined) {\n      opt_hash = newHash();\n    }\n\n    oldPut.call(this, pathString, data, opt_onComplete, opt_hash);\n  };\n\n  return function () {\n    PersistentConnection_1.PersistentConnection.prototype.put = oldPut;\n  };\n};\n/**\r\n * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}\r\n */\n\n\nexports.ConnectionTarget = RepoInfo_1.RepoInfo;\n/**\r\n * @param {!Query} query\r\n * @return {!string}\r\n */\n\nexports.queryIdentifier = function (query) {\n  return query.queryIdentifier();\n};\n/**\r\n * @param {!Query} firebaseRef\r\n * @return {!Object}\r\n */\n\n\nexports.listens = function (firebaseRef) {\n  return firebaseRef.repo.persistentConnection_.listens_;\n};\n/**\r\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\r\n *\r\n * @param {boolean} forceRestClient\r\n */\n\n\nexports.forceRestClient = function (forceRestClient) {\n  RepoManager_1.RepoManager.getInstance().forceRestClient(forceRestClient);\n};","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA;;AACA;;AACA;;AACA;;AAGaA,yBAAiBC,2CAAjB;AAEb;;;;;AAICA,4CAAqBC,SAArB,CAAuCC,YAAvC,GAAsD,UACrDC,UADqD,EAErDC,UAFqD,EAEzB;AAE5B,OAAKC,WAAL,CAAiB,GAAjB,EAAsB;AAAEC,KAAC,EAAEH;AAAL,GAAtB,EAAyCC,UAAzC;AACD,CALA;AAOD;;;;;;AAICJ,4CAAqBC,SAArB,CAAuCM,IAAvC,GAA8C,UAC7CC,IAD6C,EAE7CC,MAF6C,EAErB;AAExB,OAAKJ,WAAL,CAAiB,MAAjB,EAAyB;AAAEK,KAAC,EAAEF;AAAL,GAAzB,EAAsCC,MAAtC;AACD,CALA,C,CAOD;;;AACaV,6BAAqBY,uBAArB;AAEb;;;;;AAIaZ,qBAAa,UAASa,OAAT,EAA8B;AACtD,MAAMC,MAAM,GAAGb,4CAAqBC,SAArB,CAA+Ba,GAA9C;;AACAd,8CAAqBC,SAArB,CAA+Ba,GAA/B,GAAqC,UACnCX,UADmC,EAEnCK,IAFmC,EAGnCO,cAHmC,EAInCC,QAJmC,EAI3B;AAER,QAAIA,QAAQ,KAAKC,SAAjB,EAA4B;AAC1BD,cAAQ,GAAGJ,OAAO,EAAlB;AACD;;AACDC,UAAM,CAACK,IAAP,CAAY,IAAZ,EAAkBf,UAAlB,EAA8BK,IAA9B,EAAoCO,cAApC,EAAoDC,QAApD;AACD,GAVD;;AAWA,SAAO;AACLhB,gDAAqBC,SAArB,CAA+Ba,GAA/B,GAAqCD,MAArC;AACD,GAFD;AAGD,CAhBY;AAkBb;;;;;AAGad,2BAAmBoB,mBAAnB;AAEb;;;;;AAIapB,0BAAkB,UAASqB,KAAT,EAAqB;AAClD,SAAOA,KAAK,CAACC,eAAN,EAAP;AACD,CAFY;AAIb;;;;;;AAIatB,kBAAU,UAASuB,WAAT,EAA2B;AAChD,SAAQA,WAAW,CAACC,IAAZ,CAAiBC,qBAAjB,CAA+CC,QAAvD;AACD,CAFY;AAIb;;;;;;;AAKa1B,0BAAkB,UAAS2B,eAAT,EAAiC;AAC9DC,4BAAYC,WAAZ,GAA0BF,eAA1B,CAA0CA,eAA1C;AACD,CAFY","names":["exports","PersistentConnection_1","prototype","simpleListen","pathString","onComplete","sendRequest","p","echo","data","onEcho","d","Connection_1","newHash","oldPut","put","opt_onComplete","opt_hash","undefined","call","RepoInfo_1","query","queryIdentifier","firebaseRef","repo","persistentConnection_","listens_","forceRestClient","RepoManager_1","getInstance"],"sources":["../src/api/test_access.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RepoInfo } from '../core/RepoInfo';\nimport { PersistentConnection } from '../core/PersistentConnection';\nimport { RepoManager } from '../core/RepoManager';\nimport { Connection } from '../realtime/Connection';\nimport { Query } from './Query';\n\nexport const DataConnection = PersistentConnection;\n\n/**\n * @param {!string} pathString\n * @param {function(*)} onComplete\n */\n(PersistentConnection.prototype as any).simpleListen = function(\n  pathString: string,\n  onComplete: (a: any) => void\n) {\n  this.sendRequest('q', { p: pathString }, onComplete);\n};\n\n/**\n * @param {*} data\n * @param {function(*)} onEcho\n */\n(PersistentConnection.prototype as any).echo = function(\n  data: any,\n  onEcho: (a: any) => void\n) {\n  this.sendRequest('echo', { d: data }, onEcho);\n};\n\n// RealTimeConnection properties that we use in tests.\nexport const RealTimeConnection = Connection;\n\n/**\n * @param {function(): string} newHash\n * @return {function()}\n */\nexport const hijackHash = function(newHash: () => string) {\n  const oldPut = PersistentConnection.prototype.put;\n  PersistentConnection.prototype.put = function(\n    pathString,\n    data,\n    opt_onComplete,\n    opt_hash\n  ) {\n    if (opt_hash !== undefined) {\n      opt_hash = newHash();\n    }\n    oldPut.call(this, pathString, data, opt_onComplete, opt_hash);\n  };\n  return function() {\n    PersistentConnection.prototype.put = oldPut;\n  };\n};\n\n/**\n * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}\n */\nexport const ConnectionTarget = RepoInfo;\n\n/**\n * @param {!Query} query\n * @return {!string}\n */\nexport const queryIdentifier = function(query: Query) {\n  return query.queryIdentifier();\n};\n\n/**\n * @param {!Query} firebaseRef\n * @return {!Object}\n */\nexport const listens = function(firebaseRef: Query) {\n  return (firebaseRef.repo.persistentConnection_ as any).listens_;\n};\n\n/**\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\n *\n * @param {boolean} forceRestClient\n */\nexport const forceRestClient = function(forceRestClient: boolean) {\n  RepoManager.getInstance().forceRestClient(forceRestClient);\n};\n"]},"metadata":{},"sourceType":"script"}