{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar RangedFilter_1 = require(\"./RangedFilter\");\n\nvar ChildrenNode_1 = require(\"../../snap/ChildrenNode\");\n\nvar Node_1 = require(\"../../snap/Node\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Change_1 = require(\"../Change\");\n/**\r\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\r\n *\r\n * @constructor\r\n * @implements {NodeFilter}\r\n */\n\n\nvar LimitedFilter =\n/** @class */\nfunction () {\n  /**\r\n   * @param {!QueryParams} params\r\n   */\n  function LimitedFilter(params) {\n    this.rangedFilter_ = new RangedFilter_1.RangedFilter(params);\n    this.index_ = params.getIndex();\n    this.limit_ = params.getLimit();\n    this.reverse_ = !params.isViewFromLeft();\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  LimitedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n    if (!this.rangedFilter_.matches(new Node_1.NamedNode(key, newChild))) {\n      newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    }\n\n    if (snap.getImmediateChild(key).equals(newChild)) {\n      // No change\n      return snap;\n    } else if (snap.numChildren() < this.limit_) {\n      return this.rangedFilter_.getIndexedFilter().updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n    } else {\n      return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);\n    }\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  LimitedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n    var filtered;\n\n    if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      filtered = ChildrenNode_1.ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n    } else {\n      if (this.limit_ * 2 < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {\n        // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n        filtered = ChildrenNode_1.ChildrenNode.EMPTY_NODE.withIndex(this.index_); // anchor to the startPost, endPost, or last element as appropriate\n\n        var iterator = void 0;\n\n        if (this.reverse_) {\n          iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);\n        } else {\n          iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);\n        }\n\n        var count = 0;\n\n        while (iterator.hasNext() && count < this.limit_) {\n          var next = iterator.getNext();\n          var inRange = void 0;\n\n          if (this.reverse_) {\n            inRange = this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;\n          } else {\n            inRange = this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;\n          }\n\n          if (inRange) {\n            filtered = filtered.updateImmediateChild(next.name, next.node);\n            count++;\n          } else {\n            // if we have reached the end post, we cannot keep adding elemments\n            break;\n          }\n        }\n      } else {\n        // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n        filtered = newSnap.withIndex(this.index_); // Don't support priorities on queries\n\n        filtered = filtered.updatePriority(ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n        var startPost = void 0;\n        var endPost = void 0;\n        var cmp = void 0;\n        var iterator = void 0;\n\n        if (this.reverse_) {\n          iterator = filtered.getReverseIterator(this.index_);\n          startPost = this.rangedFilter_.getEndPost();\n          endPost = this.rangedFilter_.getStartPost();\n          var indexCompare_1 = this.index_.getCompare();\n\n          cmp = function (a, b) {\n            return indexCompare_1(b, a);\n          };\n        } else {\n          iterator = filtered.getIterator(this.index_);\n          startPost = this.rangedFilter_.getStartPost();\n          endPost = this.rangedFilter_.getEndPost();\n          cmp = this.index_.getCompare();\n        }\n\n        var count = 0;\n        var foundStartPost = false;\n\n        while (iterator.hasNext()) {\n          var next = iterator.getNext();\n\n          if (!foundStartPost && cmp(startPost, next) <= 0) {\n            // start adding\n            foundStartPost = true;\n          }\n\n          var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;\n\n          if (inRange) {\n            count++;\n          } else {\n            filtered = filtered.updateImmediateChild(next.name, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n          }\n        }\n      }\n    }\n\n    return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  LimitedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n    // Don't support priorities on queries\n    return oldSnap;\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  LimitedFilter.prototype.filtersNodes = function () {\n    return true;\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  LimitedFilter.prototype.getIndexedFilter = function () {\n    return this.rangedFilter_.getIndexedFilter();\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  LimitedFilter.prototype.getIndex = function () {\n    return this.index_;\n  };\n  /**\r\n   * @param {!Node} snap\r\n   * @param {string} childKey\r\n   * @param {!Node} childSnap\r\n   * @param {!CompleteChildSource} source\r\n   * @param {?ChildChangeAccumulator} changeAccumulator\r\n   * @return {!Node}\r\n   * @private\r\n   */\n\n\n  LimitedFilter.prototype.fullLimitUpdateChild_ = function (snap, childKey, childSnap, source, changeAccumulator) {\n    // TODO: rename all cache stuff etc to general snap terminology\n    var cmp;\n\n    if (this.reverse_) {\n      var indexCmp_1 = this.index_.getCompare();\n\n      cmp = function (a, b) {\n        return indexCmp_1(b, a);\n      };\n    } else {\n      cmp = this.index_.getCompare();\n    }\n\n    var oldEventCache = snap;\n    util_1.assert(oldEventCache.numChildren() == this.limit_, '');\n    var newChildNamedNode = new Node_1.NamedNode(childKey, childSnap);\n    var windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);\n    var inRange = this.rangedFilter_.matches(newChildNamedNode);\n\n    if (oldEventCache.hasChild(childKey)) {\n      var oldChildSnap = oldEventCache.getImmediateChild(childKey);\n      var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);\n\n      while (nextChild != null && (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))) {\n        // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n        // been applied to the limited filter yet. Ignore this next child which will be updated later in\n        // the limited filter...\n        nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);\n      }\n\n      var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n      var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;\n\n      if (remainsInWindow) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(Change_1.Change.childChangedChange(childKey, childSnap, oldChildSnap));\n        }\n\n        return oldEventCache.updateImmediateChild(childKey, childSnap);\n      } else {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(childKey, oldChildSnap));\n        }\n\n        var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n        var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);\n\n        if (nextChildInRange) {\n          if (changeAccumulator != null) {\n            changeAccumulator.trackChildChange(Change_1.Change.childAddedChange(nextChild.name, nextChild.node));\n          }\n\n          return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);\n        } else {\n          return newEventCache;\n        }\n      }\n    } else if (childSnap.isEmpty()) {\n      // we're deleting a node, but it was not in the window, so ignore it\n      return snap;\n    } else if (inRange) {\n      if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(windowBoundary.name, windowBoundary.node));\n          changeAccumulator.trackChildChange(Change_1.Change.childAddedChange(childKey, childSnap));\n        }\n\n        return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n      } else {\n        return snap;\n      }\n    } else {\n      return snap;\n    }\n  };\n\n  return LimitedFilter;\n}();\n\nexports.LimitedFilter = LimitedFilter;","map":{"version":3,"mappings":"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","names":["params","rangedFilter_","RangedFilter_1","index_","getIndex","limit_","getLimit","reverse_","isViewFromLeft","LimitedFilter","snap","key","newChild","affectedPath","source","optChangeAccumulator","matches","Node_1","ChildrenNode_1","EMPTY_NODE","getImmediateChild","equals","numChildren","getIndexedFilter","updateChild","fullLimitUpdateChild_","oldSnap","newSnap","filtered","isLeafNode","isEmpty","withIndex","isIndexed","iterator","getReverseIteratorFrom","getEndPost","getIteratorFrom","getStartPost","count","hasNext","next","getNext","inRange","compare","updateImmediateChild","name","node","updatePriority","startPost","endPost","cmp","getReverseIterator","indexCompare_1","getCompare","a","b","getIterator","foundStartPost","updateFullNode","newPriority","childKey","childSnap","changeAccumulator","indexCmp_1","oldEventCache","util_1","newChildNamedNode","windowBoundary","getFirstChild","getLastChild","hasChild","oldChildSnap","nextChild","getChildAfterChild","compareNext","remainsInWindow","trackChildChange","Change_1","childChangedChange","childRemovedChange","newEventCache","nextChildInRange","childAddedChange","exports"],"sources":["../src/core/view/filter/LimitedFilter.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RangedFilter } from './RangedFilter';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { Node, NamedNode } from '../../snap/Node';\nimport { assert } from '@firebase/util';\nimport { Change } from '../Change';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { IndexedFilter } from './IndexedFilter';\nimport { QueryParams } from '../QueryParams';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\n\n/**\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\n *\n * @constructor\n * @implements {NodeFilter}\n */\nexport class LimitedFilter implements NodeFilter {\n  /**\n   * @const\n   * @type {RangedFilter}\n   * @private\n   */\n  private readonly rangedFilter_: RangedFilter;\n\n  /**\n   * @const\n   * @type {!Index}\n   * @private\n   */\n  private readonly index_: Index;\n\n  /**\n   * @const\n   * @type {number}\n   * @private\n   */\n  private readonly limit_: number;\n\n  /**\n   * @const\n   * @type {boolean}\n   * @private\n   */\n  private readonly reverse_: boolean;\n\n  /**\n   * @param {!QueryParams} params\n   */\n  constructor(params: QueryParams) {\n    this.rangedFilter_ = new RangedFilter(params);\n    this.index_ = params.getIndex();\n    this.limit_ = params.getLimit();\n    this.reverse_ = !params.isViewFromLeft();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\n      newChild = ChildrenNode.EMPTY_NODE;\n    }\n    if (snap.getImmediateChild(key).equals(newChild)) {\n      // No change\n      return snap;\n    } else if (snap.numChildren() < this.limit_) {\n      return this.rangedFilter_\n        .getIndexedFilter()\n        .updateChild(\n          snap,\n          key,\n          newChild,\n          affectedPath,\n          source,\n          optChangeAccumulator\n        );\n    } else {\n      return this.fullLimitUpdateChild_(\n        snap,\n        key,\n        newChild,\n        source,\n        optChangeAccumulator\n      );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    let filtered;\n    if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n    } else {\n      if (\n        this.limit_ * 2 < newSnap.numChildren() &&\n        newSnap.isIndexed(this.index_)\n      ) {\n        // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n        filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        // anchor to the startPost, endPost, or last element as appropriate\n        let iterator;\n        if (this.reverse_) {\n          iterator = (newSnap as ChildrenNode).getReverseIteratorFrom(\n            this.rangedFilter_.getEndPost(),\n            this.index_\n          );\n        } else {\n          iterator = (newSnap as ChildrenNode).getIteratorFrom(\n            this.rangedFilter_.getStartPost(),\n            this.index_\n          );\n        }\n        let count = 0;\n        while (iterator.hasNext() && count < this.limit_) {\n          const next = iterator.getNext();\n          let inRange;\n          if (this.reverse_) {\n            inRange =\n              this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;\n          } else {\n            inRange =\n              this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;\n          }\n          if (inRange) {\n            filtered = filtered.updateImmediateChild(next.name, next.node);\n            count++;\n          } else {\n            // if we have reached the end post, we cannot keep adding elemments\n            break;\n          }\n        }\n      } else {\n        // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n        filtered = newSnap.withIndex(this.index_);\n        // Don't support priorities on queries\n        filtered = filtered.updatePriority(\n          ChildrenNode.EMPTY_NODE\n        ) as ChildrenNode;\n        let startPost;\n        let endPost;\n        let cmp;\n        let iterator;\n        if (this.reverse_) {\n          iterator = filtered.getReverseIterator(this.index_);\n          startPost = this.rangedFilter_.getEndPost();\n          endPost = this.rangedFilter_.getStartPost();\n          const indexCompare = this.index_.getCompare();\n          cmp = (a: NamedNode, b: NamedNode) => indexCompare(b, a);\n        } else {\n          iterator = filtered.getIterator(this.index_);\n          startPost = this.rangedFilter_.getStartPost();\n          endPost = this.rangedFilter_.getEndPost();\n          cmp = this.index_.getCompare();\n        }\n\n        let count = 0;\n        let foundStartPost = false;\n        while (iterator.hasNext()) {\n          let next = iterator.getNext();\n          if (!foundStartPost && cmp(startPost, next) <= 0) {\n            // start adding\n            foundStartPost = true;\n          }\n          let inRange =\n            foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;\n          if (inRange) {\n            count++;\n          } else {\n            filtered = filtered.updateImmediateChild(\n              next.name,\n              ChildrenNode.EMPTY_NODE\n            );\n          }\n        }\n      }\n    }\n    return this.rangedFilter_\n      .getIndexedFilter()\n      .updateFullNode(oldSnap, filtered, optChangeAccumulator);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    // Don't support priorities on queries\n    return oldSnap;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this.rangedFilter_.getIndexedFilter();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n\n  /**\n   * @param {!Node} snap\n   * @param {string} childKey\n   * @param {!Node} childSnap\n   * @param {!CompleteChildSource} source\n   * @param {?ChildChangeAccumulator} changeAccumulator\n   * @return {!Node}\n   * @private\n   */\n  private fullLimitUpdateChild_(\n    snap: Node,\n    childKey: string,\n    childSnap: Node,\n    source: CompleteChildSource,\n    changeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    // TODO: rename all cache stuff etc to general snap terminology\n    let cmp;\n    if (this.reverse_) {\n      const indexCmp = this.index_.getCompare();\n      cmp = (a: NamedNode, b: NamedNode) => indexCmp(b, a);\n    } else {\n      cmp = this.index_.getCompare();\n    }\n    const oldEventCache = snap as ChildrenNode;\n    assert(oldEventCache.numChildren() == this.limit_, '');\n    const newChildNamedNode = new NamedNode(childKey, childSnap);\n    const windowBoundary = this.reverse_\n      ? oldEventCache.getFirstChild(this.index_)\n      : (oldEventCache.getLastChild(this.index_) as NamedNode);\n    const inRange = this.rangedFilter_.matches(newChildNamedNode);\n    if (oldEventCache.hasChild(childKey)) {\n      const oldChildSnap = oldEventCache.getImmediateChild(childKey);\n      let nextChild = source.getChildAfterChild(\n        this.index_,\n        windowBoundary,\n        this.reverse_\n      );\n      while (\n        nextChild != null &&\n        (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))\n      ) {\n        // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n        // been applied to the limited filter yet. Ignore this next child which will be updated later in\n        // the limited filter...\n        nextChild = source.getChildAfterChild(\n          this.index_,\n          nextChild,\n          this.reverse_\n        );\n      }\n      const compareNext =\n        nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n      const remainsInWindow =\n        inRange && !childSnap.isEmpty() && compareNext >= 0;\n      if (remainsInWindow) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childChangedChange(childKey, childSnap, oldChildSnap)\n          );\n        }\n        return oldEventCache.updateImmediateChild(childKey, childSnap);\n      } else {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childRemovedChange(childKey, oldChildSnap)\n          );\n        }\n        const newEventCache = oldEventCache.updateImmediateChild(\n          childKey,\n          ChildrenNode.EMPTY_NODE\n        );\n        const nextChildInRange =\n          nextChild != null && this.rangedFilter_.matches(nextChild);\n        if (nextChildInRange) {\n          if (changeAccumulator != null) {\n            changeAccumulator.trackChildChange(\n              Change.childAddedChange(nextChild.name, nextChild.node)\n            );\n          }\n          return newEventCache.updateImmediateChild(\n            nextChild.name,\n            nextChild.node\n          );\n        } else {\n          return newEventCache;\n        }\n      }\n    } else if (childSnap.isEmpty()) {\n      // we're deleting a node, but it was not in the window, so ignore it\n      return snap;\n    } else if (inRange) {\n      if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childRemovedChange(windowBoundary.name, windowBoundary.node)\n          );\n          changeAccumulator.trackChildChange(\n            Change.childAddedChange(childKey, childSnap)\n          );\n        }\n        return oldEventCache\n          .updateImmediateChild(childKey, childSnap)\n          .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\n      } else {\n        return snap;\n      }\n    } else {\n      return snap;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}