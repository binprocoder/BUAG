{"ast":null,"code":"/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nimport * as array from './array';\nimport { FbsBlob } from './blob';\nimport * as errorsExports from './error';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\n/**\r\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\r\n */\n\nexport function handlerCheck(cndn) {\n  if (!cndn) {\n    throw errorsExports.unknown();\n  }\n}\nexport function metadataHandler(authWrapper, mappings) {\n  function handler(xhr, text) {\n    var metadata = MetadataUtils.fromResourceString(authWrapper, text, mappings);\n    handlerCheck(metadata !== null);\n    return metadata;\n  }\n\n  return handler;\n}\nexport function sharedErrorHandler(location) {\n  function errorHandler(xhr, err) {\n    var newErr;\n\n    if (xhr.getStatus() === 401) {\n      newErr = errorsExports.unauthenticated();\n    } else {\n      if (xhr.getStatus() === 402) {\n        newErr = errorsExports.quotaExceeded(location.bucket);\n      } else {\n        if (xhr.getStatus() === 403) {\n          newErr = errorsExports.unauthorized(location.path);\n        } else {\n          newErr = err;\n        }\n      }\n    }\n\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n\n  return errorHandler;\n}\nexport function objectErrorHandler(location) {\n  var shared = sharedErrorHandler(location);\n\n  function errorHandler(xhr, err) {\n    var newErr = shared(xhr, err);\n\n    if (xhr.getStatus() === 404) {\n      newErr = errorsExports.objectNotFound(location.path);\n    }\n\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n\n  return errorHandler;\n}\nexport function getMetadata(authWrapper, location, mappings) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'GET';\n  var timeout = authWrapper.maxOperationRetryTime();\n  var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nexport function updateMetadata(authWrapper, location, metadata, mappings) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'PATCH';\n  var body = MetadataUtils.toResourceString(metadata, mappings);\n  var headers = {\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  var timeout = authWrapper.maxOperationRetryTime();\n  var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nexport function deleteObject(authWrapper, location) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'DELETE';\n  var timeout = authWrapper.maxOperationRetryTime();\n\n  function handler(xhr, text) {}\n\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.successCodes = [200, 204];\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nexport function determineContentType_(metadata, blob) {\n  return metadata && metadata['contentType'] || blob && blob.type() || 'application/octet-stream';\n}\nexport function metadataForUpload_(location, blob, opt_metadata) {\n  var metadata = object.clone(opt_metadata);\n  metadata['fullPath'] = location.path;\n  metadata['size'] = blob.size();\n\n  if (!metadata['contentType']) {\n    metadata['contentType'] = determineContentType_(null, blob);\n  }\n\n  return metadata;\n}\nexport function multipartUpload(authWrapper, location, mappings, blob, opt_metadata) {\n  var urlPart = location.bucketOnlyServerUrl();\n  var headers = {\n    'X-Goog-Upload-Protocol': 'multipart'\n  };\n\n  function genBoundary() {\n    var str = '';\n\n    for (var i = 0; i < 2; i++) {\n      str = str + Math.random().toString().slice(2);\n    }\n\n    return str;\n  }\n\n  var boundary = genBoundary();\n  headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n  var metadata = metadataForUpload_(location, blob, opt_metadata);\n  var metadataString = MetadataUtils.toResourceString(metadata, mappings);\n  var preBlobPart = '--' + boundary + '\\r\\n' + 'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' + metadataString + '\\r\\n--' + boundary + '\\r\\n' + 'Content-Type: ' + metadata['contentType'] + '\\r\\n\\r\\n';\n  var postBlobPart = '\\r\\n--' + boundary + '--';\n  var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n\n  var urlParams = {\n    name: metadata['fullPath']\n  };\n  var url = UrlUtils.makeUploadUrl(urlPart);\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\r\n * @param current The number of bytes that have been uploaded so far.\r\n * @param total The total number of bytes in the upload.\r\n * @param opt_finalized True if the server has finished the upload.\r\n * @param opt_metadata The upload metadata, should\r\n *     only be passed if opt_finalized is true.\r\n * @struct\r\n */\n\nvar ResumableUploadStatus =\n/** @class */\nfunction () {\n  function ResumableUploadStatus(current, total, finalized, metadata) {\n    this.current = current;\n    this.total = total;\n    this.finalized = !!finalized;\n    this.metadata = metadata || null;\n  }\n\n  return ResumableUploadStatus;\n}();\n\nexport { ResumableUploadStatus };\nexport function checkResumeHeader_(xhr, opt_allowed) {\n  var status;\n\n  try {\n    status = xhr.getResponseHeader('X-Goog-Upload-Status');\n  } catch (e) {\n    handlerCheck(false);\n  }\n\n  var allowed = opt_allowed || ['active'];\n  handlerCheck(array.contains(allowed, status));\n  return status;\n}\nexport function createResumableUpload(authWrapper, location, mappings, blob, opt_metadata) {\n  var urlPart = location.bucketOnlyServerUrl();\n  var metadata = metadataForUpload_(location, blob, opt_metadata);\n  var urlParams = {\n    name: metadata['fullPath']\n  };\n  var url = UrlUtils.makeUploadUrl(urlPart);\n  var method = 'POST';\n  var headers = {\n    'X-Goog-Upload-Protocol': 'resumable',\n    'X-Goog-Upload-Command': 'start',\n    'X-Goog-Upload-Header-Content-Length': blob.size(),\n    'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  var body = MetadataUtils.toResourceString(metadata, mappings);\n  var timeout = authWrapper.maxUploadRetryTime();\n\n  function handler(xhr, text) {\n    checkResumeHeader_(xhr);\n    var url;\n\n    try {\n      url = xhr.getResponseHeader('X-Goog-Upload-URL');\n    } catch (e) {\n      handlerCheck(false);\n    }\n\n    handlerCheck(type.isString(url));\n    return url;\n  }\n\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\r\n * @param url From a call to fbs.requests.createResumableUpload.\r\n */\n\nexport function getResumableUploadStatus(authWrapper, location, url, blob) {\n  var headers = {\n    'X-Goog-Upload-Command': 'query'\n  };\n\n  function handler(xhr, text) {\n    var status = checkResumeHeader_(xhr, ['active', 'final']);\n    var sizeString;\n\n    try {\n      sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n    } catch (e) {\n      handlerCheck(false);\n    }\n\n    var size = parseInt(sizeString, 10);\n    handlerCheck(!isNaN(size));\n    return new ResumableUploadStatus(size, blob.size(), status === 'final');\n  }\n\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\r\n * Any uploads via the resumable upload API must transfer a number of bytes\r\n * that is a multiple of this number.\r\n */\n\nexport var resumableUploadChunkSize = 256 * 1024;\n/**\r\n * @param url From a call to fbs.requests.createResumableUpload.\r\n * @param chunkSize Number of bytes to upload.\r\n * @param opt_status The previous status.\r\n *     If not passed or null, we start from the beginning.\r\n * @throws fbs.Error If the upload is already complete, the passed in status\r\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\r\n *     for upload.\r\n */\n\nexport function continueResumableUpload(location, authWrapper, url, blob, chunkSize, mappings, opt_status, opt_progressCallback) {\n  // TODO(andysoto): standardize on internal asserts\n  // assert(!(opt_status && opt_status.finalized));\n  var status = new ResumableUploadStatus(0, 0);\n\n  if (opt_status) {\n    status.current = opt_status.current;\n    status.total = opt_status.total;\n  } else {\n    status.current = 0;\n    status.total = blob.size();\n  }\n\n  if (blob.size() !== status.total) {\n    throw errorsExports.serverFileWrongSize();\n  }\n\n  var bytesLeft = status.total - status.current;\n  var bytesToUpload = bytesLeft;\n\n  if (chunkSize > 0) {\n    bytesToUpload = Math.min(bytesToUpload, chunkSize);\n  }\n\n  var startByte = status.current;\n  var endByte = startByte + bytesToUpload;\n  var uploadCommand = bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n  var headers = {\n    'X-Goog-Upload-Command': uploadCommand,\n    'X-Goog-Upload-Offset': status.current\n  };\n  var body = blob.slice(startByte, endByte);\n\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n\n  function handler(xhr, text) {\n    // TODO(andysoto): Verify the MD5 of each uploaded range:\n    // the 'x-range-md5' header comes back with status code 308 responses.\n    // We'll only be able to bail out though, because you can't re-upload a\n    // range that you previously uploaded.\n    var uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n    var newCurrent = status.current + bytesToUpload;\n    var size = blob.size();\n    var metadata;\n\n    if (uploadStatus === 'final') {\n      metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n    } else {\n      metadata = null;\n    }\n\n    return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);\n  }\n\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.progressCallback = opt_progressCallback || null;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}","map":{"version":3,"mappings":"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","names":["array","FbsBlob","errorsExports","MetadataUtils","object","RequestInfo","type","UrlUtils","cndn","unknown","authWrapper","mappings","xhr","text","metadata","fromResourceString","handlerCheck","handler","location","err","newErr","getStatus","unauthenticated","quotaExceeded","bucket","unauthorized","path","setServerResponseProp","serverResponseProp","errorHandler","shared","sharedErrorHandler","objectNotFound","urlPart","fullServerUrl","url","makeNormalUrl","method","timeout","maxOperationRetryTime","requestInfo","metadataHandler","objectErrorHandler","body","toResourceString","headers","successCodes","blob","opt_metadata","clone","size","determineContentType_","bucketOnlyServerUrl","str","i","Math","random","toString","slice","boundary","genBoundary","metadataForUpload_","metadataString","preBlobPart","postBlobPart","getBlob","cannotSliceBlob","urlParams","name","makeUploadUrl","maxUploadRetryTime","uploadData","current","total","finalized","opt_allowed","status","getResponseHeader","e","allowed","contains","checkResumeHeader_","isString","sizeString","parseInt","isNaN","ResumableUploadStatus","resumableUploadChunkSize","chunkSize","opt_status","opt_progressCallback","serverFileWrongSize","bytesLeft","bytesToUpload","min","startByte","endByte","uploadCommand","uploadStatus","newCurrent","progressCallback"],"sources":["../src/implementation/requests.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines methods for interacting with the network.\n */\n\nimport { Metadata } from '../metadata';\n\nimport * as array from './array';\nimport { AuthWrapper } from './authwrapper';\nimport { FbsBlob } from './blob';\nimport * as errorsExports from './error';\nimport { FirebaseStorageError } from './error';\nimport { errors } from './error';\nimport { Location } from './location';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport { XhrIo } from './xhrio';\n\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\nexport function handlerCheck(cndn: boolean) {\n  if (!cndn) {\n    throw errorsExports.unknown();\n  }\n}\n\nexport function metadataHandler(\n  authWrapper: AuthWrapper,\n  mappings: MetadataUtils.Mappings\n): (p1: XhrIo, p2: string) => Metadata {\n  function handler(xhr: XhrIo, text: string): Metadata {\n    let metadata = MetadataUtils.fromResourceString(\n      authWrapper,\n      text,\n      mappings\n    );\n    handlerCheck(metadata !== null);\n    return metadata as Metadata;\n  }\n  return handler;\n}\n\nexport function sharedErrorHandler(\n  location: Location\n): (p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  function errorHandler(\n    xhr: XhrIo,\n    err: FirebaseStorageError\n  ): FirebaseStorageError {\n    let newErr;\n    if (xhr.getStatus() === 401) {\n      newErr = errorsExports.unauthenticated();\n    } else {\n      if (xhr.getStatus() === 402) {\n        newErr = errorsExports.quotaExceeded(location.bucket);\n      } else {\n        if (xhr.getStatus() === 403) {\n          newErr = errorsExports.unauthorized(location.path);\n        } else {\n          newErr = err;\n        }\n      }\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function objectErrorHandler(\n  location: Location\n): (p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  let shared = sharedErrorHandler(location);\n\n  function errorHandler(\n    xhr: XhrIo,\n    err: FirebaseStorageError\n  ): FirebaseStorageError {\n    let newErr = shared(xhr, err);\n    if (xhr.getStatus() === 404) {\n      newErr = errorsExports.objectNotFound(location.path);\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function getMetadata(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings\n): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'GET';\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function updateMetadata(\n  authWrapper: AuthWrapper,\n  location: Location,\n  metadata: Metadata,\n  mappings: MetadataUtils.Mappings\n): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'PATCH';\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let headers = { 'Content-Type': 'application/json; charset=utf-8' };\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function deleteObject(\n  authWrapper: AuthWrapper,\n  location: Location\n): RequestInfo<void> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'DELETE';\n  let timeout = authWrapper.maxOperationRetryTime();\n\n  function handler(xhr: XhrIo, text: string) {}\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.successCodes = [200, 204];\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function determineContentType_(\n  metadata: Metadata | null,\n  blob: FbsBlob | null\n): string {\n  return (\n    (metadata && metadata['contentType']) ||\n    (blob && blob.type()) ||\n    'application/octet-stream'\n  );\n}\n\nexport function metadataForUpload_(\n  location: Location,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): Metadata {\n  let metadata = object.clone<Metadata>(opt_metadata);\n  metadata['fullPath'] = location.path;\n  metadata['size'] = blob.size();\n  if (!metadata['contentType']) {\n    metadata['contentType'] = determineContentType_(null, blob);\n  }\n  return metadata;\n}\n\nexport function multipartUpload(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): RequestInfo<Metadata> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let headers: { [prop: string]: string } = {\n    'X-Goog-Upload-Protocol': 'multipart'\n  };\n\n  function genBoundary() {\n    let str = '';\n    for (let i = 0; i < 2; i++) {\n      str =\n        str +\n        Math.random()\n          .toString()\n          .slice(2);\n    }\n    return str;\n  }\n  let boundary = genBoundary();\n  headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let metadataString = MetadataUtils.toResourceString(metadata, mappings);\n  let preBlobPart =\n    '--' +\n    boundary +\n    '\\r\\n' +\n    'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' +\n    metadataString +\n    '\\r\\n--' +\n    boundary +\n    '\\r\\n' +\n    'Content-Type: ' +\n    metadata['contentType'] +\n    '\\r\\n\\r\\n';\n  let postBlobPart = '\\r\\n--' + boundary + '--';\n  let body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n  let urlParams = { name: metadata['fullPath'] };\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\nexport class ResumableUploadStatus {\n  finalized: boolean;\n  metadata: Metadata | null;\n\n  constructor(\n    public current: number,\n    public total: number,\n    finalized?: boolean,\n    metadata?: Metadata | null\n  ) {\n    this.finalized = !!finalized;\n    this.metadata = metadata || null;\n  }\n}\n\nexport function checkResumeHeader_(xhr: XhrIo, opt_allowed?: string[]): string {\n  let status;\n  try {\n    status = xhr.getResponseHeader('X-Goog-Upload-Status');\n  } catch (e) {\n    handlerCheck(false);\n  }\n  let allowed = opt_allowed || ['active'];\n  handlerCheck(array.contains(allowed, status));\n  return status as string;\n}\n\nexport function createResumableUpload(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): RequestInfo<string> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let urlParams = { name: metadata['fullPath'] };\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let headers = {\n    'X-Goog-Upload-Protocol': 'resumable',\n    'X-Goog-Upload-Command': 'start',\n    'X-Goog-Upload-Header-Content-Length': blob.size(),\n    'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let timeout = authWrapper.maxUploadRetryTime();\n\n  function handler(xhr: XhrIo, text: string): string {\n    checkResumeHeader_(xhr);\n    let url;\n    try {\n      url = xhr.getResponseHeader('X-Goog-Upload-URL');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    handlerCheck(type.isString(url));\n    return url as string;\n  }\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nexport function getResumableUploadStatus(\n  authWrapper: AuthWrapper,\n  location: Location,\n  url: string,\n  blob: FbsBlob\n): RequestInfo<ResumableUploadStatus> {\n  let headers = { 'X-Goog-Upload-Command': 'query' };\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    let status = checkResumeHeader_(xhr, ['active', 'final']);\n    let sizeString;\n    try {\n      sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    let size = parseInt(sizeString, 10);\n    handlerCheck(!isNaN(size));\n    return new ResumableUploadStatus(size, blob.size(), status === 'final');\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nexport const resumableUploadChunkSize: number = 256 * 1024;\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nexport function continueResumableUpload(\n  location: Location,\n  authWrapper: AuthWrapper,\n  url: string,\n  blob: FbsBlob,\n  chunkSize: number,\n  mappings: MetadataUtils.Mappings,\n  opt_status?: ResumableUploadStatus | null,\n  opt_progressCallback?: ((p1: number, p2: number) => void) | null\n): RequestInfo<ResumableUploadStatus> {\n  // TODO(andysoto): standardize on internal asserts\n  // assert(!(opt_status && opt_status.finalized));\n  let status = new ResumableUploadStatus(0, 0);\n  if (opt_status) {\n    status.current = opt_status.current;\n    status.total = opt_status.total;\n  } else {\n    status.current = 0;\n    status.total = blob.size();\n  }\n  if (blob.size() !== status.total) {\n    throw errorsExports.serverFileWrongSize();\n  }\n  let bytesLeft = status.total - status.current;\n  let bytesToUpload = bytesLeft;\n  if (chunkSize > 0) {\n    bytesToUpload = Math.min(bytesToUpload, chunkSize);\n  }\n  let startByte = status.current;\n  let endByte = startByte + bytesToUpload;\n  let uploadCommand =\n    bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n  let headers = {\n    'X-Goog-Upload-Command': uploadCommand,\n    'X-Goog-Upload-Offset': status.current\n  };\n  let body = blob.slice(startByte, endByte);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    // TODO(andysoto): Verify the MD5 of each uploaded range:\n    // the 'x-range-md5' header comes back with status code 308 responses.\n    // We'll only be able to bail out though, because you can't re-upload a\n    // range that you previously uploaded.\n    let uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n    let newCurrent = status.current + bytesToUpload;\n    let size = blob.size();\n    let metadata;\n    if (uploadStatus === 'final') {\n      metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n    } else {\n      metadata = null;\n    }\n    return new ResumableUploadStatus(\n      newCurrent,\n      size,\n      uploadStatus === 'final',\n      metadata\n    );\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.progressCallback = opt_progressCallback || null;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n"]},"metadata":{},"sourceType":"module"}