{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar KeyIndex_1 = require(\"../core/snap/indexes/KeyIndex\");\n\nvar PriorityIndex_1 = require(\"../core/snap/indexes/PriorityIndex\");\n\nvar ValueIndex_1 = require(\"../core/snap/indexes/ValueIndex\");\n\nvar PathIndex_1 = require(\"../core/snap/indexes/PathIndex\");\n\nvar util_2 = require(\"../core/util/util\");\n\nvar Path_1 = require(\"../core/util/Path\");\n\nvar validation_1 = require(\"../core/util/validation\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar EventRegistration_1 = require(\"../core/view/EventRegistration\");\n\nvar util_4 = require(\"@firebase/util\");\n\nvar __referenceConstructor;\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\n\n\nvar Query =\n/** @class */\nfunction () {\n  function Query(repo, path, queryParams_, orderByCalled_) {\n    this.repo = repo;\n    this.path = path;\n    this.queryParams_ = queryParams_;\n    this.orderByCalled_ = orderByCalled_;\n  }\n\n  Object.defineProperty(Query, \"__referenceConstructor\", {\n    get: function () {\n      util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');\n      return __referenceConstructor;\n    },\n    set: function (val) {\n      __referenceConstructor = val;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Validates start/end values for queries.\n   * @param {!QueryParams} params\n   * @private\n   */\n\n  Query.validateQueryEndpoints_ = function (params) {\n    var startNode = null;\n    var endNode = null;\n\n    if (params.hasStart()) {\n      startNode = params.getIndexStartValue();\n    }\n\n    if (params.hasEnd()) {\n      endNode = params.getIndexEndValue();\n    }\n\n    if (params.getIndex() === KeyIndex_1.KEY_INDEX) {\n      var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' + 'startAt(), endAt(), or equalTo().';\n      var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' + 'or equalTo() must be a string.';\n\n      if (params.hasStart()) {\n        var startName = params.getIndexStartName();\n\n        if (startName != util_2.MIN_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof startNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n\n      if (params.hasEnd()) {\n        var endName = params.getIndexEndName();\n\n        if (endName != util_2.MAX_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof endNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n    } else if (params.getIndex() === PriorityIndex_1.PRIORITY_INDEX) {\n      if (startNode != null && !validation_1.isValidPriority(startNode) || endNode != null && !validation_1.isValidPriority(endNode)) {\n        throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' + 'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');\n      }\n    } else {\n      util_1.assert(params.getIndex() instanceof PathIndex_1.PathIndex || params.getIndex() === ValueIndex_1.VALUE_INDEX, 'unknown index type.');\n\n      if (startNode != null && typeof startNode === 'object' || endNode != null && typeof endNode === 'object') {\n        throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' + 'an object.');\n      }\n    }\n  };\n  /**\n   * Validates that limit* has been called with the correct combination of parameters\n   * @param {!QueryParams} params\n   * @private\n   */\n\n\n  Query.validateLimit_ = function (params) {\n    if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {\n      throw new Error(\"Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.\");\n    }\n  };\n  /**\n   * Validates that no other order by call has been made\n   * @param {!string} fnName\n   * @private\n   */\n\n\n  Query.prototype.validateNoPreviousOrderByCall_ = function (fnName) {\n    if (this.orderByCalled_ === true) {\n      throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n  };\n  /**\n   * @return {!QueryParams}\n   */\n\n\n  Query.prototype.getQueryParams = function () {\n    return this.queryParams_;\n  };\n  /**\n   * @return {!Reference}\n   */\n\n\n  Query.prototype.getRef = function () {\n    util_3.validateArgCount('Query.ref', 0, 0, arguments.length); // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n    // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n    // method gets called.\n\n    return new Query.__referenceConstructor(this.repo, this.path);\n  };\n  /**\n   * @param {!string} eventType\n   * @param {!function(DataSnapshot, string=)} callback\n   * @param {(function(Error)|Object)=} cancelCallbackOrContext\n   * @param {Object=} context\n   * @return {!function(DataSnapshot, string=)}\n   */\n\n\n  Query.prototype.on = function (eventType, callback, cancelCallbackOrContext, context) {\n    util_3.validateArgCount('Query.on', 2, 4, arguments.length);\n    validation_1.validateEventType('Query.on', 1, eventType, false);\n    util_3.validateCallback('Query.on', 2, callback, false);\n    var ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);\n\n    if (eventType === 'value') {\n      this.onValueEvent(callback, ret.cancel, ret.context);\n    } else {\n      var callbacks = {};\n      callbacks[eventType] = callback;\n      this.onChildEvent(callbacks, ret.cancel, ret.context);\n    }\n\n    return callback;\n  };\n  /**\n   * @param {!function(!DataSnapshot)} callback\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n\n\n  Query.prototype.onValueEvent = function (callback, cancelCallback, context) {\n    var container = new EventRegistration_1.ValueEventRegistration(callback, cancelCallback || null, context || null);\n    this.repo.addEventCallbackForQuery(this, container);\n  };\n  /**\n   * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n\n\n  Query.prototype.onChildEvent = function (callbacks, cancelCallback, context) {\n    var container = new EventRegistration_1.ChildEventRegistration(callbacks, cancelCallback, context);\n    this.repo.addEventCallbackForQuery(this, container);\n  };\n  /**\n   * @param {string=} eventType\n   * @param {(function(!DataSnapshot, ?string=))=} callback\n   * @param {Object=} context\n   */\n\n\n  Query.prototype.off = function (eventType, callback, context) {\n    util_3.validateArgCount('Query.off', 0, 3, arguments.length);\n    validation_1.validateEventType('Query.off', 1, eventType, true);\n    util_3.validateCallback('Query.off', 2, callback, true);\n    util_3.validateContextObject('Query.off', 3, context, true);\n    var container = null;\n    var callbacks = null;\n\n    if (eventType === 'value') {\n      var valueCallback = callback || null;\n      container = new EventRegistration_1.ValueEventRegistration(valueCallback, null, context || null);\n    } else if (eventType) {\n      if (callback) {\n        callbacks = {};\n        callbacks[eventType] = callback;\n      }\n\n      container = new EventRegistration_1.ChildEventRegistration(callbacks, null, context || null);\n    }\n\n    this.repo.removeEventCallbackForQuery(this, container);\n  };\n  /**\n   * Attaches a listener, waits for the first event, and then removes the listener\n   * @param {!string} eventType\n   * @param {!function(!DataSnapshot, string=)} userCallback\n   * @param cancelOrContext\n   * @param context\n   * @return {!firebase.Promise}\n   */\n\n\n  Query.prototype.once = function (eventType, userCallback, cancelOrContext, context) {\n    var _this = this;\n\n    util_3.validateArgCount('Query.once', 1, 4, arguments.length);\n    validation_1.validateEventType('Query.once', 1, eventType, false);\n    util_3.validateCallback('Query.once', 2, userCallback, true);\n    var ret = Query.getCancelAndContextArgs_('Query.once', cancelOrContext, context); // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n    // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n    // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n    // against the Promise specification.\n\n    var firstCall = true;\n    var deferred = new util_4.Deferred(); // A dummy error handler in case a user wasn't expecting promises\n\n    deferred.promise.catch(function () {});\n\n    var onceCallback = function (snapshot) {\n      // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n      // triggers multiple events (e.g. child_added or child_changed).\n      if (firstCall) {\n        firstCall = false;\n\n        _this.off(eventType, onceCallback);\n\n        if (userCallback) {\n          userCallback.bind(ret.context)(snapshot);\n        }\n\n        deferred.resolve(snapshot);\n      }\n    };\n\n    this.on(eventType, onceCallback,\n    /*cancel=*/\n    function (err) {\n      _this.off(eventType, onceCallback);\n\n      if (ret.cancel) ret.cancel.bind(ret.context)(err);\n      deferred.reject(err);\n    });\n    return deferred.promise;\n  };\n  /**\n   * Set a limit and anchor it to the start of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n\n\n  Query.prototype.limitToFirst = function (limit) {\n    util_3.validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\n      throw new Error('Query.limitToFirst: First argument must be a positive integer.');\n    }\n\n    if (this.queryParams_.hasLimit()) {\n      throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' + 'limitToFirst, or limitToLast).');\n    }\n\n    return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);\n  };\n  /**\n   * Set a limit and anchor it to the end of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n\n\n  Query.prototype.limitToLast = function (limit) {\n    util_3.validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\n      throw new Error('Query.limitToLast: First argument must be a positive integer.');\n    }\n\n    if (this.queryParams_.hasLimit()) {\n      throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' + 'limitToFirst, or limitToLast).');\n    }\n\n    return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);\n  };\n  /**\n   * Given a child path, return a new query ordered by the specified grandchild path.\n   * @param {!string} path\n   * @return {!Query}\n   */\n\n\n  Query.prototype.orderByChild = function (path) {\n    util_3.validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n\n    if (path === '$key') {\n      throw new Error('Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.');\n    } else if (path === '$priority') {\n      throw new Error('Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.');\n    } else if (path === '$value') {\n      throw new Error('Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.');\n    }\n\n    validation_1.validatePathString('Query.orderByChild', 1, path, false);\n    this.validateNoPreviousOrderByCall_('Query.orderByChild');\n    var parsedPath = new Path_1.Path(path);\n\n    if (parsedPath.isEmpty()) {\n      throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');\n    }\n\n    var index = new PathIndex_1.PathIndex(parsedPath);\n    var newParams = this.queryParams_.orderBy(index);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams,\n    /*orderByCalled=*/\n    true);\n  };\n  /**\n   * Return a new query ordered by the KeyIndex\n   * @return {!Query}\n   */\n\n\n  Query.prototype.orderByKey = function () {\n    util_3.validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByKey');\n    var newParams = this.queryParams_.orderBy(KeyIndex_1.KEY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams,\n    /*orderByCalled=*/\n    true);\n  };\n  /**\n   * Return a new query ordered by the PriorityIndex\n   * @return {!Query}\n   */\n\n\n  Query.prototype.orderByPriority = function () {\n    util_3.validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n    var newParams = this.queryParams_.orderBy(PriorityIndex_1.PRIORITY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams,\n    /*orderByCalled=*/\n    true);\n  };\n  /**\n   * Return a new query ordered by the ValueIndex\n   * @return {!Query}\n   */\n\n\n  Query.prototype.orderByValue = function () {\n    util_3.validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByValue');\n    var newParams = this.queryParams_.orderBy(ValueIndex_1.VALUE_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams,\n    /*orderByCalled=*/\n    true);\n  };\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n\n\n  Query.prototype.startAt = function (value, name) {\n    if (value === void 0) {\n      value = null;\n    }\n\n    util_3.validateArgCount('Query.startAt', 0, 2, arguments.length);\n    validation_1.validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n    validation_1.validateKey('Query.startAt', 2, name, true);\n    var newParams = this.queryParams_.startAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n\n    if (this.queryParams_.hasStart()) {\n      throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' + 'or equalTo).');\n    } // Calling with no params tells us to start at the beginning.\n\n\n    if (value === undefined) {\n      value = null;\n      name = null;\n    }\n\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  };\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n\n\n  Query.prototype.endAt = function (value, name) {\n    if (value === void 0) {\n      value = null;\n    }\n\n    util_3.validateArgCount('Query.endAt', 0, 2, arguments.length);\n    validation_1.validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n    validation_1.validateKey('Query.endAt', 2, name, true);\n    var newParams = this.queryParams_.endAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n\n    if (this.queryParams_.hasEnd()) {\n      throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' + 'equalTo).');\n    }\n\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  };\n  /**\n   * Load the selection of children with exactly the specified value, and, optionally,\n   * the specified name.\n   * @param {number|string|boolean|null} value\n   * @param {string=} name\n   * @return {!Query}\n   */\n\n\n  Query.prototype.equalTo = function (value, name) {\n    util_3.validateArgCount('Query.equalTo', 1, 2, arguments.length);\n    validation_1.validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n    validation_1.validateKey('Query.equalTo', 2, name, true);\n\n    if (this.queryParams_.hasStart()) {\n      throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' + 'equalTo).');\n    }\n\n    if (this.queryParams_.hasEnd()) {\n      throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' + 'equalTo).');\n    }\n\n    return this.startAt(value, name).endAt(value, name);\n  };\n  /**\n   * @return {!string} URL for this location.\n   */\n\n\n  Query.prototype.toString = function () {\n    util_3.validateArgCount('Query.toString', 0, 0, arguments.length);\n    return this.repo.toString() + this.path.toUrlEncodedString();\n  }; // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users.\n\n\n  Query.prototype.toJSON = function () {\n    // An optional spacer argument is unnecessary for a string.\n    util_3.validateArgCount('Query.toJSON', 0, 1, arguments.length);\n    return this.toString();\n  };\n  /**\n   * An object representation of the query parameters used by this Query.\n   * @return {!Object}\n   */\n\n\n  Query.prototype.queryObject = function () {\n    return this.queryParams_.getQueryObject();\n  };\n  /**\n   * @return {!string}\n   */\n\n\n  Query.prototype.queryIdentifier = function () {\n    var obj = this.queryObject();\n    var id = util_2.ObjectToUniqueKey(obj);\n    return id === '{}' ? 'default' : id;\n  };\n  /**\n   * Return true if this query and the provided query are equivalent; otherwise, return false.\n   * @param {Query} other\n   * @return {boolean}\n   */\n\n\n  Query.prototype.isEqual = function (other) {\n    util_3.validateArgCount('Query.isEqual', 1, 1, arguments.length);\n\n    if (!(other instanceof Query)) {\n      var error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n      throw new Error(error);\n    }\n\n    var sameRepo = this.repo === other.repo;\n    var samePath = this.path.equals(other.path);\n    var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();\n    return sameRepo && samePath && sameQueryIdentifier;\n  };\n  /**\n   * Helper used by .on and .once to extract the context and or cancel arguments.\n   * @param {!string} fnName The function name (on or once)\n   * @param {(function(Error)|Object)=} cancelOrContext\n   * @param {Object=} context\n   * @return {{cancel: ?function(Error), context: ?Object}}\n   * @private\n   */\n\n\n  Query.getCancelAndContextArgs_ = function (fnName, cancelOrContext, context) {\n    var ret = {\n      cancel: null,\n      context: null\n    };\n\n    if (cancelOrContext && context) {\n      ret.cancel = cancelOrContext;\n      util_3.validateCallback(fnName, 3, ret.cancel, true);\n      ret.context = context;\n      util_3.validateContextObject(fnName, 4, ret.context, true);\n    } else if (cancelOrContext) {\n      // we have either a cancel callback or a context.\n      if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\n        // it's a context!\n        ret.context = cancelOrContext;\n      } else if (typeof cancelOrContext === 'function') {\n        ret.cancel = cancelOrContext;\n      } else {\n        throw new Error(util_3.errorPrefix(fnName, 3, true) + ' must either be a cancel callback or a context object.');\n      }\n    }\n\n    return ret;\n  };\n\n  Object.defineProperty(Query.prototype, \"ref\", {\n    get: function () {\n      return this.getRef();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Query;\n}();\n\nexports.Query = Query;","map":{"version":3,"mappings":"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","names":["__referenceConstructor","repo","path","queryParams_","orderByCalled_","Object","Query","util_1","val","params","startNode","endNode","hasStart","getIndexStartValue","hasEnd","getIndexEndValue","getIndex","KeyIndex_1","tooManyArgsError","wrongArgTypeError","startName","getIndexStartName","util_2","Error","endName","getIndexEndName","PriorityIndex_1","validation_1","PathIndex_1","ValueIndex_1","hasLimit","hasAnchoredLimit","fnName","util_3","arguments","length","eventType","callback","cancelCallbackOrContext","context","ret","getCancelAndContextArgs_","onValueEvent","cancel","callbacks","onChildEvent","cancelCallback","container","EventRegistration_1","addEventCallbackForQuery","valueCallback","removeEventCallbackForQuery","userCallback","cancelOrContext","firstCall","deferred","util_4","promise","catch","onceCallback","snapshot","_this","off","bind","resolve","on","err","reject","limit","Math","floor","limitToFirst","limitToLast","validateNoPreviousOrderByCall_","parsedPath","Path_1","isEmpty","index","newParams","orderBy","validateQueryEndpoints_","value","name","startAt","validateLimit_","undefined","endAt","toString","toUrlEncodedString","getQueryObject","obj","queryObject","id","other","error","sameRepo","samePath","equals","sameQueryIdentifier","queryIdentifier","getRef","exports"],"sources":["../src/api/Query.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { KEY_INDEX } from '../core/snap/indexes/KeyIndex';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { VALUE_INDEX } from '../core/snap/indexes/ValueIndex';\nimport { PathIndex } from '../core/snap/indexes/PathIndex';\nimport { MIN_NAME, MAX_NAME, ObjectToUniqueKey } from '../core/util/util';\nimport { Path } from '../core/util/Path';\nimport {\n  isValidPriority,\n  validateEventType,\n  validatePathString,\n  validateFirebaseDataArg,\n  validateKey\n} from '../core/util/validation';\nimport {\n  errorPrefix,\n  validateArgCount,\n  validateCallback,\n  validateContextObject\n} from '@firebase/util';\nimport {\n  ValueEventRegistration,\n  ChildEventRegistration,\n  EventRegistration\n} from '../core/view/EventRegistration';\nimport { Deferred } from '@firebase/util';\nimport { Repo } from '../core/Repo';\nimport { QueryParams } from '../core/view/QueryParams';\nimport { Reference } from './Reference';\nimport { DataSnapshot } from './DataSnapshot';\n\nlet __referenceConstructor: new (repo: Repo, path: Path) => Query;\n\nexport interface SnapshotCallback {\n  (a: DataSnapshot, b?: string): any;\n}\n\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\nexport class Query {\n  static set __referenceConstructor(val) {\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  constructor(\n    public repo: Repo,\n    public path: Path,\n    private queryParams_: QueryParams,\n    private orderByCalled_: boolean\n  ) {}\n\n  /**\n   * Validates start/end values for queries.\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateQueryEndpoints_(params: QueryParams) {\n    let startNode = null;\n    let endNode = null;\n    if (params.hasStart()) {\n      startNode = params.getIndexStartValue();\n    }\n    if (params.hasEnd()) {\n      endNode = params.getIndexEndValue();\n    }\n\n    if (params.getIndex() === KEY_INDEX) {\n      const tooManyArgsError =\n        'Query: When ordering by key, you may only pass one argument to ' +\n        'startAt(), endAt(), or equalTo().';\n      const wrongArgTypeError =\n        'Query: When ordering by key, the argument passed to startAt(), endAt(),' +\n        'or equalTo() must be a string.';\n      if (params.hasStart()) {\n        const startName = params.getIndexStartName();\n        if (startName != MIN_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof startNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n      if (params.hasEnd()) {\n        const endName = params.getIndexEndName();\n        if (endName != MAX_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof endNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n    } else if (params.getIndex() === PRIORITY_INDEX) {\n      if (\n        (startNode != null && !isValidPriority(startNode)) ||\n        (endNode != null && !isValidPriority(endNode))\n      ) {\n        throw new Error(\n          'Query: When ordering by priority, the first argument passed to startAt(), ' +\n            'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).'\n        );\n      }\n    } else {\n      assert(\n        params.getIndex() instanceof PathIndex ||\n          params.getIndex() === VALUE_INDEX,\n        'unknown index type.'\n      );\n      if (\n        (startNode != null && typeof startNode === 'object') ||\n        (endNode != null && typeof endNode === 'object')\n      ) {\n        throw new Error(\n          'Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +\n            'an object.'\n        );\n      }\n    }\n  }\n\n  /**\n   * Validates that limit* has been called with the correct combination of parameters\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateLimit_(params: QueryParams) {\n    if (\n      params.hasStart() &&\n      params.hasEnd() &&\n      params.hasLimit() &&\n      !params.hasAnchoredLimit()\n    ) {\n      throw new Error(\n        \"Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.\"\n      );\n    }\n  }\n\n  /**\n   * Validates that no other order by call has been made\n   * @param {!string} fnName\n   * @private\n   */\n  private validateNoPreviousOrderByCall_(fnName: string) {\n    if (this.orderByCalled_ === true) {\n      throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n  }\n\n  /**\n   * @return {!QueryParams}\n   */\n  getQueryParams(): QueryParams {\n    return this.queryParams_;\n  }\n\n  /**\n   * @return {!Reference}\n   */\n  getRef(): Reference {\n    validateArgCount('Query.ref', 0, 0, arguments.length);\n    // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n    // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n    // method gets called.\n    return new Query.__referenceConstructor(this.repo, this.path) as Reference;\n  }\n\n  /**\n   * @param {!string} eventType\n   * @param {!function(DataSnapshot, string=)} callback\n   * @param {(function(Error)|Object)=} cancelCallbackOrContext\n   * @param {Object=} context\n   * @return {!function(DataSnapshot, string=)}\n   */\n  on(\n    eventType: string,\n    callback: SnapshotCallback,\n    cancelCallbackOrContext?: ((a: Error) => any) | Object,\n    context?: Object\n  ): SnapshotCallback {\n    validateArgCount('Query.on', 2, 4, arguments.length);\n    validateEventType('Query.on', 1, eventType, false);\n    validateCallback('Query.on', 2, callback, false);\n\n    const ret = Query.getCancelAndContextArgs_(\n      'Query.on',\n      cancelCallbackOrContext,\n      context\n    );\n\n    if (eventType === 'value') {\n      this.onValueEvent(callback, ret.cancel, ret.context);\n    } else {\n      const callbacks: { [k: string]: typeof callback } = {};\n      callbacks[eventType] = callback;\n      this.onChildEvent(callbacks, ret.cancel, ret.context);\n    }\n    return callback;\n  }\n\n  /**\n   * @param {!function(!DataSnapshot)} callback\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  protected onValueEvent(\n    callback: (a: DataSnapshot) => void,\n    cancelCallback: ((a: Error) => void) | null,\n    context: Object | null\n  ) {\n    const container = new ValueEventRegistration(\n      callback,\n      cancelCallback || null,\n      context || null\n    );\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  onChildEvent(\n    callbacks: { [k: string]: SnapshotCallback },\n    cancelCallback: ((a: Error) => any) | null,\n    context: Object | null\n  ) {\n    const container = new ChildEventRegistration(\n      callbacks,\n      cancelCallback,\n      context\n    );\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {string=} eventType\n   * @param {(function(!DataSnapshot, ?string=))=} callback\n   * @param {Object=} context\n   */\n  off(eventType?: string, callback?: SnapshotCallback, context?: Object) {\n    validateArgCount('Query.off', 0, 3, arguments.length);\n    validateEventType('Query.off', 1, eventType, true);\n    validateCallback('Query.off', 2, callback, true);\n    validateContextObject('Query.off', 3, context, true);\n\n    let container: EventRegistration | null = null;\n    let callbacks: { [k: string]: typeof callback } | null = null;\n    if (eventType === 'value') {\n      const valueCallback = callback || null;\n      container = new ValueEventRegistration(\n        valueCallback,\n        null,\n        context || null\n      );\n    } else if (eventType) {\n      if (callback) {\n        callbacks = {};\n        callbacks[eventType] = callback;\n      }\n      container = new ChildEventRegistration(callbacks, null, context || null);\n    }\n    this.repo.removeEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * Attaches a listener, waits for the first event, and then removes the listener\n   * @param {!string} eventType\n   * @param {!function(!DataSnapshot, string=)} userCallback\n   * @param cancelOrContext\n   * @param context\n   * @return {!firebase.Promise}\n   */\n  once(\n    eventType: string,\n    userCallback?: SnapshotCallback,\n    cancelOrContext?: ((a: Error) => void) | Object,\n    context?: Object\n  ): Promise<DataSnapshot> {\n    validateArgCount('Query.once', 1, 4, arguments.length);\n    validateEventType('Query.once', 1, eventType, false);\n    validateCallback('Query.once', 2, userCallback, true);\n\n    const ret = Query.getCancelAndContextArgs_(\n      'Query.once',\n      cancelOrContext,\n      context\n    );\n\n    // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n    // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n    // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n    // against the Promise specification.\n    let firstCall = true;\n    const deferred = new Deferred<DataSnapshot>();\n\n    // A dummy error handler in case a user wasn't expecting promises\n    deferred.promise.catch(() => {});\n\n    const onceCallback = (snapshot: DataSnapshot) => {\n      // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n      // triggers multiple events (e.g. child_added or child_changed).\n      if (firstCall) {\n        firstCall = false;\n        this.off(eventType, onceCallback);\n\n        if (userCallback) {\n          userCallback.bind(ret.context)(snapshot);\n        }\n        deferred.resolve(snapshot);\n      }\n    };\n\n    this.on(\n      eventType,\n      onceCallback,\n      /*cancel=*/ err => {\n        this.off(eventType, onceCallback);\n\n        if (ret.cancel) ret.cancel.bind(ret.context)(err);\n        deferred.reject(err);\n      }\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * Set a limit and anchor it to the start of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToFirst(limit: number): Query {\n    validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n    if (\n      typeof limit !== 'number' ||\n      Math.floor(limit) !== limit ||\n      limit <= 0\n    ) {\n      throw new Error(\n        'Query.limitToFirst: First argument must be a positive integer.'\n      );\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error(\n        'Query.limitToFirst: Limit was already set (by another call to limit, ' +\n          'limitToFirst, or limitToLast).'\n      );\n    }\n\n    return new Query(\n      this.repo,\n      this.path,\n      this.queryParams_.limitToFirst(limit),\n      this.orderByCalled_\n    );\n  }\n\n  /**\n   * Set a limit and anchor it to the end of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToLast(limit: number): Query {\n    validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n    if (\n      typeof limit !== 'number' ||\n      Math.floor(limit) !== limit ||\n      limit <= 0\n    ) {\n      throw new Error(\n        'Query.limitToLast: First argument must be a positive integer.'\n      );\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error(\n        'Query.limitToLast: Limit was already set (by another call to limit, ' +\n          'limitToFirst, or limitToLast).'\n      );\n    }\n\n    return new Query(\n      this.repo,\n      this.path,\n      this.queryParams_.limitToLast(limit),\n      this.orderByCalled_\n    );\n  }\n\n  /**\n   * Given a child path, return a new query ordered by the specified grandchild path.\n   * @param {!string} path\n   * @return {!Query}\n   */\n  orderByChild(path: string): Query {\n    validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n    if (path === '$key') {\n      throw new Error(\n        'Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.'\n      );\n    } else if (path === '$priority') {\n      throw new Error(\n        'Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.'\n      );\n    } else if (path === '$value') {\n      throw new Error(\n        'Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.'\n      );\n    }\n    validatePathString('Query.orderByChild', 1, path, false);\n    this.validateNoPreviousOrderByCall_('Query.orderByChild');\n    const parsedPath = new Path(path);\n    if (parsedPath.isEmpty()) {\n      throw new Error(\n        'Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.'\n      );\n    }\n    const index = new PathIndex(parsedPath);\n    const newParams = this.queryParams_.orderBy(index);\n    Query.validateQueryEndpoints_(newParams);\n\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the KeyIndex\n   * @return {!Query}\n   */\n  orderByKey(): Query {\n    validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByKey');\n    const newParams = this.queryParams_.orderBy(KEY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the PriorityIndex\n   * @return {!Query}\n   */\n  orderByPriority(): Query {\n    validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n    const newParams = this.queryParams_.orderBy(PRIORITY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the ValueIndex\n   * @return {!Query}\n   */\n  orderByValue(): Query {\n    validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByValue');\n    const newParams = this.queryParams_.orderBy(VALUE_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  startAt(\n    value: number | string | boolean | null = null,\n    name?: string | null\n  ): Query {\n    validateArgCount('Query.startAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n    validateKey('Query.startAt', 2, name, true);\n\n    const newParams = this.queryParams_.startAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasStart()) {\n      throw new Error(\n        'Query.startAt: Starting point was already set (by another call to startAt ' +\n          'or equalTo).'\n      );\n    }\n\n    // Calling with no params tells us to start at the beginning.\n    if (value === undefined) {\n      value = null;\n      name = null;\n    }\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  endAt(\n    value: number | string | boolean | null = null,\n    name?: string | null\n  ): Query {\n    validateArgCount('Query.endAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n    validateKey('Query.endAt', 2, name, true);\n\n    const newParams = this.queryParams_.endAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasEnd()) {\n      throw new Error(\n        'Query.endAt: Ending point was already set (by another call to endAt or ' +\n          'equalTo).'\n      );\n    }\n\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * Load the selection of children with exactly the specified value, and, optionally,\n   * the specified name.\n   * @param {number|string|boolean|null} value\n   * @param {string=} name\n   * @return {!Query}\n   */\n  equalTo(value: number | string | boolean | null, name?: string) {\n    validateArgCount('Query.equalTo', 1, 2, arguments.length);\n    validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n    validateKey('Query.equalTo', 2, name, true);\n    if (this.queryParams_.hasStart()) {\n      throw new Error(\n        'Query.equalTo: Starting point was already set (by another call to startAt or ' +\n          'equalTo).'\n      );\n    }\n    if (this.queryParams_.hasEnd()) {\n      throw new Error(\n        'Query.equalTo: Ending point was already set (by another call to endAt or ' +\n          'equalTo).'\n      );\n    }\n    return this.startAt(value, name).endAt(value, name);\n  }\n\n  /**\n   * @return {!string} URL for this location.\n   */\n  toString(): string {\n    validateArgCount('Query.toString', 0, 0, arguments.length);\n\n    return this.repo.toString() + this.path.toUrlEncodedString();\n  }\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users.\n  toJSON() {\n    // An optional spacer argument is unnecessary for a string.\n    validateArgCount('Query.toJSON', 0, 1, arguments.length);\n    return this.toString();\n  }\n\n  /**\n   * An object representation of the query parameters used by this Query.\n   * @return {!Object}\n   */\n  queryObject(): Object {\n    return this.queryParams_.getQueryObject();\n  }\n\n  /**\n   * @return {!string}\n   */\n  queryIdentifier(): string {\n    const obj = this.queryObject();\n    const id = ObjectToUniqueKey(obj);\n    return id === '{}' ? 'default' : id;\n  }\n\n  /**\n   * Return true if this query and the provided query are equivalent; otherwise, return false.\n   * @param {Query} other\n   * @return {boolean}\n   */\n  isEqual(other: Query): boolean {\n    validateArgCount('Query.isEqual', 1, 1, arguments.length);\n    if (!(other instanceof Query)) {\n      const error =\n        'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n      throw new Error(error);\n    }\n\n    const sameRepo = this.repo === other.repo;\n    const samePath = this.path.equals(other.path);\n    const sameQueryIdentifier =\n      this.queryIdentifier() === other.queryIdentifier();\n\n    return sameRepo && samePath && sameQueryIdentifier;\n  }\n\n  /**\n   * Helper used by .on and .once to extract the context and or cancel arguments.\n   * @param {!string} fnName The function name (on or once)\n   * @param {(function(Error)|Object)=} cancelOrContext\n   * @param {Object=} context\n   * @return {{cancel: ?function(Error), context: ?Object}}\n   * @private\n   */\n  private static getCancelAndContextArgs_(\n    fnName: string,\n    cancelOrContext?: ((a: Error) => void) | Object,\n    context?: Object\n  ): { cancel: ((a: Error) => void) | null; context: Object | null } {\n    const ret: {\n      cancel: ((a: Error) => void) | null;\n      context: Object | null;\n    } = { cancel: null, context: null };\n    if (cancelOrContext && context) {\n      ret.cancel = cancelOrContext as (a: Error) => void;\n      validateCallback(fnName, 3, ret.cancel, true);\n\n      ret.context = context;\n      validateContextObject(fnName, 4, ret.context, true);\n    } else if (cancelOrContext) {\n      // we have either a cancel callback or a context.\n      if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\n        // it's a context!\n        ret.context = cancelOrContext;\n      } else if (typeof cancelOrContext === 'function') {\n        ret.cancel = cancelOrContext;\n      } else {\n        throw new Error(\n          errorPrefix(fnName, 3, true) +\n            ' must either be a cancel callback or a context object.'\n        );\n      }\n    }\n    return ret;\n  }\n\n  get ref(): Reference {\n    return this.getRef();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}