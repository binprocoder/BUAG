{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"./util/util\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar util_4 = require(\"@firebase/util\");\n\nvar util_5 = require(\"@firebase/util\");\n\nvar ServerActions_1 = require(\"./ServerActions\");\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\n\n\nvar ReadonlyRestClient =\n/** @class */\nfunction (_super) {\n  __extends(ReadonlyRestClient, _super);\n  /**\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param {AuthTokenProvider} authTokenProvider_\n   * @implements {ServerActions}\n   */\n\n\n  function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) {\n    var _this = _super.call(this) || this;\n\n    _this.repoInfo_ = repoInfo_;\n    _this.onDataUpdate_ = onDataUpdate_;\n    _this.authTokenProvider_ = authTokenProvider_;\n    /** @private {function(...[*])} */\n\n    _this.log_ = util_2.logWrapper('p:rest:');\n    /**\n     * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n     * that's been removed. :-/\n     *\n     * @private {!Object.<string, !Object>}\n     */\n\n    _this.listens_ = {};\n    return _this;\n  }\n\n  ReadonlyRestClient.prototype.reportStats = function (stats) {\n    throw new Error('Method not implemented.');\n  };\n  /**\n   * @param {!Query} query\n   * @param {?number=} tag\n   * @return {string}\n   * @private\n   */\n\n\n  ReadonlyRestClient.getListenId_ = function (query, tag) {\n    if (tag !== undefined) {\n      return 'tag$' + tag;\n    } else {\n      util_1.assert(query.getQueryParams().isDefault(), \"should have a tag if it's not a default query.\");\n      return query.path.toString();\n    }\n  };\n  /** @inheritDoc */\n\n\n  ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) {\n    var _this = this;\n\n    var pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier()); // Mark this listener so we can tell if it's removed.\n\n    var listenId = ReadonlyRestClient.getListenId_(query, tag);\n    var thisListen = {};\n    this.listens_[listenId] = thisListen;\n    var queryStringParamaters = query.getQueryParams().toRestQueryStringParameters();\n    this.restRequest_(pathString + '.json', queryStringParamaters, function (error, result) {\n      var data = result;\n\n      if (error === 404) {\n        data = null;\n        error = null;\n      }\n\n      if (error === null) {\n        _this.onDataUpdate_(pathString, data,\n        /*isMerge=*/\n        false, tag);\n      }\n\n      if (util_4.safeGet(_this.listens_, listenId) === thisListen) {\n        var status_1;\n\n        if (!error) {\n          status_1 = 'ok';\n        } else if (error == 401) {\n          status_1 = 'permission_denied';\n        } else {\n          status_1 = 'rest_error:' + error;\n        }\n\n        onComplete(status_1, null);\n      }\n    });\n  };\n  /** @inheritDoc */\n\n\n  ReadonlyRestClient.prototype.unlisten = function (query, tag) {\n    var listenId = ReadonlyRestClient.getListenId_(query, tag);\n    delete this.listens_[listenId];\n  };\n  /** @inheritDoc */\n\n\n  ReadonlyRestClient.prototype.refreshAuthToken = function (token) {// no-op since we just always call getToken.\n  };\n  /**\n   * Performs a REST request to the given path, with the provided query string parameters,\n   * and any auth credentials we have.\n   *\n   * @param {!string} pathString\n   * @param {!Object.<string, *>} queryStringParameters\n   * @param {?function(?number, *=)} callback\n   * @private\n   */\n\n\n  ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) {\n    var _this = this;\n\n    if (queryStringParameters === void 0) {\n      queryStringParameters = {};\n    }\n\n    queryStringParameters['format'] = 'export';\n    this.authTokenProvider_.getToken(\n    /*forceRefresh=*/\n    false).then(function (authTokenData) {\n      var authToken = authTokenData && authTokenData.accessToken;\n\n      if (authToken) {\n        queryStringParameters['auth'] = authToken;\n      }\n\n      var url = (_this.repoInfo_.secure ? 'https://' : 'http://') + _this.repoInfo_.host + pathString + '?' + util_5.querystring(queryStringParameters);\n\n      _this.log_('Sending REST request for ' + url);\n\n      var xhr = new XMLHttpRequest();\n\n      xhr.onreadystatechange = function () {\n        if (callback && xhr.readyState === 4) {\n          _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);\n\n          var res = null;\n\n          if (xhr.status >= 200 && xhr.status < 300) {\n            try {\n              res = util_3.jsonEval(xhr.responseText);\n            } catch (e) {\n              util_2.warn('Failed to parse JSON response for ' + url + ': ' + xhr.responseText);\n            }\n\n            callback(null, res);\n          } else {\n            // 401 and 404 are expected.\n            if (xhr.status !== 401 && xhr.status !== 404) {\n              util_2.warn('Got unsuccessful REST response for ' + url + ' Status: ' + xhr.status);\n            }\n\n            callback(xhr.status);\n          }\n\n          callback = null;\n        }\n      };\n\n      xhr.open('GET', url,\n      /*asynchronous=*/\n      true);\n      xhr.send();\n    });\n  };\n\n  return ReadonlyRestClient;\n}(ServerActions_1.ServerActions);\n\nexports.ReadonlyRestClient = ReadonlyRestClient;","map":{"version":3,"mappings":"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","names":["__extends","repoInfo_","onDataUpdate_","authTokenProvider_","_super","_this","util_2","ReadonlyRestClient","stats","Error","query","tag","undefined","util_1","getQueryParams","isDefault","path","toString","currentHashFn","onComplete","pathString","log_","queryIdentifier","listenId","getListenId_","thisListen","listens_","queryStringParamaters","toRestQueryStringParameters","restRequest_","error","result","data","util_4","status_1","token","queryStringParameters","callback","getToken","then","authToken","authTokenData","accessToken","url","secure","host","util_5","xhr","XMLHttpRequest","onreadystatechange","readyState","status","responseText","res","util_3","e","open","send","ServerActions_1","exports"],"sources":["../src/core/ReadonlyRestClient.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { logWrapper, warn } from './util/util';\nimport { jsonEval } from '@firebase/util';\nimport { safeGet } from '@firebase/util';\nimport { querystring } from '@firebase/util';\nimport { ServerActions } from './ServerActions';\nimport { RepoInfo } from './RepoInfo';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { Query } from '../api/Query';\n\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\nexport class ReadonlyRestClient extends ServerActions {\n  reportStats(stats: { [k: string]: any }): void {\n    throw new Error('Method not implemented.');\n  }\n\n  /** @private {function(...[*])} */\n  private log_: (...args: any[]) => void = logWrapper('p:rest:');\n\n  /**\n   * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n   * that's been removed. :-/\n   *\n   * @private {!Object.<string, !Object>}\n   */\n  private listens_: { [k: string]: Object } = {};\n\n  /**\n   * @param {!Query} query\n   * @param {?number=} tag\n   * @return {string}\n   * @private\n   */\n  static getListenId_(query: Query, tag?: number | null): string {\n    if (tag !== undefined) {\n      return 'tag$' + tag;\n    } else {\n      assert(\n        query.getQueryParams().isDefault(),\n        \"should have a tag if it's not a default query.\"\n      );\n      return query.path.toString();\n    }\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param {AuthTokenProvider} authTokenProvider_\n   * @implements {ServerActions}\n   */\n  constructor(\n    private repoInfo_: RepoInfo,\n    private onDataUpdate_: (\n      a: string,\n      b: any,\n      c: boolean,\n      d: number | null\n    ) => void,\n    private authTokenProvider_: AuthTokenProvider\n  ) {\n    super();\n  }\n\n  /** @inheritDoc */\n  listen(\n    query: Query,\n    currentHashFn: () => string,\n    tag: number | null,\n    onComplete: (a: string, b: any) => void\n  ) {\n    const pathString = query.path.toString();\n    this.log_(\n      'Listen called for ' + pathString + ' ' + query.queryIdentifier()\n    );\n\n    // Mark this listener so we can tell if it's removed.\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    const thisListen = {};\n    this.listens_[listenId] = thisListen;\n\n    const queryStringParamaters = query\n      .getQueryParams()\n      .toRestQueryStringParameters();\n\n    this.restRequest_(\n      pathString + '.json',\n      queryStringParamaters,\n      (error, result) => {\n        let data = result;\n\n        if (error === 404) {\n          data = null;\n          error = null;\n        }\n\n        if (error === null) {\n          this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\n        }\n\n        if (safeGet(this.listens_, listenId) === thisListen) {\n          let status;\n          if (!error) {\n            status = 'ok';\n          } else if (error == 401) {\n            status = 'permission_denied';\n          } else {\n            status = 'rest_error:' + error;\n          }\n\n          onComplete(status, null);\n        }\n      }\n    );\n  }\n\n  /** @inheritDoc */\n  unlisten(query: Query, tag: number | null) {\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    delete this.listens_[listenId];\n  }\n\n  /** @inheritDoc */\n  refreshAuthToken(token: string) {\n    // no-op since we just always call getToken.\n  }\n\n  /**\n   * Performs a REST request to the given path, with the provided query string parameters,\n   * and any auth credentials we have.\n   *\n   * @param {!string} pathString\n   * @param {!Object.<string, *>} queryStringParameters\n   * @param {?function(?number, *=)} callback\n   * @private\n   */\n  private restRequest_(\n    pathString: string,\n    queryStringParameters: { [k: string]: any } = {},\n    callback: ((a: number | null, b?: any) => void) | null\n  ) {\n    queryStringParameters['format'] = 'export';\n\n    this.authTokenProvider_\n      .getToken(/*forceRefresh=*/ false)\n      .then(authTokenData => {\n        const authToken = authTokenData && authTokenData.accessToken;\n        if (authToken) {\n          queryStringParameters['auth'] = authToken;\n        }\n\n        const url =\n          (this.repoInfo_.secure ? 'https://' : 'http://') +\n          this.repoInfo_.host +\n          pathString +\n          '?' +\n          querystring(queryStringParameters);\n\n        this.log_('Sending REST request for ' + url);\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n          if (callback && xhr.readyState === 4) {\n            this.log_(\n              'REST Response for ' + url + ' received. status:',\n              xhr.status,\n              'response:',\n              xhr.responseText\n            );\n            let res = null;\n            if (xhr.status >= 200 && xhr.status < 300) {\n              try {\n                res = jsonEval(xhr.responseText);\n              } catch (e) {\n                warn(\n                  'Failed to parse JSON response for ' +\n                    url +\n                    ': ' +\n                    xhr.responseText\n                );\n              }\n              callback(null, res);\n            } else {\n              // 401 and 404 are expected.\n              if (xhr.status !== 401 && xhr.status !== 404) {\n                warn(\n                  'Got unsuccessful REST response for ' +\n                    url +\n                    ' Status: ' +\n                    xhr.status\n                );\n              }\n              callback(xhr.status);\n            }\n            callback = null;\n          }\n        };\n\n        xhr.open('GET', url, /*asynchronous=*/ true);\n        xhr.send();\n      });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}