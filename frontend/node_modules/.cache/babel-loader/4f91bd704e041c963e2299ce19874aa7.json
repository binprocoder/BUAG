{"ast":null,"code":"/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\nvar FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nvar FCM_TOKEN_DETAILS_DB_VERSION = 1;\n\nvar TokenManager =\n/** @class */\nfunction () {\n  function TokenManager() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n  /**\r\n   * Get the indexedDB as a promsie.\r\n   * @private\r\n   * @return {Promise<IDBDatabase>} The IndexedDB database\r\n   */\n\n\n  TokenManager.prototype.openDatabase_ = function () {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n\n    this.openDbPromise_ = new Promise(function (resolve, reject) {\n      var request = indexedDB.open(TokenManager.DB_NAME, FCM_TOKEN_DETAILS_DB_VERSION);\n\n      request.onerror = function (event) {\n        reject(event.target.error);\n      };\n\n      request.onsuccess = function (event) {\n        resolve(event.target.result);\n      };\n\n      request.onupgradeneeded = function (event) {\n        var db = event.target.result;\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        }); // Make sure the sender ID can be searched\n\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n    return this.openDbPromise_;\n  };\n  /**\r\n   * Close the currently open database.\r\n   * @return {Promise<?>} Returns the result of the promise chain.\r\n   */\n\n\n  TokenManager.prototype.closeDatabase = function () {\n    var _this = this;\n\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(function (db) {\n        db.close();\n        _this.openDbPromise_ = null;\n      });\n    }\n\n    return Promise.resolve();\n  };\n  /**\r\n   * Given a token, this method will look up the details in indexedDB.\r\n   * @public\r\n   * @param {string} fcmToken\r\n   * @return {Promise<Object>} The details associated with that token.\r\n   */\n\n\n  TokenManager.prototype.getTokenDetailsFromToken = function (fcmToken) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var index = objectStore.index('fcmToken');\n        var request = index.get(fcmToken);\n\n        request.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        request.onsuccess = function (event) {\n          resolve(event.target.result);\n        };\n      });\n    });\n  };\n\n  TokenManager.prototype.getTokenDetailsFromSWScope_ = function (swScope) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var scopeRequest = objectStore.get(swScope);\n\n        scopeRequest.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        scopeRequest.onsuccess = function (event) {\n          resolve(event.target.result);\n        };\n      });\n    });\n  };\n\n  TokenManager.prototype.getAllTokenDetailsForSenderId_ = function (senderId) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var senderIdTokens = [];\n        var cursorRequest = objectStore.openCursor();\n\n        cursorRequest.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        cursorRequest.onsuccess = function (event) {\n          var cursor = event.target.result;\n\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  };\n  /**\r\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\r\n   * @public\r\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\r\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\r\n   * @param  {string=} pushSet If defined this will swap the subscription for\r\n   * matching FCM token.\r\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\r\n   * of the PushSubscription.\r\n   */\n\n\n  TokenManager.prototype.subscribeToFCM = function (senderId, subscription, pushSet) {\n    var _this = this;\n\n    var p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    var auth = arrayBufferToBase64(subscription['getKey']('auth'));\n    var fcmSubscribeBody = \"authorized_entity=\" + senderId + \"&\" + (\"endpoint=\" + subscription.endpoint + \"&\") + (\"encryption_key=\" + p256dh + \"&\") + (\"encryption_auth=\" + auth);\n\n    if (pushSet) {\n      fcmSubscribeBody += \"&pushSet=\" + pushSet;\n    }\n\n    var headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n    var subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n    return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe', subscribeOptions).then(function (response) {\n      return response.json();\n    }).then(function (response) {\n      var fcmTokenResponse = response;\n\n      if (fcmTokenResponse['error']) {\n        var message = fcmTokenResponse['error']['message'];\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n          message: message\n        });\n      }\n\n      if (!fcmTokenResponse['token']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);\n      }\n\n      if (!fcmTokenResponse['pushSet']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n      }\n\n      return {\n        token: fcmTokenResponse['token'],\n        pushSet: fcmTokenResponse['pushSet']\n      };\n    });\n  };\n  /**\r\n   * Checks the that fields in the PushSubscription are equivalent to the\r\n   * details stores in the masterTokenDetails.\r\n   * @private\r\n   * @param  {PushSubscription} subscription The push subscription we expect\r\n   * the master token to match.\r\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\r\n   * with the PushSubscription\r\n   * @return {boolean} true if the subscription and token details are\r\n   * equivalent.\r\n   */\n\n\n  TokenManager.prototype.isSameSubscription_ = function (subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return subscription.endpoint === masterTokenDetails['endpoint'] && arrayBufferToBase64(subscription['getKey']('auth')) === masterTokenDetails['auth'] && arrayBufferToBase64(subscription['getKey']('p256dh')) === masterTokenDetails['p256dh'];\n  };\n  /**\r\n   * Save the details for the fcm token for re-use at a later date.\r\n   * @private\r\n   * @param  {string} senderId The 'messagingSenderId' used for this project\r\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\r\n   * used to subscribe the user for web push\r\n   * @param  {PushSubscription} subscription The push subscription passed to\r\n   * FCM for the current token.\r\n   * @param  {string} fcmToken The FCM token currently used on this\r\n   * device.\r\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\r\n   * @return {Promise<void>}\r\n   */\n\n\n  TokenManager.prototype.saveTokenDetails_ = function (senderId, swRegistration, subscription, fcmToken, fcmPushSet) {\n    var details = {\n      swScope: swRegistration.scope,\n      endpoint: subscription.endpoint,\n      auth: arrayBufferToBase64(subscription['getKey']('auth')),\n      p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),\n      fcmToken: fcmToken,\n      fcmPushSet: fcmPushSet,\n      fcmSenderId: senderId\n    };\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var request = objectStore.put(details);\n\n        request.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        request.onsuccess = function (event) {\n          resolve();\n        };\n      });\n    });\n  };\n  /**\r\n   * Returns the saved FCM Token if one is available and still valid,\r\n   * otherwise `null` is returned.\r\n   * @param {string} senderId This should be the sender ID associated with the\r\n   * FCM Token being retrieved.\r\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\r\n   * to subscribe the user to push.\r\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\r\n   * avilable and valid.\r\n   * @export\r\n   */\n\n\n  TokenManager.prototype.getSavedToken = function (senderId, swRegistration) {\n    var _this = this;\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n    }\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n    }\n\n    return this.getAllTokenDetailsForSenderId_(senderId).then(function (allTokenDetails) {\n      if (allTokenDetails.length === 0) {\n        return;\n      }\n\n      var index = allTokenDetails.findIndex(function (tokenDetails) {\n        return swRegistration.scope === tokenDetails['swScope'] && senderId === tokenDetails['fcmSenderId'];\n      });\n\n      if (index === -1) {\n        return;\n      }\n\n      return allTokenDetails[index];\n    }).then(function (tokenDetails) {\n      if (!tokenDetails) {\n        return;\n      }\n\n      return swRegistration.pushManager.getSubscription().catch(function (err) {\n        throw _this.errorFactory_.create(Errors.codes.GET_SUBSCRIPTION_FAILED);\n      }).then(function (subscription) {\n        if (subscription && _this.isSameSubscription_(subscription, tokenDetails)) {\n          return tokenDetails['fcmToken'];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates a new FCM token.\r\n   */\n\n\n  TokenManager.prototype.createToken = function (senderId, swRegistration) {\n    var _this = this;\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n    }\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n    } // Check for existing subscription first\n\n\n    var subscription;\n    var fcmTokenDetails;\n    return swRegistration.pushManager.getSubscription().then(function (subscription) {\n      if (subscription) {\n        return subscription;\n      }\n\n      return swRegistration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);\n    }).then(function (sub) {\n      subscription = sub;\n      return _this.subscribeToFCM(senderId, subscription);\n    }).then(function (tokenDetails) {\n      fcmTokenDetails = tokenDetails;\n      return _this.saveTokenDetails_(senderId, swRegistration, subscription, fcmTokenDetails['token'], fcmTokenDetails['pushSet']);\n    }).then(function () {\n      return fcmTokenDetails['token'];\n    });\n  };\n  /**\r\n   * This method deletes details of the current FCM token.\r\n   * It's returning a promise in case we need to move to an async\r\n   * method for deleting at a later date.\r\n   * @param {string} token Token to be deleted\r\n   * @return {Promise<Object>} Resolves once the FCM token details have been\r\n   * deleted and returns the deleted details.\r\n   */\n\n\n  TokenManager.prototype.deleteToken = function (token) {\n    var _this = this;\n\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN));\n    }\n\n    return this.getTokenDetailsFromToken(token).then(function (details) {\n      if (!details) {\n        throw _this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n\n      return _this.openDatabase_().then(function (db) {\n        return new Promise(function (resolve, reject) {\n          var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n          var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          var request = objectStore.delete(details['swScope']);\n\n          request.onerror = function (event) {\n            reject(event.target.error);\n          };\n\n          request.onsuccess = function (event) {\n            if (event.target.result === 0) {\n              reject(_this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN));\n              return;\n            }\n\n            resolve(details);\n          };\n        });\n      });\n    });\n  };\n\n  return TokenManager;\n}();\n\nexport default TokenManager;","map":{"version":3,"mappings":"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","names":["ErrorFactory","Errors","arrayBufferToBase64","FCMDetails","FCM_TOKEN_OBJ_STORE","FCM_TOKEN_DETAILS_DB_VERSION","errorFactory_","map","openDbPromise_","TokenManager","Promise","resolve","reject","request","indexedDB","open","DB_NAME","onerror","event","target","error","onsuccess","result","onupgradeneeded","db","objectStore","createObjectStore","keyPath","createIndex","unique","then","close","_this","fcmToken","openDatabase_","transaction","index","get","swScope","scopeRequest","senderId","senderIdTokens","cursorRequest","openCursor","cursor","value","push","continue","subscription","pushSet","p256dh","auth","fcmSubscribeBody","endpoint","headers","Headers","append","subscribeOptions","method","body","fetch","ENDPOINT","json","fcmTokenResponse","response","message","create","codes","TOKEN_SUBSCRIBE_FAILED","TOKEN_SUBSCRIBE_NO_TOKEN","TOKEN_SUBSCRIBE_NO_PUSH_SET","token","masterTokenDetails","swRegistration","fcmPushSet","details","scope","fcmSenderId","put","ServiceWorkerRegistration","SW_REGISTRATION_EXPECTED","length","BAD_SENDER_ID","getAllTokenDetailsForSenderId_","allTokenDetails","findIndex","tokenDetails","pushManager","getSubscription","catch","GET_SUBSCRIPTION_FAILED","isSameSubscription_","fcmTokenDetails","subscribe","SUBSCRIPTION_OPTIONS","sub","subscribeToFCM","saveTokenDetails_","INVALID_DELETE_TOKEN","getTokenDetailsFromToken","DELETE_TOKEN_NOT_FOUND","delete","FAILED_TO_DELETE_TOKEN"],"sources":["../src/models/token-manager.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\n\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\n\nconst FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nconst FCM_TOKEN_DETAILS_DB_VERSION = 1;\n\nexport default class TokenManager {\n  private errorFactory_: ErrorFactory<string>;\n  private openDbPromise_: Promise<IDBDatabase>;\n\n  static DB_NAME: 'fcm_token_details_db';\n\n  constructor() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n\n  /**\n   * Get the indexedDB as a promsie.\n   * @private\n   * @return {Promise<IDBDatabase>} The IndexedDB database\n   */\n  openDatabase_() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n\n    this.openDbPromise_ = new Promise((resolve, reject) => {\n      const request = indexedDB.open(\n        TokenManager.DB_NAME,\n        FCM_TOKEN_DETAILS_DB_VERSION\n      );\n      request.onerror = event => {\n        reject((<IDBRequest>event.target).error);\n      };\n      request.onsuccess = event => {\n        resolve((<IDBRequest>event.target).result);\n      };\n      request.onupgradeneeded = event => {\n        var db = (<IDBRequest>event.target).result;\n\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        });\n\n        // Make sure the sender ID can be searched\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n\n    return this.openDbPromise_;\n  }\n\n  /**\n   * Close the currently open database.\n   * @return {Promise<?>} Returns the result of the promise chain.\n   */\n  closeDatabase() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(db => {\n        db.close();\n        this.openDbPromise_ = null;\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   * @public\n   * @param {string} fcmToken\n   * @return {Promise<Object>} The details associated with that token.\n   */\n  getTokenDetailsFromToken(fcmToken) {\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const index = objectStore.index('fcmToken');\n        const request = index.get(fcmToken);\n        request.onerror = function(event) {\n          reject((<IDBRequest>event.target).error);\n        };\n        request.onsuccess = function(event) {\n          resolve((<IDBRequest>event.target).result);\n        };\n      });\n    });\n  }\n\n  getTokenDetailsFromSWScope_(swScope) {\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const scopeRequest = objectStore.get(swScope);\n        scopeRequest.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n\n        scopeRequest.onsuccess = event => {\n          resolve((<IDBRequest>event.target).result);\n        };\n      });\n    });\n  }\n\n  getAllTokenDetailsForSenderId_(senderId): Promise<Array<Object>> {\n    return this.openDatabase_().then(db => {\n      return new Promise<Array<Object>>((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n\n        const senderIdTokens = [];\n\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n\n        cursorRequest.onsuccess = event => {\n          const cursor = (<IDBRequest>event.target).result;\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  }\n\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {string=} pushSet If defined this will swap the subscription for\n   * matching FCM token.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n  subscribeToFCM(senderId, subscription, pushSet?): Promise<Object> {\n    const p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    const auth = arrayBufferToBase64(subscription['getKey']('auth'));\n\n    let fcmSubscribeBody =\n      `authorized_entity=${senderId}&` +\n      `endpoint=${subscription.endpoint}&` +\n      `encryption_key=${p256dh}&` +\n      `encryption_auth=${auth}`;\n\n    if (pushSet) {\n      fcmSubscribeBody += `&pushSet=${pushSet}`;\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n    const subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n\n    return fetch(\n      FCMDetails.ENDPOINT + '/fcm/connect/subscribe',\n      subscribeOptions\n    )\n      .then(response => response.json())\n      .then(response => {\n        const fcmTokenResponse = response;\n        if (fcmTokenResponse['error']) {\n          const message = fcmTokenResponse['error']['message'];\n          throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n            message: message\n          });\n        }\n\n        if (!fcmTokenResponse['token']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN\n          );\n        }\n\n        if (!fcmTokenResponse['pushSet']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET\n          );\n        }\n\n        return {\n          token: fcmTokenResponse['token'],\n          pushSet: fcmTokenResponse['pushSet']\n        };\n      });\n  }\n\n  /**\n   * Checks the that fields in the PushSubscription are equivalent to the\n   * details stores in the masterTokenDetails.\n   * @private\n   * @param  {PushSubscription} subscription The push subscription we expect\n   * the master token to match.\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\n   * with the PushSubscription\n   * @return {boolean} true if the subscription and token details are\n   * equivalent.\n   */\n  isSameSubscription_(subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return (\n      subscription.endpoint === masterTokenDetails['endpoint'] &&\n      arrayBufferToBase64(subscription['getKey']('auth')) ===\n        masterTokenDetails['auth'] &&\n      arrayBufferToBase64(subscription['getKey']('p256dh')) ===\n        masterTokenDetails['p256dh']\n    );\n  }\n\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @private\n   * @param  {string} senderId The 'messagingSenderId' used for this project\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\n   * used to subscribe the user for web push\n   * @param  {PushSubscription} subscription The push subscription passed to\n   * FCM for the current token.\n   * @param  {string} fcmToken The FCM token currently used on this\n   * device.\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n   * @return {Promise<void>}\n   */\n  saveTokenDetails_(\n    senderId,\n    swRegistration,\n    subscription,\n    fcmToken,\n    fcmPushSet\n  ) {\n    const details = {\n      swScope: swRegistration.scope,\n      endpoint: subscription.endpoint,\n      auth: arrayBufferToBase64(subscription['getKey']('auth')),\n      p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),\n      fcmToken: fcmToken,\n      fcmPushSet: fcmPushSet,\n      fcmSenderId: senderId\n    };\n\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const request = objectStore.put(details);\n        request.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n        request.onsuccess = event => {\n          resolve();\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the saved FCM Token if one is available and still valid,\n   * otherwise `null` is returned.\n   * @param {string} senderId This should be the sender ID associated with the\n   * FCM Token being retrieved.\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n   * to subscribe the user to push.\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\n   * avilable and valid.\n   * @export\n   */\n  getSavedToken(senderId, swRegistration) {\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED)\n      );\n    }\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.BAD_SENDER_ID)\n      );\n    }\n\n    return this.getAllTokenDetailsForSenderId_(senderId)\n      .then(allTokenDetails => {\n        if (allTokenDetails.length === 0) {\n          return;\n        }\n\n        const index = allTokenDetails.findIndex(tokenDetails => {\n          return (\n            swRegistration.scope === tokenDetails['swScope'] &&\n            senderId === tokenDetails['fcmSenderId']\n          );\n        });\n\n        if (index === -1) {\n          return;\n        }\n\n        return allTokenDetails[index];\n      })\n      .then(tokenDetails => {\n        if (!tokenDetails) {\n          return;\n        }\n\n        return swRegistration.pushManager\n          .getSubscription()\n          .catch(err => {\n            throw this.errorFactory_.create(\n              Errors.codes.GET_SUBSCRIPTION_FAILED\n            );\n          })\n          .then(subscription => {\n            if (\n              subscription &&\n              this.isSameSubscription_(subscription, tokenDetails)\n            ) {\n              return tokenDetails['fcmToken'];\n            }\n          });\n      });\n  }\n\n  /**\n   * Creates a new FCM token.\n   */\n  createToken(senderId, swRegistration): Promise<String> {\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.BAD_SENDER_ID)\n      );\n    }\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED)\n      );\n    }\n\n    // Check for existing subscription first\n    let subscription;\n    let fcmTokenDetails;\n    return swRegistration.pushManager\n      .getSubscription()\n      .then(subscription => {\n        if (subscription) {\n          return subscription;\n        }\n\n        return swRegistration.pushManager.subscribe(\n          FCMDetails.SUBSCRIPTION_OPTIONS\n        );\n      })\n      .then(sub => {\n        subscription = sub;\n        return this.subscribeToFCM(senderId, subscription);\n      })\n      .then(tokenDetails => {\n        fcmTokenDetails = tokenDetails;\n        return this.saveTokenDetails_(\n          senderId,\n          swRegistration,\n          subscription,\n          fcmTokenDetails['token'],\n          fcmTokenDetails['pushSet']\n        );\n      })\n      .then(() => fcmTokenDetails['token']);\n  }\n\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   * @param {string} token Token to be deleted\n   * @return {Promise<Object>} Resolves once the FCM token details have been\n   * deleted and returns the deleted details.\n   */\n  deleteToken(token) {\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN)\n      );\n    }\n\n    return this.getTokenDetailsFromToken(token).then(details => {\n      if (!details) {\n        throw this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n\n      return this.openDatabase_().then(db => {\n        return new Promise((resolve, reject) => {\n          const transaction = db.transaction(\n            [FCM_TOKEN_OBJ_STORE],\n            'readwrite'\n          );\n          const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          const request = objectStore.delete(details['swScope']);\n          request.onerror = event => {\n            reject((<IDBRequest>event.target).error);\n          };\n          request.onsuccess = event => {\n            if ((<IDBRequest>event.target).result === 0) {\n              reject(\n                this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN)\n              );\n              return;\n            }\n\n            resolve(details);\n          };\n        });\n      });\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}