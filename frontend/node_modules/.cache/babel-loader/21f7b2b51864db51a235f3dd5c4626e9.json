{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"../util/util\");\n\nvar StatsListener_1 = require(\"./StatsListener\"); // Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\n\n\nvar FIRST_STATS_MIN_TIME = 10 * 1000;\nvar FIRST_STATS_MAX_TIME = 30 * 1000; // We'll continue to report stats on average every 5 minutes.\n\nvar REPORT_STATS_INTERVAL = 5 * 60 * 1000;\n/**\n * @constructor\n */\n\nvar StatsReporter =\n/** @class */\nfunction () {\n  /**\n   * @param collection\n   * @param server_\n   */\n  function StatsReporter(collection, server_) {\n    this.server_ = server_;\n    this.statsToReport_ = {};\n    this.statsListener_ = new StatsListener_1.StatsListener(collection);\n    var timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\n    util_2.setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\n  }\n\n  StatsReporter.prototype.includeStat = function (stat) {\n    this.statsToReport_[stat] = true;\n  };\n\n  StatsReporter.prototype.reportStats_ = function () {\n    var _this = this;\n\n    var stats = this.statsListener_.get();\n    var reportedStats = {};\n    var haveStatsToReport = false;\n    util_1.forEach(stats, function (stat, value) {\n      if (value > 0 && util_1.contains(_this.statsToReport_, stat)) {\n        reportedStats[stat] = value;\n        haveStatsToReport = true;\n      }\n    });\n\n    if (haveStatsToReport) {\n      this.server_.reportStats(reportedStats);\n    } // queue our next run.\n\n\n    util_2.setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));\n  };\n\n  return StatsReporter;\n}();\n\nexports.StatsReporter = StatsReporter;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA;;AACA;;AACA,iD,CAIA;AACA;AACA;;;AACA,IAAMA,oBAAoB,GAAG,KAAK,IAAlC;AACA,IAAMC,oBAAoB,GAAG,KAAK,IAAlC,C,CAEA;;AACA,IAAMC,qBAAqB,GAAG,IAAI,EAAJ,GAAS,IAAvC;AAEA;;;;AAGA;AAAA;AAAA;AAIE;;;;AAIA,yBAAYC,UAAZ,EAAiDC,OAAjD,EAAuE;AAAtB;AANzC,0BAA2C,EAA3C;AAON,SAAKC,cAAL,GAAsB,IAAIC,6BAAJ,CAAkBH,UAAlB,CAAtB;AAEA,QAAMI,OAAO,GACXP,oBAAoB,GACpB,CAACC,oBAAoB,GAAGD,oBAAxB,IAAgDQ,IAAI,CAACC,MAAL,EAFlD;AAGAC,iCAAsB,KAAKC,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CAAtB,EAAoDJ,IAAI,CAACK,KAAL,CAAWN,OAAX,CAApD;AACD;;AAEDO,kDAAYC,IAAZ,EAAwB;AACtB,SAAKC,cAAL,CAAoBD,IAApB,IAA4B,IAA5B;AACD,GAFD;;AAIQD,yCAAR;AAAA;;AACE,QAAMG,KAAK,GAAG,KAAKZ,cAAL,CAAoBa,GAApB,EAAd;AACA,QAAMC,aAAa,GAAiB,EAApC;AACA,QAAIC,iBAAiB,GAAG,KAAxB;AAEAC,mBAAQJ,KAAR,EAAe,UAACF,IAAD,EAAeO,KAAf,EAA4B;AACzC,UAAIA,KAAK,GAAG,CAAR,IAAaD,gBAASE,KAAI,CAACP,cAAd,EAA8BD,IAA9B,CAAjB,EAAsD;AACpDI,qBAAa,CAACJ,IAAD,CAAb,GAAsBO,KAAtB;AACAF,yBAAiB,GAAG,IAApB;AACD;AACF,KALD;;AAOA,QAAIA,iBAAJ,EAAuB;AACrB,WAAKhB,OAAL,CAAaoB,WAAb,CAAyBL,aAAzB;AACD,KAdH,CAgBE;;;AACAT,iCACE,KAAKC,YAAL,CAAkBC,IAAlB,CAAuB,IAAvB,CADF,EAEEJ,IAAI,CAACK,KAAL,CAAWL,IAAI,CAACC,MAAL,KAAgB,CAAhB,GAAoBP,qBAA/B,CAFF;AAID,GArBO;;AAsBV;AA3CA;;AAAauB","names":["FIRST_STATS_MIN_TIME","FIRST_STATS_MAX_TIME","REPORT_STATS_INTERVAL","collection","server_","statsListener_","StatsListener_1","timeout","Math","random","util_2","reportStats_","bind","floor","StatsReporter","stat","statsToReport_","stats","get","reportedStats","haveStatsToReport","util_1","value","_this","reportStats","exports"],"sources":["../src/core/stats/StatsReporter.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { contains, forEach } from '@firebase/util';\nimport { setTimeoutNonBlocking } from '../util/util';\nimport { StatsListener } from './StatsListener';\nimport { StatsCollection } from './StatsCollection';\nimport { ServerActions } from '../ServerActions';\n\n// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\nconst FIRST_STATS_MIN_TIME = 10 * 1000;\nconst FIRST_STATS_MAX_TIME = 30 * 1000;\n\n// We'll continue to report stats on average every 5 minutes.\nconst REPORT_STATS_INTERVAL = 5 * 60 * 1000;\n\n/**\n * @constructor\n */\nexport class StatsReporter {\n  private statsListener_: StatsListener;\n  private statsToReport_: { [k: string]: boolean } = {};\n\n  /**\n   * @param collection\n   * @param server_\n   */\n  constructor(collection: StatsCollection, private server_: ServerActions) {\n    this.statsListener_ = new StatsListener(collection);\n\n    const timeout =\n      FIRST_STATS_MIN_TIME +\n      (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\n    setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\n  }\n\n  includeStat(stat: string) {\n    this.statsToReport_[stat] = true;\n  }\n\n  private reportStats_() {\n    const stats = this.statsListener_.get();\n    const reportedStats: typeof stats = {};\n    let haveStatsToReport = false;\n\n    forEach(stats, (stat: string, value: number) => {\n      if (value > 0 && contains(this.statsToReport_, stat)) {\n        reportedStats[stat] = value;\n        haveStatsToReport = true;\n      }\n    });\n\n    if (haveStatsToReport) {\n      this.server_.reportStats(reportedStats);\n    }\n\n    // queue our next run.\n    setTimeoutNonBlocking(\n      this.reportStats_.bind(this),\n      Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL)\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}