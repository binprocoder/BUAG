{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Path_1 = require(\"./Path\");\n\nvar SparseSnapshotTree_1 = require(\"../SparseSnapshotTree\");\n\nvar LeafNode_1 = require(\"../snap/LeafNode\");\n\nvar nodeFromJSON_1 = require(\"../snap/nodeFromJSON\");\n\nvar PriorityIndex_1 = require(\"../snap/indexes/PriorityIndex\");\n/**\r\n * Generate placeholders for deferred values.\r\n * @param {?Object} values\r\n * @return {!Object}\r\n */\n\n\nexports.generateWithValues = function (values) {\n  values = values || {};\n  values['timestamp'] = values['timestamp'] || new Date().getTime();\n  return values;\n};\n/**\r\n * Value to use when firing local events. When writing server values, fire\r\n * local events with an approximate value, otherwise return value as-is.\r\n * @param {(Object|string|number|boolean)} value\r\n * @param {!Object} serverValues\r\n * @return {!(string|number|boolean)}\r\n */\n\n\nexports.resolveDeferredValue = function (value, serverValues) {\n  if (!value || typeof value !== 'object') {\n    return value;\n  } else {\n    util_1.assert('.sv' in value, 'Unexpected leaf node or priority contents');\n    return serverValues[value['.sv']];\n  }\n};\n/**\r\n * Recursively replace all deferred values and priorities in the tree with the\r\n * specified generated replacement values.\r\n * @param {!SparseSnapshotTree} tree\r\n * @param {!Object} serverValues\r\n * @return {!SparseSnapshotTree}\r\n */\n\n\nexports.resolveDeferredValueTree = function (tree, serverValues) {\n  var resolvedTree = new SparseSnapshotTree_1.SparseSnapshotTree();\n  tree.forEachTree(new Path_1.Path(''), function (path, node) {\n    resolvedTree.remember(path, exports.resolveDeferredValueSnapshot(node, serverValues));\n  });\n  return resolvedTree;\n};\n/**\r\n * Recursively replace all deferred values and priorities in the node with the\r\n * specified generated replacement values.  If there are no server values in the node,\r\n * it'll be returned as-is.\r\n * @param {!Node} node\r\n * @param {!Object} serverValues\r\n * @return {!Node}\r\n */\n\n\nexports.resolveDeferredValueSnapshot = function (node, serverValues) {\n  var rawPri = node.getPriority().val();\n  var priority = exports.resolveDeferredValue(rawPri, serverValues);\n  var newNode;\n\n  if (node.isLeafNode()) {\n    var leafNode = node;\n    var value = exports.resolveDeferredValue(leafNode.getValue(), serverValues);\n\n    if (value !== leafNode.getValue() || priority !== leafNode.getPriority().val()) {\n      return new LeafNode_1.LeafNode(value, nodeFromJSON_1.nodeFromJSON(priority));\n    } else {\n      return node;\n    }\n  } else {\n    var childrenNode = node;\n    newNode = childrenNode;\n\n    if (priority !== childrenNode.getPriority().val()) {\n      newNode = newNode.updatePriority(new LeafNode_1.LeafNode(priority));\n    }\n\n    childrenNode.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {\n      var newChildNode = exports.resolveDeferredValueSnapshot(childNode, serverValues);\n\n      if (newChildNode !== childNode) {\n        newNode = newNode.updateImmediateChild(childName, newChildNode);\n      }\n    });\n    return newNode;\n  }\n};","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA;;AACA;;AACA;;AACA;;AACA;;AACA;AAIA;;;;;;;AAKaA,6BAAqB,UAChCC,MADgC,EAGxB;AAERA,QAAM,GAAGA,MAAM,IAAI,EAAnB;AACAA,QAAM,CAAC,WAAD,CAAN,GAAsBA,MAAM,CAAC,WAAD,CAAN,IAAuB,IAAIC,IAAJ,GAAWC,OAAX,EAA7C;AACA,SAAOF,MAAP;AACD,CARY;AAUb;;;;;;;;;AAOaD,+BAAuB,UAClCI,KADkC,EAElCC,YAFkC,EAEA;AAElC,MAAI,CAACD,KAAD,IAAU,OAAOA,KAAP,KAAiB,QAA/B,EAAyC;AACvC,WAAOA,KAAP;AACD,GAFD,MAEO;AACLE,kBAAO,SAASF,KAAhB,EAAuB,2CAAvB;AACA,WAAOC,YAAY,CAACD,KAAK,CAAC,KAAD,CAAN,CAAnB;AACD;AACF,CAVY;AAYb;;;;;;;;;AAOaJ,mCAA2B,UACtCO,IADsC,EAEtCF,YAFsC,EAElB;AAEpB,MAAMG,YAAY,GAAG,IAAIC,uCAAJ,EAArB;AACAF,MAAI,CAACG,WAAL,CAAiB,IAAIC,WAAJ,CAAS,EAAT,CAAjB,EAA+B,UAASC,IAAT,EAAeC,IAAf,EAAmB;AAChDL,gBAAY,CAACM,QAAb,CACEF,IADF,EAEEZ,qCAA6Ba,IAA7B,EAAmCR,YAAnC,CAFF;AAID,GALD;AAMA,SAAOG,YAAP;AACD,CAZY;AAcb;;;;;;;;;;AAQaR,uCAA+B,UAC1Ca,IAD0C,EAE1CR,YAF0C,EAEtB;AAEpB,MAAMU,MAAM,GAAGF,IAAI,CAACG,WAAL,GAAmBC,GAAnB,EAAf;AAMA,MAAMC,QAAQ,GAAGlB,6BAAqBe,MAArB,EAA6BV,YAA7B,CAAjB;AACA,MAAIc,OAAJ;;AAEA,MAAIN,IAAI,CAACO,UAAL,EAAJ,EAAuB;AACrB,QAAMC,QAAQ,GAAGR,IAAjB;AACA,QAAMT,KAAK,GAAGJ,6BAAqBqB,QAAQ,CAACC,QAAT,EAArB,EAA0CjB,YAA1C,CAAd;;AACA,QACED,KAAK,KAAKiB,QAAQ,CAACC,QAAT,EAAV,IACAJ,QAAQ,KAAKG,QAAQ,CAACL,WAAT,GAAuBC,GAAvB,EAFf,EAGE;AACA,aAAO,IAAIM,mBAAJ,CAAanB,KAAb,EAAoBoB,4BAAaN,QAAb,CAApB,CAAP;AACD,KALD,MAKO;AACL,aAAOL,IAAP;AACD;AACF,GAXD,MAWO;AACL,QAAMY,YAAY,GAAGZ,IAArB;AACAM,WAAO,GAAGM,YAAV;;AACA,QAAIP,QAAQ,KAAKO,YAAY,CAACT,WAAb,GAA2BC,GAA3B,EAAjB,EAAmD;AACjDE,aAAO,GAAGA,OAAO,CAACO,cAAR,CAAuB,IAAIH,mBAAJ,CAAaL,QAAb,CAAvB,CAAV;AACD;;AACDO,gBAAY,CAACE,YAAb,CAA0BC,8BAA1B,EAA0C,UAASC,SAAT,EAAoBC,SAApB,EAA6B;AACrE,UAAMC,YAAY,GAAG/B,qCACnB8B,SADmB,EAEnBzB,YAFmB,CAArB;;AAIA,UAAI0B,YAAY,KAAKD,SAArB,EAAgC;AAC9BX,eAAO,GAAGA,OAAO,CAACa,oBAAR,CAA6BH,SAA7B,EAAwCE,YAAxC,CAAV;AACD;AACF,KARD;AASA,WAAOZ,OAAP;AACD;AACF,CAzCY","names":["exports","values","Date","getTime","value","serverValues","util_1","tree","resolvedTree","SparseSnapshotTree_1","forEachTree","Path_1","path","node","remember","rawPri","getPriority","val","priority","newNode","isLeafNode","leafNode","getValue","LeafNode_1","nodeFromJSON_1","childrenNode","updatePriority","forEachChild","PriorityIndex_1","childName","childNode","newChildNode","updateImmediateChild"],"sources":["../src/core/util/ServerValues.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Path } from './Path';\nimport { SparseSnapshotTree } from '../SparseSnapshotTree';\nimport { LeafNode } from '../snap/LeafNode';\nimport { nodeFromJSON } from '../snap/nodeFromJSON';\nimport { PRIORITY_INDEX } from '../snap/indexes/PriorityIndex';\nimport { Node } from '../snap/Node';\nimport { ChildrenNode } from '../snap/ChildrenNode';\n\n/**\n * Generate placeholders for deferred values.\n * @param {?Object} values\n * @return {!Object}\n */\nexport const generateWithValues = function(\n  values: {\n    [k: string]: any;\n  } | null\n): { [k: string]: any } {\n  values = values || {};\n  values['timestamp'] = values['timestamp'] || new Date().getTime();\n  return values;\n};\n\n/**\n * Value to use when firing local events. When writing server values, fire\n * local events with an approximate value, otherwise return value as-is.\n * @param {(Object|string|number|boolean)} value\n * @param {!Object} serverValues\n * @return {!(string|number|boolean)}\n */\nexport const resolveDeferredValue = function(\n  value: { [k: string]: any } | string | number | boolean,\n  serverValues: { [k: string]: any }\n): string | number | boolean {\n  if (!value || typeof value !== 'object') {\n    return value as string | number | boolean;\n  } else {\n    assert('.sv' in value, 'Unexpected leaf node or priority contents');\n    return serverValues[value['.sv']];\n  }\n};\n\n/**\n * Recursively replace all deferred values and priorities in the tree with the\n * specified generated replacement values.\n * @param {!SparseSnapshotTree} tree\n * @param {!Object} serverValues\n * @return {!SparseSnapshotTree}\n */\nexport const resolveDeferredValueTree = function(\n  tree: SparseSnapshotTree,\n  serverValues: Object\n): SparseSnapshotTree {\n  const resolvedTree = new SparseSnapshotTree();\n  tree.forEachTree(new Path(''), function(path, node) {\n    resolvedTree.remember(\n      path,\n      resolveDeferredValueSnapshot(node, serverValues)\n    );\n  });\n  return resolvedTree;\n};\n\n/**\n * Recursively replace all deferred values and priorities in the node with the\n * specified generated replacement values.  If there are no server values in the node,\n * it'll be returned as-is.\n * @param {!Node} node\n * @param {!Object} serverValues\n * @return {!Node}\n */\nexport const resolveDeferredValueSnapshot = function(\n  node: Node,\n  serverValues: Object\n): Node {\n  const rawPri = node.getPriority().val() as\n    | object\n    | boolean\n    | null\n    | number\n    | string;\n  const priority = resolveDeferredValue(rawPri, serverValues);\n  let newNode: Node;\n\n  if (node.isLeafNode()) {\n    const leafNode = node as LeafNode;\n    const value = resolveDeferredValue(leafNode.getValue(), serverValues);\n    if (\n      value !== leafNode.getValue() ||\n      priority !== leafNode.getPriority().val()\n    ) {\n      return new LeafNode(value, nodeFromJSON(priority));\n    } else {\n      return node;\n    }\n  } else {\n    const childrenNode = node as ChildrenNode;\n    newNode = childrenNode;\n    if (priority !== childrenNode.getPriority().val()) {\n      newNode = newNode.updatePriority(new LeafNode(priority));\n    }\n    childrenNode.forEachChild(PRIORITY_INDEX, function(childName, childNode) {\n      const newChildNode = resolveDeferredValueSnapshot(\n        childNode,\n        serverValues\n      );\n      if (newChildNode !== childNode) {\n        newNode = newNode.updateImmediateChild(childName, newChildNode);\n      }\n    });\n    return newNode;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}