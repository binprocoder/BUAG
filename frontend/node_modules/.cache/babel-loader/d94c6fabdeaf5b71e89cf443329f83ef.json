{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"../util/util\");\n\nvar SortedMap_1 = require(\"../util/SortedMap\");\n\nvar Node_1 = require(\"./Node\");\n\nvar snap_1 = require(\"./snap\");\n\nvar PriorityIndex_1 = require(\"./indexes/PriorityIndex\");\n\nvar KeyIndex_1 = require(\"./indexes/KeyIndex\");\n\nvar IndexMap_1 = require(\"./IndexMap\");\n\nvar LeafNode_1 = require(\"./LeafNode\");\n\nvar comparators_1 = require(\"./comparators\"); // TODO: For memory savings, don't store priorityNode_ if it's empty.\n\n\nvar EMPTY_NODE;\n/**\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\n * (i.e. nodes with children).  It implements Node and stores the\n * list of children in the children property, sorted by child name.\n *\n * @constructor\n * @implements {Node}\n */\n\nvar ChildrenNode =\n/** @class */\nfunction () {\n  /**\n   *\n   * @param {!SortedMap.<string, !Node>} children_ List of children\n   * of this node..\n   * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).\n   * @param {!IndexMap} indexMap_\n   */\n  function ChildrenNode(children_, priorityNode_, indexMap_) {\n    this.children_ = children_;\n    this.priorityNode_ = priorityNode_;\n    this.indexMap_ = indexMap_;\n    this.lazyHash_ = null;\n    /**\n     * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\n     * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\n     * class instead of an empty ChildrenNode.\n     */\n\n    if (this.priorityNode_) {\n      snap_1.validatePriorityNode(this.priorityNode_);\n    }\n\n    if (this.children_.isEmpty()) {\n      util_1.assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');\n    }\n  }\n\n  Object.defineProperty(ChildrenNode, \"EMPTY_NODE\", {\n    get: function () {\n      return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode(new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), null, IndexMap_1.IndexMap.Default));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @inheritDoc */\n\n  ChildrenNode.prototype.isLeafNode = function () {\n    return false;\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.getPriority = function () {\n    return this.priorityNode_ || EMPTY_NODE;\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.updatePriority = function (newPriorityNode) {\n    if (this.children_.isEmpty()) {\n      // Don't allow priorities on empty nodes\n      return this;\n    } else {\n      return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n    }\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.getImmediateChild = function (childName) {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.getPriority();\n    } else {\n      var child = this.children_.get(childName);\n      return child === null ? EMPTY_NODE : child;\n    }\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.getChild = function (path) {\n    var front = path.getFront();\n    if (front === null) return this;\n    return this.getImmediateChild(front).getChild(path.popFront());\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.hasChild = function (childName) {\n    return this.children_.get(childName) !== null;\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.updateImmediateChild = function (childName, newChildNode) {\n    util_1.assert(newChildNode, 'We should always be passing snapshot nodes');\n\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else {\n      var namedNode = new Node_1.NamedNode(childName, newChildNode);\n      var newChildren = void 0,\n          newIndexMap = void 0,\n          newPriority = void 0;\n\n      if (newChildNode.isEmpty()) {\n        newChildren = this.children_.remove(childName);\n        newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);\n      } else {\n        newChildren = this.children_.insert(childName, newChildNode);\n        newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n      }\n\n      newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n      return new ChildrenNode(newChildren, newPriority, newIndexMap);\n    }\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.updateChild = function (path, newChildNode) {\n    var front = path.getFront();\n\n    if (front === null) {\n      return newChildNode;\n    } else {\n      util_1.assert(path.getFront() !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');\n      var newImmediateChild = this.getImmediateChild(front).updateChild(path.popFront(), newChildNode);\n      return this.updateImmediateChild(front, newImmediateChild);\n    }\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.isEmpty = function () {\n    return this.children_.isEmpty();\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.numChildren = function () {\n    return this.children_.count();\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.val = function (exportFormat) {\n    if (this.isEmpty()) return null;\n    var obj = {};\n    var numKeys = 0,\n        maxKey = 0,\n        allIntegerKeys = true;\n    this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n      obj[key] = childNode.val(exportFormat);\n      numKeys++;\n\n      if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n        maxKey = Math.max(maxKey, Number(key));\n      } else {\n        allIntegerKeys = false;\n      }\n    });\n\n    if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n      // convert to array.\n      var array = [];\n\n      for (var key in obj) array[key] = obj[key];\n\n      return array;\n    } else {\n      if (exportFormat && !this.getPriority().isEmpty()) {\n        obj['.priority'] = this.getPriority().val();\n      }\n\n      return obj;\n    }\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.hash = function () {\n    if (this.lazyHash_ === null) {\n      var toHash_1 = '';\n      if (!this.getPriority().isEmpty()) toHash_1 += 'priority:' + snap_1.priorityHashText(this.getPriority().val()) + ':';\n      this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n        var childHash = childNode.hash();\n        if (childHash !== '') toHash_1 += ':' + key + ':' + childHash;\n      });\n      this.lazyHash_ = toHash_1 === '' ? '' : util_2.sha1(toHash_1);\n    }\n\n    return this.lazyHash_;\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.getPredecessorChildName = function (childName, childNode, index) {\n    var idx = this.resolveIndex_(index);\n\n    if (idx) {\n      var predecessor = idx.getPredecessorKey(new Node_1.NamedNode(childName, childNode));\n      return predecessor ? predecessor.name : null;\n    } else {\n      return this.children_.getPredecessorKey(childName);\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n\n\n  ChildrenNode.prototype.getFirstChildName = function (indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n\n    if (idx) {\n      var minKey = idx.minKey();\n      return minKey && minKey.name;\n    } else {\n      return this.children_.minKey();\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n\n\n  ChildrenNode.prototype.getFirstChild = function (indexDefinition) {\n    var minKey = this.getFirstChildName(indexDefinition);\n\n    if (minKey) {\n      return new Node_1.NamedNode(minKey, this.children_.get(minKey));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Given an index, return the key name of the largest value we have, according to that index\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n\n\n  ChildrenNode.prototype.getLastChildName = function (indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n\n    if (idx) {\n      var maxKey = idx.maxKey();\n      return maxKey && maxKey.name;\n    } else {\n      return this.children_.maxKey();\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n\n\n  ChildrenNode.prototype.getLastChild = function (indexDefinition) {\n    var maxKey = this.getLastChildName(indexDefinition);\n\n    if (maxKey) {\n      return new Node_1.NamedNode(maxKey, this.children_.get(maxKey));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildrenNode.prototype.forEachChild = function (index, action) {\n    var idx = this.resolveIndex_(index);\n\n    if (idx) {\n      return idx.inorderTraversal(function (wrappedNode) {\n        return action(wrappedNode.name, wrappedNode.node);\n      });\n    } else {\n      return this.children_.inorderTraversal(action);\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {SortedMapIterator}\n   */\n\n\n  ChildrenNode.prototype.getIterator = function (indexDefinition) {\n    return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n  };\n  /**\n   *\n   * @param {!NamedNode} startPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n\n\n  ChildrenNode.prototype.getIteratorFrom = function (startPost, indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n\n    if (idx) {\n      return idx.getIteratorFrom(startPost, function (key) {\n        return key;\n      });\n    } else {\n      var iterator = this.children_.getIteratorFrom(startPost.name, Node_1.NamedNode.Wrap);\n      var next = iterator.peek();\n\n      while (next != null && indexDefinition.compare(next, startPost) < 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n\n      return iterator;\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n\n\n  ChildrenNode.prototype.getReverseIterator = function (indexDefinition) {\n    return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);\n  };\n  /**\n   * @param {!NamedNode} endPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n\n\n  ChildrenNode.prototype.getReverseIteratorFrom = function (endPost, indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n\n    if (idx) {\n      return idx.getReverseIteratorFrom(endPost, function (key) {\n        return key;\n      });\n    } else {\n      var iterator = this.children_.getReverseIteratorFrom(endPost.name, Node_1.NamedNode.Wrap);\n      var next = iterator.peek();\n\n      while (next != null && indexDefinition.compare(next, endPost) > 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n\n      return iterator;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildrenNode.prototype.compareTo = function (other) {\n    if (this.isEmpty()) {\n      if (other.isEmpty()) {\n        return 0;\n      } else {\n        return -1;\n      }\n    } else if (other.isLeafNode() || other.isEmpty()) {\n      return 1;\n    } else if (other === exports.MAX_NODE) {\n      return -1;\n    } else {\n      // Must be another node with children.\n      return 0;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildrenNode.prototype.withIndex = function (indexDefinition) {\n    if (indexDefinition === KeyIndex_1.KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {\n      return this;\n    } else {\n      var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);\n      return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildrenNode.prototype.isIndexed = function (index) {\n    return index === KeyIndex_1.KEY_INDEX || this.indexMap_.hasIndex(index);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildrenNode.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      return false;\n    } else {\n      var otherChildrenNode = other;\n\n      if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n        return false;\n      } else if (this.children_.count() === otherChildrenNode.children_.count()) {\n        var thisIter = this.getIterator(PriorityIndex_1.PRIORITY_INDEX);\n        var otherIter = otherChildrenNode.getIterator(PriorityIndex_1.PRIORITY_INDEX);\n        var thisCurrent = thisIter.getNext();\n        var otherCurrent = otherIter.getNext();\n\n        while (thisCurrent && otherCurrent) {\n          if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {\n            return false;\n          }\n\n          thisCurrent = thisIter.getNext();\n          otherCurrent = otherIter.getNext();\n        }\n\n        return thisCurrent === null && otherCurrent === null;\n      } else {\n        return false;\n      }\n    }\n  };\n  /**\n   * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\n   * instead.\n   *\n   * @private\n   * @param {!Index} indexDefinition\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n\n\n  ChildrenNode.prototype.resolveIndex_ = function (indexDefinition) {\n    if (indexDefinition === KeyIndex_1.KEY_INDEX) {\n      return null;\n    } else {\n      return this.indexMap_.get(indexDefinition.toString());\n    }\n  };\n  /**\n   * @private\n   * @type {RegExp}\n   */\n\n\n  ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\n  return ChildrenNode;\n}();\n\nexports.ChildrenNode = ChildrenNode;\n/**\n * @constructor\n * @extends {ChildrenNode}\n * @private\n */\n\nvar MaxNode =\n/** @class */\nfunction (_super) {\n  __extends(MaxNode, _super);\n\n  function MaxNode() {\n    return _super.call(this, new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap_1.IndexMap.Default) || this;\n  }\n\n  MaxNode.prototype.compareTo = function (other) {\n    if (other === this) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  MaxNode.prototype.equals = function (other) {\n    // Not that we every compare it, but MAX_NODE is only ever equal to itself\n    return other === this;\n  };\n\n  MaxNode.prototype.getPriority = function () {\n    return this;\n  };\n\n  MaxNode.prototype.getImmediateChild = function (childName) {\n    return ChildrenNode.EMPTY_NODE;\n  };\n\n  MaxNode.prototype.isEmpty = function () {\n    return false;\n  };\n\n  return MaxNode;\n}(ChildrenNode);\n\nexports.MaxNode = MaxNode;\n/**\n * Marker that will sort higher than any other snapshot.\n * @type {!MAX_NODE}\n * @const\n */\n\nexports.MAX_NODE = new MaxNode();\nObject.defineProperties(Node_1.NamedNode, {\n  MIN: {\n    value: new Node_1.NamedNode(util_2.MIN_NAME, ChildrenNode.EMPTY_NODE)\n  },\n  MAX: {\n    value: new Node_1.NamedNode(util_2.MAX_NAME, exports.MAX_NODE)\n  }\n});\n/**\n * Reference Extensions\n */\n\nKeyIndex_1.KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode_1.LeafNode.__childrenNodeConstructor = ChildrenNode;\nsnap_1.setMaxNode(exports.MAX_NODE);\nPriorityIndex_1.setMaxNode(exports.MAX_NODE);","map":{"version":3,"mappings":"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","names":["EMPTY_NODE","children_","priorityNode_","indexMap_","snap_1","isEmpty","util_1","Object","ChildrenNode","SortedMap_1","comparators_1","IndexMap_1","Default","newPriorityNode","childName","getPriority","child","get","path","front","getFront","getImmediateChild","getChild","popFront","newChildNode","updatePriority","namedNode","Node_1","newChildren","newIndexMap","newPriority","remove","removeFromIndexes","insert","addToIndexes","getLength","newImmediateChild","updateChild","updateImmediateChild","count","exportFormat","obj","numKeys","maxKey","allIntegerKeys","forEachChild","PriorityIndex_1","key","childNode","val","INTEGER_REGEXP_","test","Math","max","Number","array","lazyHash_","toHash_1","childHash","hash","util_2","index","idx","resolveIndex_","predecessor","getPredecessorKey","name","indexDefinition","minKey","getFirstChildName","getLastChildName","action","inorderTraversal","wrappedNode","node","getIteratorFrom","minPost","startPost","iterator","Wrap","next","peek","compare","getNext","getReverseIteratorFrom","maxPost","endPost","other","isLeafNode","exports","KeyIndex_1","hasIndex","addIndex","otherChildrenNode","equals","thisIter","getIterator","otherIter","thisCurrent","otherCurrent","toString","__extends","_super","MaxNode","defineProperties","MIN","value","MAX","__EMPTY_NODE","LeafNode_1","__childrenNodeConstructor"],"sources":["../src/core/snap/ChildrenNode.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { sha1, MAX_NAME, MIN_NAME } from '../util/util';\nimport { SortedMap, SortedMapIterator } from '../util/SortedMap';\nimport { Node, NamedNode } from './Node';\nimport { validatePriorityNode, priorityHashText, setMaxNode } from './snap';\nimport {\n  PRIORITY_INDEX,\n  setMaxNode as setPriorityMaxNode\n} from './indexes/PriorityIndex';\nimport { KEY_INDEX, KeyIndex } from './indexes/KeyIndex';\nimport { IndexMap } from './IndexMap';\nimport { LeafNode } from './LeafNode';\nimport { NAME_COMPARATOR } from './comparators';\nimport { Index } from './indexes/Index';\nimport { Path } from '../util/Path';\n\nexport interface ChildrenNodeConstructor {\n  new (\n    children_: SortedMap<string, Node>,\n    priorityNode_: Node | null,\n    indexMap_: IndexMap\n  ): ChildrenNode;\n  EMPTY_NODE: ChildrenNode;\n}\n\n// TODO: For memory savings, don't store priorityNode_ if it's empty.\n\nlet EMPTY_NODE: ChildrenNode;\n\n/**\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\n * (i.e. nodes with children).  It implements Node and stores the\n * list of children in the children property, sorted by child name.\n *\n * @constructor\n * @implements {Node}\n */\nexport class ChildrenNode implements Node {\n  private lazyHash_: string | null = null;\n\n  static get EMPTY_NODE(): ChildrenNode {\n    return (\n      EMPTY_NODE ||\n      (EMPTY_NODE = new ChildrenNode(\n        new SortedMap<string, Node>(NAME_COMPARATOR),\n        null,\n        IndexMap.Default\n      ))\n    );\n  }\n\n  /**\n   *\n   * @param {!SortedMap.<string, !Node>} children_ List of children\n   * of this node..\n   * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).\n   * @param {!IndexMap} indexMap_\n   */\n  constructor(\n    private readonly children_: SortedMap<string, Node>,\n    private readonly priorityNode_: Node | null,\n    private indexMap_: IndexMap\n  ) {\n    /**\n     * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\n     * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\n     * class instead of an empty ChildrenNode.\n     */\n    if (this.priorityNode_) {\n      validatePriorityNode(this.priorityNode_);\n    }\n\n    if (this.children_.isEmpty()) {\n      assert(\n        !this.priorityNode_ || this.priorityNode_.isEmpty(),\n        'An empty node cannot have a priority'\n      );\n    }\n  }\n\n  /** @inheritDoc */\n  isLeafNode(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  getPriority(): Node {\n    return this.priorityNode_ || EMPTY_NODE;\n  }\n\n  /** @inheritDoc */\n  updatePriority(newPriorityNode: Node): Node {\n    if (this.children_.isEmpty()) {\n      // Don't allow priorities on empty nodes\n      return this;\n    } else {\n      return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n    }\n  }\n\n  /** @inheritDoc */\n  getImmediateChild(childName: string): Node {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.getPriority();\n    } else {\n      const child = this.children_.get(childName);\n      return child === null ? EMPTY_NODE : child;\n    }\n  }\n\n  /** @inheritDoc */\n  getChild(path: Path): Node {\n    const front = path.getFront();\n    if (front === null) return this;\n\n    return this.getImmediateChild(front).getChild(path.popFront());\n  }\n\n  /** @inheritDoc */\n  hasChild(childName: string): boolean {\n    return this.children_.get(childName) !== null;\n  }\n\n  /** @inheritDoc */\n  updateImmediateChild(childName: string, newChildNode: Node): Node {\n    assert(newChildNode, 'We should always be passing snapshot nodes');\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else {\n      const namedNode = new NamedNode(childName, newChildNode);\n      let newChildren, newIndexMap, newPriority;\n      if (newChildNode.isEmpty()) {\n        newChildren = this.children_.remove(childName);\n        newIndexMap = this.indexMap_.removeFromIndexes(\n          namedNode,\n          this.children_\n        );\n      } else {\n        newChildren = this.children_.insert(childName, newChildNode);\n        newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n      }\n\n      newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n      return new ChildrenNode(newChildren, newPriority, newIndexMap);\n    }\n  }\n\n  /** @inheritDoc */\n  updateChild(path: Path, newChildNode: Node): Node {\n    const front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else {\n      assert(\n        path.getFront() !== '.priority' || path.getLength() === 1,\n        '.priority must be the last token in a path'\n      );\n      const newImmediateChild = this.getImmediateChild(front).updateChild(\n        path.popFront(),\n        newChildNode\n      );\n      return this.updateImmediateChild(front, newImmediateChild);\n    }\n  }\n\n  /** @inheritDoc */\n  isEmpty(): boolean {\n    return this.children_.isEmpty();\n  }\n\n  /** @inheritDoc */\n  numChildren(): number {\n    return this.children_.count();\n  }\n\n  /**\n   * @private\n   * @type {RegExp}\n   */\n  private static INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\n\n  /** @inheritDoc */\n  val(exportFormat?: boolean): object {\n    if (this.isEmpty()) return null;\n\n    const obj: { [k: string]: Object } = {};\n    let numKeys = 0,\n      maxKey = 0,\n      allIntegerKeys = true;\n    this.forEachChild(PRIORITY_INDEX, function(key: string, childNode: Node) {\n      obj[key] = childNode.val(exportFormat);\n\n      numKeys++;\n      if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n        maxKey = Math.max(maxKey, Number(key));\n      } else {\n        allIntegerKeys = false;\n      }\n    });\n\n    if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n      // convert to array.\n      const array: Object[] = [];\n      for (let key in obj) array[(key as any) as number] = obj[key];\n\n      return array;\n    } else {\n      if (exportFormat && !this.getPriority().isEmpty()) {\n        obj['.priority'] = this.getPriority().val();\n      }\n      return obj;\n    }\n  }\n\n  /** @inheritDoc */\n  hash(): string {\n    if (this.lazyHash_ === null) {\n      let toHash = '';\n      if (!this.getPriority().isEmpty())\n        toHash +=\n          'priority:' +\n          priorityHashText(this.getPriority().val() as string | number) +\n          ':';\n\n      this.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n        const childHash = childNode.hash();\n        if (childHash !== '') toHash += ':' + key + ':' + childHash;\n      });\n\n      this.lazyHash_ = toHash === '' ? '' : sha1(toHash);\n    }\n    return this.lazyHash_;\n  }\n\n  /** @inheritDoc */\n  getPredecessorChildName(\n    childName: string,\n    childNode: Node,\n    index: Index\n  ): string {\n    const idx = this.resolveIndex_(index);\n    if (idx) {\n      const predecessor = idx.getPredecessorKey(\n        new NamedNode(childName, childNode)\n      );\n      return predecessor ? predecessor.name : null;\n    } else {\n      return this.children_.getPredecessorKey(childName);\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  getFirstChildName(indexDefinition: Index): string | null {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      const minKey = idx.minKey();\n      return minKey && minKey.name;\n    } else {\n      return this.children_.minKey();\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  getFirstChild(indexDefinition: Index): NamedNode | null {\n    const minKey = this.getFirstChildName(indexDefinition);\n    if (minKey) {\n      return new NamedNode(minKey, this.children_.get(minKey));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Given an index, return the key name of the largest value we have, according to that index\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  getLastChildName(indexDefinition: Index): string | null {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      const maxKey = idx.maxKey();\n      return maxKey && maxKey.name;\n    } else {\n      return this.children_.maxKey();\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  getLastChild(indexDefinition: Index): NamedNode | null {\n    const maxKey = this.getLastChildName(indexDefinition);\n    if (maxKey) {\n      return new NamedNode(maxKey, this.children_.get(maxKey));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachChild(index: Index, action: (key: string, node: Node) => void): any {\n    const idx = this.resolveIndex_(index);\n    if (idx) {\n      return idx.inorderTraversal(function(wrappedNode) {\n        return action(wrappedNode.name, wrappedNode.node);\n      });\n    } else {\n      return this.children_.inorderTraversal(action);\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {SortedMapIterator}\n   */\n  getIterator(\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n  }\n\n  /**\n   *\n   * @param {!NamedNode} startPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getIteratorFrom(\n    startPost: NamedNode,\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getIteratorFrom(startPost, key => key);\n    } else {\n      const iterator = this.children_.getIteratorFrom(\n        startPost.name,\n        NamedNode.Wrap\n      );\n      let next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, startPost) < 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getReverseIterator(\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    return this.getReverseIteratorFrom(\n      indexDefinition.maxPost(),\n      indexDefinition\n    );\n  }\n\n  /**\n   * @param {!NamedNode} endPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getReverseIteratorFrom(\n    endPost: NamedNode,\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getReverseIteratorFrom(endPost, function(key) {\n        return key;\n      });\n    } else {\n      const iterator = this.children_.getReverseIteratorFrom(\n        endPost.name,\n        NamedNode.Wrap\n      );\n      let next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, endPost) > 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compareTo(other: ChildrenNode): number {\n    if (this.isEmpty()) {\n      if (other.isEmpty()) {\n        return 0;\n      } else {\n        return -1;\n      }\n    } else if (other.isLeafNode() || other.isEmpty()) {\n      return 1;\n    } else if (other === MAX_NODE) {\n      return -1;\n    } else {\n      // Must be another node with children.\n      return 0;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  withIndex(indexDefinition: Index): Node {\n    if (\n      indexDefinition === KEY_INDEX ||\n      this.indexMap_.hasIndex(indexDefinition)\n    ) {\n      return this;\n    } else {\n      const newIndexMap = this.indexMap_.addIndex(\n        indexDefinition,\n        this.children_\n      );\n      return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isIndexed(index: Index): boolean {\n    return index === KEY_INDEX || this.indexMap_.hasIndex(index);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  equals(other: Node): boolean {\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      return false;\n    } else {\n      const otherChildrenNode = other as ChildrenNode;\n      if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n        return false;\n      } else if (\n        this.children_.count() === otherChildrenNode.children_.count()\n      ) {\n        const thisIter = this.getIterator(PRIORITY_INDEX);\n        const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\n        let thisCurrent = thisIter.getNext();\n        let otherCurrent = otherIter.getNext();\n        while (thisCurrent && otherCurrent) {\n          if (\n            thisCurrent.name !== otherCurrent.name ||\n            !thisCurrent.node.equals(otherCurrent.node)\n          ) {\n            return false;\n          }\n          thisCurrent = thisIter.getNext();\n          otherCurrent = otherIter.getNext();\n        }\n        return thisCurrent === null && otherCurrent === null;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\n   * instead.\n   *\n   * @private\n   * @param {!Index} indexDefinition\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  private resolveIndex_(\n    indexDefinition: Index\n  ): SortedMap<NamedNode, Node> | null {\n    if (indexDefinition === KEY_INDEX) {\n      return null;\n    } else {\n      return this.indexMap_.get(indexDefinition.toString());\n    }\n  }\n}\n\n/**\n * @constructor\n * @extends {ChildrenNode}\n * @private\n */\nexport class MaxNode extends ChildrenNode {\n  constructor() {\n    super(\n      new SortedMap<string, Node>(NAME_COMPARATOR),\n      ChildrenNode.EMPTY_NODE,\n      IndexMap.Default\n    );\n  }\n\n  compareTo(other: Node): number {\n    if (other === this) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n\n  equals(other: Node): boolean {\n    // Not that we every compare it, but MAX_NODE is only ever equal to itself\n    return other === this;\n  }\n\n  getPriority(): MaxNode {\n    return this;\n  }\n\n  getImmediateChild(childName: string): ChildrenNode {\n    return ChildrenNode.EMPTY_NODE;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n}\n\n/**\n * Marker that will sort higher than any other snapshot.\n * @type {!MAX_NODE}\n * @const\n */\nexport const MAX_NODE = new MaxNode();\n\n/**\n * Document NamedNode extensions\n */\ndeclare module './Node' {\n  interface NamedNode {\n    MIN: NamedNode;\n    MAX: NamedNode;\n  }\n}\n\nObject.defineProperties(NamedNode, {\n  MIN: {\n    value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\n  },\n  MAX: {\n    value: new NamedNode(MAX_NAME, MAX_NODE)\n  }\n});\n\n/**\n * Reference Extensions\n */\nKeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode.__childrenNodeConstructor = ChildrenNode;\nsetMaxNode(MAX_NODE);\nsetPriorityMaxNode(MAX_NODE);\n"]},"metadata":{},"sourceType":"script"}