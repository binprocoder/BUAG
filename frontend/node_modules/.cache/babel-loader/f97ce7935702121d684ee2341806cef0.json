{"ast":null,"code":"'use strict'; // The Resolver is currently experimental and might be exposed to users in the future.\n\nconst pa = require('path');\n\nconst fs = require('fs');\n\nconst {\n  VMError\n} = require('./bridge');\n\nconst {\n  VMScript\n} = require('./script'); // This should match. Note that '\\', '%' are invalid characters\n// 1. name/.*\n// 2. @scope/name/.*\n\n\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^/\\\\%]+)(\\/.*)?$/; // See https://tc39.es/ecma262/#integer-index\n\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFFFFFF;\n}\n\nclass Resolver {\n  constructor(builtinModules, globalPaths, hostRequire) {\n    this.builtinModules = builtinModules;\n    this.globalPaths = globalPaths;\n    this.hostRequire = hostRequire;\n  }\n\n  init(vm) {}\n\n  pathResolve(path) {\n    return pa.resolve(path);\n  }\n\n  pathIsRelative(path) {\n    if (path === '' || path[0] !== '.') return false;\n    if (path.length === 1) return true;\n    const idx = path[1] === '.' ? 2 : 1;\n    if (path.length <= idx) return false;\n    return path[idx] === '/' || path[idx] === pa.sep;\n  }\n\n  pathIsAbsolute(path) {\n    return pa.isAbsolute(path);\n  }\n\n  pathConcat(...paths) {\n    return pa.join(...paths);\n  }\n\n  pathBasename(path) {\n    return pa.basename(path);\n  }\n\n  pathDirname(path) {\n    return pa.dirname(path);\n  }\n\n  lookupPaths(mod, id) {\n    if (typeof id === 'string') throw new Error('Id is not a string');\n    if (this.pathIsRelative(id)) return [mod.path || '.'];\n    return [...mod.paths, ...this.globalPaths];\n  }\n\n  getBuiltinModulesList() {\n    return Object.getOwnPropertyNames(this.builtinModules);\n  }\n\n  loadBuiltinModule(vm, id) {\n    const handler = this.builtinModules[id];\n    return handler && handler(this, vm, id);\n  }\n\n  loadJS(vm, mod, filename) {\n    throw new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n  }\n\n  loadJSON(vm, mod, filename) {\n    throw new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n  }\n\n  loadNode(vm, mod, filename) {\n    throw new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n  }\n\n  registerModule(mod, filename, path, parent, direct) {}\n\n  resolve(mod, x, options, ext, direct) {\n    if (typeof x !== 'string') throw new Error('Id is not a string');\n\n    if (x.startsWith('node:') || this.builtinModules[x]) {\n      // a. return the core module\n      // b. STOP\n      return x;\n    }\n\n    return this.resolveFull(mod, x, options, ext, direct);\n  }\n\n  resolveFull(mod, x, options, ext, direct) {\n    // 7. THROW \"not found\"\n    throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n  } // NODE_MODULES_PATHS(START)\n\n\n  genLookupPaths(path) {\n    // 1. let PARTS = path split(START)\n    // 2. let I = count of PARTS - 1\n    // 3. let DIRS = []\n    const dirs = []; // 4. while I >= 0,\n\n    while (true) {\n      const name = this.pathBasename(path); // a. if PARTS[I] = \"node_modules\" CONTINUE\n\n      if (name !== 'node_modules') {\n        // b. DIR = path join(PARTS[0 .. I] + \"node_modules\")\n        // c. DIRS = DIR + DIRS // Note: this seems wrong. Should be DIRS + DIR\n        dirs.push(this.pathConcat(path, 'node_modules'));\n      }\n\n      const dir = this.pathDirname(path);\n      if (dir == path) break; // d. let I = I - 1\n\n      path = dir;\n    }\n\n    return dirs; // This is done later on\n    // 5. return DIRS + GLOBAL_FOLDERS\n  }\n\n}\n\nclass DefaultResolver extends Resolver {\n  constructor(builtinModules, checkPath, globalPaths, pathContext, customResolver, hostRequire, compiler) {\n    super(builtinModules, globalPaths, hostRequire);\n    this.checkPath = checkPath;\n    this.pathContext = pathContext;\n    this.customResolver = customResolver;\n    this.compiler = compiler;\n    this.packageCache = {\n      __proto__: null\n    };\n    this.scriptCache = {\n      __proto__: null\n    };\n  }\n\n  isPathAllowed(path) {\n    return this.checkPath(path);\n  }\n\n  pathTestIsDirectory(path) {\n    try {\n      const stat = fs.statSync(path, {\n        __proto__: null,\n        throwIfNoEntry: false\n      });\n      return stat && stat.isDirectory();\n    } catch (e) {\n      return false;\n    }\n  }\n\n  pathTestIsFile(path) {\n    try {\n      const stat = fs.statSync(path, {\n        __proto__: null,\n        throwIfNoEntry: false\n      });\n      return stat && stat.isFile();\n    } catch (e) {\n      return false;\n    }\n  }\n\n  readFile(path) {\n    return fs.readFileSync(path, {\n      encoding: 'utf8'\n    });\n  }\n\n  readFileWhenExists(path) {\n    return this.pathTestIsFile(path) ? this.readFile(path) : undefined;\n  }\n\n  readScript(filename) {\n    let script = this.scriptCache[filename];\n\n    if (!script) {\n      script = new VMScript(this.readFile(filename), {\n        filename,\n        compiler: this.compiler\n      });\n      this.scriptCache[filename] = script;\n    }\n\n    return script;\n  }\n\n  checkAccess(mod, filename) {\n    if (!this.isPathAllowed(filename)) {\n      throw new VMError(`Module '${filename}' is not allowed to be required. The path is outside the border!`, 'EDENIED');\n    }\n  }\n\n  loadJS(vm, mod, filename) {\n    filename = this.pathResolve(filename);\n    this.checkAccess(mod, filename);\n\n    if (this.pathContext(filename, 'js') === 'sandbox') {\n      const script = this.readScript(filename);\n      vm.run(script, {\n        filename,\n        strict: true,\n        module: mod,\n        wrapper: 'none',\n        dirname: mod.path\n      });\n    } else {\n      const m = this.hostRequire(filename);\n      mod.exports = vm.readonly(m);\n    }\n  }\n\n  loadJSON(vm, mod, filename) {\n    filename = this.pathResolve(filename);\n    this.checkAccess(mod, filename);\n    const json = this.readFile(filename);\n    mod.exports = vm._jsonParse(json);\n  }\n\n  loadNode(vm, mod, filename) {\n    filename = this.pathResolve(filename);\n    this.checkAccess(mod, filename);\n    if (this.pathContext(filename, 'node') === 'sandbox') throw new VMError('Native modules can be required only with context set to \\'host\\'.');\n    const m = this.hostRequire(filename);\n    mod.exports = vm.readonly(m);\n  } // require(X) from module at path Y\n\n\n  resolveFull(mod, x, options, ext, direct) {\n    // Note: core module handled by caller\n    const extList = Object.getOwnPropertyNames(ext);\n    const path = mod.path || '.'; // 5. LOAD_PACKAGE_SELF(X, dirname(Y))\n\n    let f = this.loadPackageSelf(x, path, extList);\n    if (f) return f; // 4. If X begins with '#'\n\n    if (x[0] === '#') {\n      // a. LOAD_PACKAGE_IMPORTS(X, dirname(Y))\n      f = this.loadPackageImports(x, path, extList);\n      if (f) return f;\n    } // 2. If X begins with '/'\n\n\n    if (this.pathIsAbsolute(x)) {\n      // a. set Y to be the filesystem root\n      f = this.loadAsFileOrDirecotry(x, extList);\n      if (f) return f; // c. THROW \"not found\"\n\n      throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND'); // 3. If X begins with './' or '/' or '../'\n    } else if (this.pathIsRelative(x)) {\n      if (typeof options === 'object' && options !== null) {\n        const paths = options.paths;\n\n        if (Array.isArray(paths)) {\n          for (let i = 0; i < paths.length; i++) {\n            // a. LOAD_AS_FILE(Y + X)\n            // b. LOAD_AS_DIRECTORY(Y + X)\n            f = this.loadAsFileOrDirecotry(this.pathConcat(paths[i], x), extList);\n            if (f) return f;\n          }\n        } else if (paths === undefined) {\n          // a. LOAD_AS_FILE(Y + X)\n          // b. LOAD_AS_DIRECTORY(Y + X)\n          f = this.loadAsFileOrDirecotry(this.pathConcat(path, x), extList);\n          if (f) return f;\n        } else {\n          throw new VMError('Invalid options.paths option.');\n        }\n      } else {\n        // a. LOAD_AS_FILE(Y + X)\n        // b. LOAD_AS_DIRECTORY(Y + X)\n        f = this.loadAsFileOrDirecotry(this.pathConcat(path, x), extList);\n        if (f) return f;\n      } // c. THROW \"not found\"\n\n\n      throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n    }\n\n    let dirs;\n\n    if (typeof options === 'object' && options !== null) {\n      const paths = options.paths;\n\n      if (Array.isArray(paths)) {\n        dirs = [];\n\n        for (let i = 0; i < paths.length; i++) {\n          const lookups = this.genLookupPaths(paths[i]);\n\n          for (let j = 0; j < lookups.length; j++) {\n            if (!dirs.includes(lookups[j])) dirs.push(lookups[j]);\n          }\n\n          if (i === 0) {\n            const globalPaths = this.globalPaths;\n\n            for (let j = 0; j < globalPaths.length; j++) {\n              if (!dirs.includes(globalPaths[j])) dirs.push(globalPaths[j]);\n            }\n          }\n        }\n      } else if (paths === undefined) {\n        dirs = [...mod.paths, ...this.globalPaths];\n      } else {\n        throw new VMError('Invalid options.paths option.');\n      }\n    } else {\n      dirs = [...mod.paths, ...this.globalPaths];\n    } // 6. LOAD_NODE_MODULES(X, dirname(Y))\n\n\n    f = this.loadNodeModules(x, dirs, extList);\n    if (f) return f;\n    f = this.customResolver(this, x, path, extList);\n    if (f) return f;\n    return super.resolveFull(mod, x, options, ext, direct);\n  }\n\n  loadAsFileOrDirecotry(x, extList) {\n    // a. LOAD_AS_FILE(X)\n    const f = this.loadAsFile(x, extList);\n    if (f) return f; // b. LOAD_AS_DIRECTORY(X)\n\n    return this.loadAsDirectory(x, extList);\n  }\n\n  tryFile(x) {\n    x = this.pathResolve(x);\n    return this.isPathAllowed(x) && this.pathTestIsFile(x) ? x : undefined;\n  }\n\n  tryWithExtension(x, extList) {\n    for (let i = 0; i < extList.length; i++) {\n      const ext = extList[i];\n      if (ext !== this.pathBasename(ext)) continue;\n      const f = this.tryFile(x + ext);\n      if (f) return f;\n    }\n\n    return undefined;\n  }\n\n  readPackage(path) {\n    const packagePath = this.pathResolve(this.pathConcat(path, 'package.json'));\n    const cache = this.packageCache[packagePath];\n    if (cache !== undefined) return cache;\n    if (!this.isPathAllowed(packagePath)) return undefined;\n    const content = this.readFileWhenExists(packagePath);\n\n    if (!content) {\n      this.packageCache[packagePath] = false;\n      return false;\n    }\n\n    let parsed;\n\n    try {\n      parsed = JSON.parse(content);\n    } catch (e) {\n      e.path = packagePath;\n      e.message = 'Error parsing ' + packagePath + ': ' + e.message;\n      throw e;\n    }\n\n    const filtered = {\n      name: parsed.name,\n      main: parsed.main,\n      exports: parsed.exports,\n      imports: parsed.imports,\n      type: parsed.type\n    };\n    this.packageCache[packagePath] = filtered;\n    return filtered;\n  }\n\n  readPackageScope(path) {\n    while (true) {\n      const dir = this.pathDirname(path);\n      if (dir === path) break;\n      const basename = this.pathBasename(dir);\n      if (basename === 'node_modules') break;\n      const pack = this.readPackage(dir);\n      if (pack) return {\n        data: pack,\n        scope: dir\n      };\n      path = dir;\n    }\n\n    return {\n      data: undefined,\n      scope: undefined\n    };\n  } // LOAD_AS_FILE(X)\n\n\n  loadAsFile(x, extList) {\n    // 1. If X is a file, load X as its file extension format. STOP\n    const f = this.tryFile(x);\n    if (f) return f; // 2. If X.js is a file, load X.js as JavaScript text. STOP\n    // 3. If X.json is a file, parse X.json to a JavaScript Object. STOP\n    // 4. If X.node is a file, load X.node as binary addon. STOP\n\n    return this.tryWithExtension(x, extList);\n  } // LOAD_INDEX(X)\n\n\n  loadIndex(x, extList) {\n    // 1. If X/index.js is a file, load X/index.js as JavaScript text. STOP\n    // 2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP\n    // 3. If X/index.node is a file, load X/index.node as binary addon. STOP\n    return this.tryWithExtension(this.pathConcat(x, 'index'), extList);\n  } // LOAD_AS_DIRECTORY(X)\n\n\n  loadAsPackage(x, pack, extList) {\n    // 1. If X/package.json is a file,\n    // already done.\n    if (pack) {\n      // a. Parse X/package.json, and look for \"main\" field.\n      // b. If \"main\" is a falsy value, GOTO 2.\n      if (typeof pack.main === 'string') {\n        // c. let M = X + (json main field)\n        const m = this.pathConcat(x, pack.main); // d. LOAD_AS_FILE(M)\n\n        let f = this.loadAsFile(m, extList);\n        if (f) return f; // e. LOAD_INDEX(M)\n\n        f = this.loadIndex(m, extList);\n        if (f) return f; // f. LOAD_INDEX(X) DEPRECATED\n\n        f = this.loadIndex(x, extList);\n        if (f) return f; // g. THROW \"not found\"\n\n        throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n      }\n    } // 2. LOAD_INDEX(X)\n\n\n    return this.loadIndex(x, extList);\n  } // LOAD_AS_DIRECTORY(X)\n\n\n  loadAsDirectory(x, extList) {\n    // 1. If X/package.json is a file,\n    const pack = this.readPackage(x);\n    return this.loadAsPackage(x, pack, extList);\n  } // LOAD_NODE_MODULES(X, START)\n\n\n  loadNodeModules(x, dirs, extList) {\n    // 1. let DIRS = NODE_MODULES_PATHS(START)\n    // This step is already done.\n    // 2. for each DIR in DIRS:\n    for (let i = 0; i < dirs.length; i++) {\n      const dir = dirs[i]; // a. LOAD_PACKAGE_EXPORTS(X, DIR)\n\n      let f = this.loadPackageExports(x, dir, extList);\n      if (f) return f; // b. LOAD_AS_FILE(DIR/X)\n\n      f = this.loadAsFile(dir + '/' + x, extList);\n      if (f) return f; // c. LOAD_AS_DIRECTORY(DIR/X)\n\n      f = this.loadAsDirectory(dir + '/' + x, extList);\n      if (f) return f;\n    }\n\n    return undefined;\n  } // LOAD_PACKAGE_IMPORTS(X, DIR)\n\n\n  loadPackageImports(x, dir, extList) {\n    // 1. Find the closest package scope SCOPE to DIR.\n    const {\n      data,\n      scope\n    } = this.readPackageScope(dir); // 2. If no scope was found, return.\n\n    if (!data) return undefined; // 3. If the SCOPE/package.json \"imports\" is null or undefined, return.\n\n    if (typeof data.imports !== 'object' || data.imports === null || Array.isArray(data.imports)) return undefined; // 4. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE),\n    //   [\"node\", \"require\"]) defined in the ESM resolver.\n    // PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)\n    // 1. Assert: specifier begins with \"#\".\n    // 2. If specifier is exactly equal to \"#\" or starts with \"#/\", then\n\n    if (x === '#' || x.startsWith('#/')) {\n      // a. Throw an Invalid Module Specifier error.\n      throw new VMError(`Invalid module specifier '${x}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n    } // 3. Let packageURL be the result of LOOKUP_PACKAGE_SCOPE(parentURL).\n    // Note: packageURL === parentURL === scope\n    // 4. If packageURL is not null, then\n    // Always true\n    // a. Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n    // pjson === data\n    // b. If pjson.imports is a non-null Object, then\n    // Already tested\n    // x. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( specifier, pjson.imports, packageURL, true, conditions).\n\n\n    const match = this.packageImportsExportsResolve(x, data.imports, scope, true, ['node', 'require'], extList); // y. If resolved is not null or undefined, return resolved.\n\n    if (!match) {\n      // 5. Throw a Package Import Not Defined error.\n      throw new VMError(`Package import not defined for '${x}'`, 'ERR_PACKAGE_IMPORT_NOT_DEFINED');\n    } // END PACKAGE_IMPORTS_RESOLVE\n    // 5. RESOLVE_ESM_MATCH(MATCH).\n\n\n    return this.resolveEsmMatch(match, x, extList);\n  } // LOAD_PACKAGE_EXPORTS(X, DIR)\n\n\n  loadPackageExports(x, dir, extList) {\n    // 1. Try to interpret X as a combination of NAME and SUBPATH where the name\n    //    may have a @scope/ prefix and the subpath begins with a slash (`/`).\n    const res = x.match(EXPORTS_PATTERN); // 2. If X does not match this pattern or DIR/NAME/package.json is not a file,\n    //    return.\n\n    if (!res) return undefined;\n    const scope = this.pathConcat(dir, res[1]);\n    const pack = this.readPackage(scope);\n    if (!pack) return undefined; // 3. Parse DIR/NAME/package.json, and look for \"exports\" field.\n    // 4. If \"exports\" is null or undefined, return.\n\n    if (!pack.exports) return undefined; // 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), \".\" + SUBPATH,\n    //    `package.json` \"exports\", [\"node\", \"require\"]) defined in the ESM resolver.\n\n    const match = this.packageExportsResolve(scope, '.' + (res[2] || ''), pack.exports, ['node', 'require'], extList); // 6. RESOLVE_ESM_MATCH(MATCH)\n\n    return this.resolveEsmMatch(match, x, extList);\n  } // LOAD_PACKAGE_SELF(X, DIR)\n\n\n  loadPackageSelf(x, dir, extList) {\n    // 1. Find the closest package scope SCOPE to DIR.\n    const {\n      data,\n      scope\n    } = this.readPackageScope(dir); // 2. If no scope was found, return.\n\n    if (!data) return undefined; // 3. If the SCOPE/package.json \"exports\" is null or undefined, return.\n\n    if (!data.exports) return undefined; // 4. If the SCOPE/package.json \"name\" is not the first segment of X, return.\n\n    if (x !== data.name && !x.startsWith(data.name + '/')) return undefined; // 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE),\n    //    \".\" + X.slice(\"name\".length), `package.json` \"exports\", [\"node\", \"require\"])\n    //    defined in the ESM resolver.\n\n    const match = this.packageExportsResolve(scope, '.' + x.slice(data.name.length), data.exports, ['node', 'require'], extList); // 6. RESOLVE_ESM_MATCH(MATCH)\n\n    return this.resolveEsmMatch(match, x, extList);\n  } // RESOLVE_ESM_MATCH(MATCH)\n\n\n  resolveEsmMatch(match, x, extList) {\n    // 1. let { RESOLVED, EXACT } = MATCH\n    const resolved = match;\n    const exact = true; // 2. let RESOLVED_PATH = fileURLToPath(RESOLVED)\n\n    const resolvedPath = resolved;\n    let f; // 3. If EXACT is true,\n\n    if (exact) {\n      // a. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension\n      // format. STOP\n      f = this.tryFile(resolvedPath); // 4. Otherwise, if EXACT is false,\n    } else {\n      // a. LOAD_AS_FILE(RESOLVED_PATH)\n      // b. LOAD_AS_DIRECTORY(RESOLVED_PATH)\n      f = this.loadAsFileOrDirecotry(resolvedPath, extList);\n    }\n\n    if (f) return f; // 5. THROW \"not found\"\n\n    throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n  } // PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)\n\n\n  packageExportsResolve(packageURL, subpath, rexports, conditions, extList) {\n    // 1. If exports is an Object with both a key starting with \".\" and a key not starting with \".\", throw an Invalid Package Configuration error.\n    let hasDots = false;\n\n    if (typeof rexports === 'object' && !Array.isArray(rexports)) {\n      const keys = Object.getOwnPropertyNames(rexports);\n\n      if (keys.length > 0) {\n        hasDots = keys[0][0] === '.';\n\n        for (let i = 0; i < keys.length; i++) {\n          if (hasDots !== (keys[i][0] === '.')) {\n            throw new VMError('Invalid package configuration', 'ERR_INVALID_PACKAGE_CONFIGURATION');\n          }\n        }\n      }\n    } // 2. If subpath is equal to \".\", then\n\n\n    if (subpath === '.') {\n      // a. Let mainExport be undefined.\n      let mainExport = undefined; // b. If exports is a String or Array, or an Object containing no keys starting with \".\", then\n\n      if (typeof rexports === 'string' || Array.isArray(rexports) || !hasDots) {\n        // x. Set mainExport to exports.\n        mainExport = rexports; // c. Otherwise if exports is an Object containing a \".\" property, then\n      } else if (hasDots) {\n        // x. Set mainExport to exports[\".\"].\n        mainExport = rexports['.'];\n      } // d. If mainExport is not undefined, then\n\n\n      if (mainExport) {\n        // x. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, mainExport, \"\", false, false, conditions).\n        const resolved = this.packageTargetResolve(packageURL, mainExport, '', false, false, conditions, extList); // y. If resolved is not null or undefined, return resolved.\n\n        if (resolved) return resolved;\n      } // 3. Otherwise, if exports is an Object and all keys of exports start with \".\", then\n\n    } else if (hasDots) {\n      // a. Let matchKey be the string \"./\" concatenated with subpath.\n      // Note: Here subpath starts already with './'\n      // b. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( matchKey, exports, packageURL, false, conditions).\n      const resolved = this.packageImportsExportsResolve(subpath, rexports, packageURL, false, conditions, extList); // c. If resolved is not null or undefined, return resolved.\n\n      if (resolved) return resolved;\n    } // 4. Throw a Package Path Not Exported error.\n\n\n    throw new VMError(`Package path '${subpath}' is not exported`, 'ERR_PACKAGE_PATH_NOT_EXPORTED');\n  } // PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports, conditions)\n\n\n  packageImportsExportsResolve(matchKey, matchObj, packageURL, isImports, conditions, extList) {\n    // 1. If matchKey is a key of matchObj and does not contain \"*\", then\n    let target = matchObj[matchKey];\n\n    if (target && matchKey.indexOf('*') === -1) {\n      // a. Let target be the value of matchObj[matchKey].\n      // b. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, \"\", false, isImports, conditions).\n      return this.packageTargetResolve(packageURL, target, '', false, isImports, conditions, extList);\n    } // 2. Let expansionKeys be the list of keys of matchObj containing only a single \"*\",\n    //    sorted by the sorting function PATTERN_KEY_COMPARE which orders in descending order of specificity.\n\n\n    const expansionKeys = Object.getOwnPropertyNames(matchObj);\n    let bestKey = '';\n    let bestSubpath; // 3. For each key expansionKey in expansionKeys, do\n\n    for (let i = 0; i < expansionKeys.length; i++) {\n      const expansionKey = expansionKeys[i];\n      if (matchKey.length < expansionKey.length) continue; // a. Let patternBase be the substring of expansionKey up to but excluding the first \"*\" character.\n\n      const star = expansionKey.indexOf('*');\n      if (star === -1) continue; // Note: expansionKeys was not filtered\n\n      const patternBase = expansionKey.slice(0, star); // b. If matchKey starts with but is not equal to patternBase, then\n\n      if (matchKey.startsWith(patternBase) && expansionKey.indexOf('*', star + 1) === -1) {\n        // Note: expansionKeys was not filtered\n        // 1. Let patternTrailer be the substring of expansionKey from the index after the first \"*\" character.\n        const patternTrailer = expansionKey.slice(star + 1); // 2. If patternTrailer has zero length, or if matchKey ends with patternTrailer and the length of matchKey is greater than or\n        //    equal to the length of expansionKey, then\n\n        if (matchKey.endsWith(patternTrailer) && this.patternKeyCompare(bestKey, expansionKey) === 1) {\n          // Note: expansionKeys was not sorted\n          // a. Let target be the value of matchObj[expansionKey].\n          target = matchObj[expansionKey]; // b. Let subpath be the substring of matchKey starting at the index of the length of patternBase up to the length of\n          //    matchKey minus the length of patternTrailer.\n\n          bestKey = expansionKey;\n          bestSubpath = matchKey.slice(patternBase.length, matchKey.length - patternTrailer.length);\n        }\n      }\n    }\n\n    if (bestSubpath) {\n      // Note: expansionKeys was not sorted\n      // c. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, true, isImports, conditions).\n      return this.packageTargetResolve(packageURL, target, bestSubpath, true, isImports, conditions, extList);\n    } // 4. Return null.\n\n\n    return null;\n  } // PATTERN_KEY_COMPARE(keyA, keyB)\n\n\n  patternKeyCompare(keyA, keyB) {\n    // 1. Assert: keyA ends with \"/\" or contains only a single \"*\".\n    // 2. Assert: keyB ends with \"/\" or contains only a single \"*\".\n    // 3. Let baseLengthA be the index of \"*\" in keyA plus one, if keyA contains \"*\", or the length of keyA otherwise.\n    const baseAStar = keyA.indexOf('*');\n    const baseLengthA = baseAStar === -1 ? keyA.length : baseAStar + 1; // 4. Let baseLengthB be the index of \"*\" in keyB plus one, if keyB contains \"*\", or the length of keyB otherwise.\n\n    const baseBStar = keyB.indexOf('*');\n    const baseLengthB = baseBStar === -1 ? keyB.length : baseBStar + 1; // 5. If baseLengthA is greater than baseLengthB, return -1.\n\n    if (baseLengthA > baseLengthB) return -1; // 6. If baseLengthB is greater than baseLengthA, return 1.\n\n    if (baseLengthB > baseLengthA) return 1; // 7. If keyA does not contain \"*\", return 1.\n\n    if (baseAStar === -1) return 1; // 8. If keyB does not contain \"*\", return -1.\n\n    if (baseBStar === -1) return -1; // 9. If the length of keyA is greater than the length of keyB, return -1.\n\n    if (keyA.length > keyB.length) return -1; // 10. If the length of keyB is greater than the length of keyA, return 1.\n\n    if (keyB.length > keyA.length) return 1; // 11. Return 0.\n\n    return 0;\n  } // PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, pattern, internal, conditions)\n\n\n  packageTargetResolve(packageURL, target, subpath, pattern, internal, conditions, extList) {\n    // 1. If target is a String, then\n    if (typeof target === 'string') {\n      // a. If pattern is false, subpath has non-zero length and target does not end with \"/\", throw an Invalid Module Specifier error.\n      if (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n        throw new VMError(`Invalid package specifier '${subpath}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n      } // b. If target does not start with \"./\", then\n\n\n      if (!target.startsWith('./')) {\n        // 1. If internal is true and target does not start with \"../\" or \"/\" and is not a valid URL, then\n        if (internal && !target.startsWith('../') && !target.startsWith('/')) {\n          let isURL = false;\n\n          try {\n            // eslint-disable-next-line no-new\n            new URL(target);\n            isURL = true;\n          } catch (e) {}\n\n          if (!isURL) {\n            // a. If pattern is true, then\n            if (pattern) {\n              // 1. Return PACKAGE_RESOLVE(target with every instance of \"*\" replaced by subpath, packageURL + \"/\").\n              return this.packageResolve(target.replace(/\\*/g, subpath), packageURL, conditions, extList);\n            } // b. Return PACKAGE_RESOLVE(target + subpath, packageURL + \"/\").\n\n\n            return this.packageResolve(this.pathConcat(target, subpath), packageURL, conditions, extList);\n          }\n        } // Otherwise, throw an Invalid Package Target error.\n\n\n        throw new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n      }\n\n      target = decodeURI(target); // c. If target split on \"/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments after the first segment, case insensitive\n      //    and including percent encoded variants, throw an Invalid Package Target error.\n\n      if (target.split(/[/\\\\]/).slice(1).findIndex(x => x === '.' || x === '..' || x.toLowerCase() === 'node_modules') !== -1) {\n        throw new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n      } // d. Let resolvedTarget be the URL resolution of the concatenation of packageURL and target.\n\n\n      const resolvedTarget = this.pathConcat(packageURL, target); // e. Assert: resolvedTarget is contained in packageURL.\n\n      subpath = decodeURI(subpath); // f. If subpath split on \"/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments, case insensitive and including percent\n      //    encoded variants, throw an Invalid Module Specifier error.\n\n      if (subpath.split(/[/\\\\]/).findIndex(x => x === '.' || x === '..' || x.toLowerCase() === 'node_modules') !== -1) {\n        throw new VMError(`Invalid package specifier '${subpath}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n      } // g. If pattern is true, then\n\n\n      if (pattern) {\n        // 1. Return the URL resolution of resolvedTarget with every instance of \"*\" replaced with subpath.\n        return resolvedTarget.replace(/\\*/g, subpath);\n      } // h. Otherwise,\n      // 1. Return the URL resolution of the concatenation of subpath and resolvedTarget.\n\n\n      return this.pathConcat(resolvedTarget, subpath); // 3. Otherwise, if target is an Array, then\n    } else if (Array.isArray(target)) {\n      // a. If target.length is zero, return null.\n      if (target.length === 0) return null;\n      let lastException = undefined; // b. For each item targetValue in target, do\n\n      for (let i = 0; i < target.length; i++) {\n        const targetValue = target[i]; // 1. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions),\n        //    continuing the loop on any Invalid Package Target error.\n\n        let resolved;\n\n        try {\n          resolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList);\n        } catch (e) {\n          if (e.code !== 'ERR_INVALID_PACKAGE_TARGET') throw e;\n          lastException = e;\n          continue;\n        } // 2. If resolved is undefined, continue the loop.\n        // 3. Return resolved.\n\n\n        if (resolved !== undefined) return resolved;\n\n        if (resolved === null) {\n          lastException = null;\n        }\n      } // c. Return or throw the last fallback resolution null return or error.\n\n\n      if (lastException === undefined || lastException === null) return lastException;\n      throw lastException; // 2. Otherwise, if target is a non-null Object, then\n    } else if (typeof target === 'object' && target !== null) {\n      const keys = Object.getOwnPropertyNames(target); // a. If exports contains any index property keys, as defined in ECMA-262 6.1.7 Array Index, throw an Invalid Package Configuration error.\n\n      for (let i = 0; i < keys.length; i++) {\n        const p = keys[i];\n        if (isArrayIndex(p)) throw new VMError(`Invalid package configuration for '${subpath}'`, 'ERR_INVALID_PACKAGE_CONFIGURATION');\n      } // b. For each property p of target, in object insertion order as,\n\n\n      for (let i = 0; i < keys.length; i++) {\n        const p = keys[i]; // 1. If p equals \"default\" or conditions contains an entry for p, then\n\n        if (p === 'default' || conditions.includes(p)) {\n          // a. Let targetValue be the value of the p property in target.\n          const targetValue = target[p]; // b. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions).\n\n          const resolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList); // c. If resolved is equal to undefined, continue the loop.\n          // d. Return resolved.\n\n          if (resolved !== undefined) return resolved;\n        }\n      } // c. Return undefined.\n\n\n      return undefined; // 4. Otherwise, if target is null, return null.\n    } else if (target == null) {\n      return null;\n    } // Otherwise throw an Invalid Package Target error.\n\n\n    throw new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n  } // PACKAGE_RESOLVE(packageSpecifier, parentURL)\n\n\n  packageResolve(packageSpecifier, parentURL, conditions, extList) {\n    // 1. Let packageName be undefined.\n    let packageName = undefined; // 2. If packageSpecifier is an empty string, then\n\n    if (packageSpecifier === '') {\n      // a. Throw an Invalid Module Specifier error.\n      throw new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n    } // 3. If packageSpecifier is a Node.js builtin module name, then\n\n\n    if (this.builtinModules[packageSpecifier]) {\n      // a. Return the string \"node:\" concatenated with packageSpecifier.\n      return 'node:' + packageSpecifier;\n    }\n\n    let idx = packageSpecifier.indexOf('/'); // 5. Otherwise,\n\n    if (packageSpecifier[0] === '@') {\n      // a. If packageSpecifier does not contain a \"/\" separator, then\n      if (idx === -1) {\n        // x. Throw an Invalid Module Specifier error.\n        throw new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n      } // b. Set packageName to the substring of packageSpecifier until the second \"/\" separator or the end of the string.\n\n\n      idx = packageSpecifier.indexOf('/', idx + 1);\n    } // else\n    // 4. If packageSpecifier does not start with \"@\", then\n    // a. Set packageName to the substring of packageSpecifier until the first \"/\" separator or the end of the string.\n\n\n    packageName = idx === -1 ? packageSpecifier : packageSpecifier.slice(0, idx); // 6. If packageName starts with \".\" or contains \"\\\" or \"%\", then\n\n    if (idx !== 0 && (packageName[0] === '.' || packageName.indexOf('\\\\') >= 0 || packageName.indexOf('%') >= 0)) {\n      // a. Throw an Invalid Module Specifier error.\n      throw new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n    } // 7. Let packageSubpath be \".\" concatenated with the substring of packageSpecifier from the position at the length of packageName.\n\n\n    const packageSubpath = '.' + packageSpecifier.slice(packageName.length); // 8. If packageSubpath ends in \"/\", then\n\n    if (packageSubpath[packageSubpath.length - 1] === '/') {\n      // a. Throw an Invalid Module Specifier error.\n      throw new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n    } // 9. Let selfUrl be the result of PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL).\n\n\n    const selfUrl = this.packageSelfResolve(packageName, packageSubpath, parentURL); // 10. If selfUrl is not undefined, return selfUrl.\n\n    if (selfUrl) return selfUrl; // 11. While parentURL is not the file system root,\n\n    let packageURL;\n\n    while (true) {\n      // a. Let packageURL be the URL resolution of \"node_modules/\" concatenated with packageSpecifier, relative to parentURL.\n      packageURL = this.pathResolve(this.pathConcat(parentURL, 'node_modules', packageSpecifier)); // b. Set parentURL to the parent folder URL of parentURL.\n\n      const parentParentURL = this.pathDirname(parentURL); // c. If the folder at packageURL does not exist, then\n\n      if (this.isPathAllowed(packageURL) && this.pathTestIsDirectory(packageURL)) break; // 1. Continue the next loop iteration.\n\n      if (parentParentURL === parentURL) {\n        // 12. Throw a Module Not Found error.\n        throw new VMError(`Cannot find module '${packageSpecifier}'`, 'ENOTFOUND');\n      }\n\n      parentURL = parentParentURL;\n    } // d. Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n\n\n    const pack = this.readPackage(packageURL); // e. If pjson is not null and pjson.exports is not null or undefined, then\n\n    if (pack && pack.exports) {\n      // 1. Return the result of PACKAGE_EXPORTS_RESOLVE(packageURL, packageSubpath, pjson.exports, defaultConditions).\n      return this.packageExportsResolve(packageURL, packageSubpath, pack.exports, conditions, extList);\n    } // f. Otherwise, if packageSubpath is equal to \".\", then\n\n\n    if (packageSubpath === '.') {\n      // 1. If pjson.main is a string, then\n      // a. Return the URL resolution of main in packageURL.\n      return this.loadAsPackage(packageSubpath, pack, extList);\n    } // g. Otherwise,\n    // 1. Return the URL resolution of packageSubpath in packageURL.\n\n\n    return this.pathConcat(packageURL, packageSubpath);\n  }\n\n}\n\nexports.Resolver = Resolver;\nexports.DefaultResolver = DefaultResolver;","map":{"version":3,"sources":["C:/Users/Bin Tran/Desktop/BUAG/BUAG/frontend/node_modules/vm2/lib/resolver.js"],"names":["pa","require","fs","VMError","VMScript","EXPORTS_PATTERN","isArrayIndex","key","keyNum","Resolver","constructor","builtinModules","globalPaths","hostRequire","init","vm","pathResolve","path","resolve","pathIsRelative","length","idx","sep","pathIsAbsolute","isAbsolute","pathConcat","paths","join","pathBasename","basename","pathDirname","dirname","lookupPaths","mod","id","Error","getBuiltinModulesList","Object","getOwnPropertyNames","loadBuiltinModule","handler","loadJS","filename","loadJSON","loadNode","registerModule","parent","direct","x","options","ext","startsWith","resolveFull","genLookupPaths","dirs","name","push","dir","DefaultResolver","checkPath","pathContext","customResolver","compiler","packageCache","__proto__","scriptCache","isPathAllowed","pathTestIsDirectory","stat","statSync","throwIfNoEntry","isDirectory","e","pathTestIsFile","isFile","readFile","readFileSync","encoding","readFileWhenExists","undefined","readScript","script","checkAccess","run","strict","module","wrapper","m","exports","readonly","json","_jsonParse","extList","f","loadPackageSelf","loadPackageImports","loadAsFileOrDirecotry","Array","isArray","i","lookups","j","includes","loadNodeModules","loadAsFile","loadAsDirectory","tryFile","tryWithExtension","readPackage","packagePath","cache","content","parsed","JSON","parse","message","filtered","main","imports","type","readPackageScope","pack","data","scope","loadIndex","loadAsPackage","loadPackageExports","match","packageImportsExportsResolve","resolveEsmMatch","res","packageExportsResolve","slice","resolved","exact","resolvedPath","packageURL","subpath","rexports","conditions","hasDots","keys","mainExport","packageTargetResolve","matchKey","matchObj","isImports","target","indexOf","expansionKeys","bestKey","bestSubpath","expansionKey","star","patternBase","patternTrailer","endsWith","patternKeyCompare","keyA","keyB","baseAStar","baseLengthA","baseBStar","baseLengthB","pattern","internal","isURL","URL","packageResolve","replace","decodeURI","split","findIndex","toLowerCase","resolvedTarget","lastException","targetValue","code","p","packageSpecifier","parentURL","packageName","packageSubpath","selfUrl","packageSelfResolve","parentParentURL"],"mappings":"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","sourcesContent":["'use strict';\n\n// The Resolver is currently experimental and might be exposed to users in the future.\n\nconst pa = require('path');\nconst fs = require('fs');\n\nconst {\n\tVMError\n} = require('./bridge');\nconst { VMScript } = require('./script');\n\n// This should match. Note that '\\', '%' are invalid characters\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^/\\\\%]+)(\\/.*)?$/;\n\n// See https://tc39.es/ecma262/#integer-index\nfunction isArrayIndex(key) {\n\tconst keyNum = +key;\n\tif (`${keyNum}` !== key) return false;\n\treturn keyNum >= 0 && keyNum < 0xFFFFFFFF;\n}\n\nclass Resolver {\n\n\tconstructor(builtinModules, globalPaths, hostRequire) {\n\t\tthis.builtinModules = builtinModules;\n\t\tthis.globalPaths = globalPaths;\n\t\tthis.hostRequire = hostRequire;\n\t}\n\n\tinit(vm) {\n\n\t}\n\n\tpathResolve(path) {\n\t\treturn pa.resolve(path);\n\t}\n\n\tpathIsRelative(path) {\n\t\tif (path === '' || path[0] !== '.') return false;\n\t\tif (path.length === 1) return true;\n\t\tconst idx = path[1] === '.' ? 2 : 1;\n\t\tif (path.length <= idx) return false;\n\t\treturn path[idx] === '/' || path[idx] === pa.sep;\n\t}\n\n\tpathIsAbsolute(path) {\n\t\treturn pa.isAbsolute(path);\n\t}\n\n\tpathConcat(...paths) {\n\t\treturn pa.join(...paths);\n\t}\n\n\tpathBasename(path) {\n\t\treturn pa.basename(path);\n\t}\n\n\tpathDirname(path) {\n\t\treturn pa.dirname(path);\n\t}\n\n\tlookupPaths(mod, id) {\n\t\tif (typeof id === 'string') throw new Error('Id is not a string');\n\t\tif (this.pathIsRelative(id)) return [mod.path || '.'];\n\t\treturn [...mod.paths, ...this.globalPaths];\n\t}\n\n\tgetBuiltinModulesList() {\n\t\treturn Object.getOwnPropertyNames(this.builtinModules);\n\t}\n\n\tloadBuiltinModule(vm, id) {\n\t\tconst handler = this.builtinModules[id];\n\t\treturn handler && handler(this, vm, id);\n\t}\n\n\tloadJS(vm, mod, filename) {\n\t\tthrow new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n\t}\n\n\tloadJSON(vm, mod, filename) {\n\t\tthrow new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n\t}\n\n\tloadNode(vm, mod, filename) {\n\t\tthrow new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n\t}\n\n\tregisterModule(mod, filename, path, parent, direct) {\n\n\t}\n\n\tresolve(mod, x, options, ext, direct) {\n\t\tif (typeof x !== 'string') throw new Error('Id is not a string');\n\n\t\tif (x.startsWith('node:') || this.builtinModules[x]) {\n\t\t\t// a. return the core module\n\t\t\t// b. STOP\n\t\t\treturn x;\n\t\t}\n\n\t\treturn this.resolveFull(mod, x, options, ext, direct);\n\t}\n\n\tresolveFull(mod, x, options, ext, direct) {\n\t\t// 7. THROW \"not found\"\n\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t}\n\n\t// NODE_MODULES_PATHS(START)\n\tgenLookupPaths(path) {\n\t\t// 1. let PARTS = path split(START)\n\t\t// 2. let I = count of PARTS - 1\n\t\t// 3. let DIRS = []\n\t\tconst dirs = [];\n\t\t// 4. while I >= 0,\n\t\twhile (true) {\n\t\t\tconst name = this.pathBasename(path);\n\t\t\t// a. if PARTS[I] = \"node_modules\" CONTINUE\n\t\t\tif (name !== 'node_modules') {\n\t\t\t\t// b. DIR = path join(PARTS[0 .. I] + \"node_modules\")\n\t\t\t\t// c. DIRS = DIR + DIRS // Note: this seems wrong. Should be DIRS + DIR\n\t\t\t\tdirs.push(this.pathConcat(path, 'node_modules'));\n\t\t\t}\n\t\t\tconst dir = this.pathDirname(path);\n\t\t\tif (dir == path) break;\n\t\t\t// d. let I = I - 1\n\t\t\tpath = dir;\n\t\t}\n\n\t\treturn dirs;\n\t\t// This is done later on\n\t\t// 5. return DIRS + GLOBAL_FOLDERS\n\t}\n\n}\n\nclass DefaultResolver extends Resolver {\n\n\tconstructor(builtinModules, checkPath, globalPaths, pathContext, customResolver, hostRequire, compiler) {\n\t\tsuper(builtinModules, globalPaths, hostRequire);\n\t\tthis.checkPath = checkPath;\n\t\tthis.pathContext = pathContext;\n\t\tthis.customResolver = customResolver;\n\t\tthis.compiler = compiler;\n\t\tthis.packageCache = {__proto__: null};\n\t\tthis.scriptCache = {__proto__: null};\n\t}\n\n\tisPathAllowed(path) {\n\t\treturn this.checkPath(path);\n\t}\n\n\tpathTestIsDirectory(path) {\n\t\ttry {\n\t\t\tconst stat = fs.statSync(path, {__proto__: null, throwIfNoEntry: false});\n\t\t\treturn stat && stat.isDirectory();\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpathTestIsFile(path) {\n\t\ttry {\n\t\t\tconst stat = fs.statSync(path, {__proto__: null, throwIfNoEntry: false});\n\t\t\treturn stat && stat.isFile();\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treadFile(path) {\n\t\treturn fs.readFileSync(path, {encoding: 'utf8'});\n\t}\n\n\treadFileWhenExists(path) {\n\t\treturn this.pathTestIsFile(path) ? this.readFile(path) : undefined;\n\t}\n\n\treadScript(filename) {\n\t\tlet script = this.scriptCache[filename];\n\t\tif (!script) {\n\t\t\tscript = new VMScript(this.readFile(filename), {filename, compiler: this.compiler});\n\t\t\tthis.scriptCache[filename] = script;\n\t\t}\n\t\treturn script;\n\t}\n\n\tcheckAccess(mod, filename) {\n\t\tif (!this.isPathAllowed(filename)) {\n\t\t\tthrow new VMError(`Module '${filename}' is not allowed to be required. The path is outside the border!`, 'EDENIED');\n\t\t}\n\t}\n\n\tloadJS(vm, mod, filename) {\n\t\tfilename = this.pathResolve(filename);\n\t\tthis.checkAccess(mod, filename);\n\t\tif (this.pathContext(filename, 'js') === 'sandbox') {\n\t\t\tconst script = this.readScript(filename);\n\t\t\tvm.run(script, {filename, strict: true, module: mod, wrapper: 'none', dirname: mod.path});\n\t\t} else {\n\t\t\tconst m = this.hostRequire(filename);\n\t\t\tmod.exports = vm.readonly(m);\n\t\t}\n\t}\n\n\tloadJSON(vm, mod, filename) {\n\t\tfilename = this.pathResolve(filename);\n\t\tthis.checkAccess(mod, filename);\n\t\tconst json = this.readFile(filename);\n\t\tmod.exports = vm._jsonParse(json);\n\t}\n\n\tloadNode(vm, mod, filename) {\n\t\tfilename = this.pathResolve(filename);\n\t\tthis.checkAccess(mod, filename);\n\t\tif (this.pathContext(filename, 'node') === 'sandbox') throw new VMError('Native modules can be required only with context set to \\'host\\'.');\n\t\tconst m = this.hostRequire(filename);\n\t\tmod.exports = vm.readonly(m);\n\t}\n\n\t// require(X) from module at path Y\n\tresolveFull(mod, x, options, ext, direct) {\n\t\t// Note: core module handled by caller\n\n\t\tconst extList = Object.getOwnPropertyNames(ext);\n\t\tconst path = mod.path || '.';\n\n\t\t// 5. LOAD_PACKAGE_SELF(X, dirname(Y))\n\t\tlet f = this.loadPackageSelf(x, path, extList);\n\t\tif (f) return f;\n\n\t\t// 4. If X begins with '#'\n\t\tif (x[0] === '#') {\n\t\t\t// a. LOAD_PACKAGE_IMPORTS(X, dirname(Y))\n\t\t\tf = this.loadPackageImports(x, path, extList);\n\t\t\tif (f) return f;\n\t\t}\n\n\t\t// 2. If X begins with '/'\n\t\tif (this.pathIsAbsolute(x)) {\n\t\t\t// a. set Y to be the filesystem root\n\t\t\tf = this.loadAsFileOrDirecotry(x, extList);\n\t\t\tif (f) return f;\n\n\t\t\t// c. THROW \"not found\"\n\t\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\n\t\t// 3. If X begins with './' or '/' or '../'\n\t\t} else if (this.pathIsRelative(x)) {\n\t\t\tif (typeof options === 'object' && options !== null) {\n\t\t\t\tconst paths = options.paths;\n\t\t\t\tif (Array.isArray(paths)) {\n\t\t\t\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\t\t\t\t// a. LOAD_AS_FILE(Y + X)\n\t\t\t\t\t\t// b. LOAD_AS_DIRECTORY(Y + X)\n\t\t\t\t\t\tf = this.loadAsFileOrDirecotry(this.pathConcat(paths[i], x), extList);\n\t\t\t\t\t\tif (f) return f;\n\t\t\t\t\t}\n\t\t\t\t} else if (paths === undefined) {\n\t\t\t\t\t// a. LOAD_AS_FILE(Y + X)\n\t\t\t\t\t// b. LOAD_AS_DIRECTORY(Y + X)\n\t\t\t\t\tf = this.loadAsFileOrDirecotry(this.pathConcat(path, x), extList);\n\t\t\t\t\tif (f) return f;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new VMError('Invalid options.paths option.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// a. LOAD_AS_FILE(Y + X)\n\t\t\t\t// b. LOAD_AS_DIRECTORY(Y + X)\n\t\t\t\tf = this.loadAsFileOrDirecotry(this.pathConcat(path, x), extList);\n\t\t\t\tif (f) return f;\n\t\t\t}\n\n\t\t\t// c. THROW \"not found\"\n\t\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t\t}\n\n\t\tlet dirs;\n\t\tif (typeof options === 'object' && options !== null) {\n\t\t\tconst paths = options.paths;\n\t\t\tif (Array.isArray(paths)) {\n\t\t\t\tdirs = [];\n\n\t\t\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\t\t\tconst lookups = this.genLookupPaths(paths[i]);\n\t\t\t\t\tfor (let j = 0; j < lookups.length; j++) {\n\t\t\t\t\t\tif (!dirs.includes(lookups[j])) dirs.push(lookups[j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tconst globalPaths = this.globalPaths;\n\t\t\t\t\t\tfor (let j = 0; j < globalPaths.length; j++) {\n\t\t\t\t\t\t\tif (!dirs.includes(globalPaths[j])) dirs.push(globalPaths[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (paths === undefined) {\n\t\t\t\tdirs = [...mod.paths, ...this.globalPaths];\n\t\t\t} else {\n\t\t\t\tthrow new VMError('Invalid options.paths option.');\n\t\t\t}\n\t\t} else {\n\t\t\tdirs = [...mod.paths, ...this.globalPaths];\n\t\t}\n\n\t\t// 6. LOAD_NODE_MODULES(X, dirname(Y))\n\t\tf = this.loadNodeModules(x, dirs, extList);\n\t\tif (f) return f;\n\n\t\tf = this.customResolver(this, x, path, extList);\n\t\tif (f) return f;\n\n\t\treturn super.resolveFull(mod, x, options, ext, direct);\n\t}\n\n\tloadAsFileOrDirecotry(x, extList) {\n\t\t// a. LOAD_AS_FILE(X)\n\t\tconst f = this.loadAsFile(x, extList);\n\t\tif (f) return f;\n\t\t// b. LOAD_AS_DIRECTORY(X)\n\t\treturn this.loadAsDirectory(x, extList);\n\t}\n\n\ttryFile(x) {\n\t\tx = this.pathResolve(x);\n\t\treturn this.isPathAllowed(x) && this.pathTestIsFile(x) ? x : undefined;\n\t}\n\n\ttryWithExtension(x, extList) {\n\t\tfor (let i = 0; i < extList.length; i++) {\n\t\t\tconst ext = extList[i];\n\t\t\tif (ext !== this.pathBasename(ext)) continue;\n\t\t\tconst f = this.tryFile(x + ext);\n\t\t\tif (f) return f;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\treadPackage(path) {\n\t\tconst packagePath = this.pathResolve(this.pathConcat(path, 'package.json'));\n\n\t\tconst cache = this.packageCache[packagePath];\n\t\tif (cache !== undefined) return cache;\n\n\t\tif (!this.isPathAllowed(packagePath)) return undefined;\n\t\tconst content = this.readFileWhenExists(packagePath);\n\t\tif (!content) {\n\t\t\tthis.packageCache[packagePath] = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(content);\n\t\t} catch (e) {\n\t\t\te.path = packagePath;\n\t\t\te.message = 'Error parsing ' + packagePath + ': ' + e.message;\n\t\t\tthrow e;\n\t\t}\n\n\t\tconst filtered = {\n\t\t\tname: parsed.name,\n\t\t\tmain: parsed.main,\n\t\t\texports: parsed.exports,\n\t\t\timports: parsed.imports,\n\t\t\ttype: parsed.type\n\t\t};\n\t\tthis.packageCache[packagePath] = filtered;\n\t\treturn filtered;\n\t}\n\n\treadPackageScope(path) {\n\t\twhile (true) {\n\t\t\tconst dir = this.pathDirname(path);\n\t\t\tif (dir === path) break;\n\t\t\tconst basename = this.pathBasename(dir);\n\t\t\tif (basename === 'node_modules') break;\n\t\t\tconst pack = this.readPackage(dir);\n\t\t\tif (pack) return {data: pack, scope: dir};\n\t\t\tpath = dir;\n\t\t}\n\t\treturn {data: undefined, scope: undefined};\n\t}\n\n\t// LOAD_AS_FILE(X)\n\tloadAsFile(x, extList) {\n\t\t// 1. If X is a file, load X as its file extension format. STOP\n\t\tconst f = this.tryFile(x);\n\t\tif (f) return f;\n\t\t// 2. If X.js is a file, load X.js as JavaScript text. STOP\n\t\t// 3. If X.json is a file, parse X.json to a JavaScript Object. STOP\n\t\t// 4. If X.node is a file, load X.node as binary addon. STOP\n\t\treturn this.tryWithExtension(x, extList);\n\t}\n\n\t// LOAD_INDEX(X)\n\tloadIndex(x, extList) {\n\t\t// 1. If X/index.js is a file, load X/index.js as JavaScript text. STOP\n\t\t// 2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP\n\t\t// 3. If X/index.node is a file, load X/index.node as binary addon. STOP\n\t\treturn this.tryWithExtension(this.pathConcat(x, 'index'), extList);\n\t}\n\n\t// LOAD_AS_DIRECTORY(X)\n\tloadAsPackage(x, pack, extList) {\n\t\t// 1. If X/package.json is a file,\n\t\t// already done.\n\t\tif (pack) {\n\t\t\t// a. Parse X/package.json, and look for \"main\" field.\n\t\t\t// b. If \"main\" is a falsy value, GOTO 2.\n\t\t\tif (typeof pack.main === 'string') {\n\t\t\t\t// c. let M = X + (json main field)\n\t\t\t\tconst m = this.pathConcat(x, pack.main);\n\t\t\t\t// d. LOAD_AS_FILE(M)\n\t\t\t\tlet f = this.loadAsFile(m, extList);\n\t\t\t\tif (f) return f;\n\t\t\t\t// e. LOAD_INDEX(M)\n\t\t\t\tf = this.loadIndex(m, extList);\n\t\t\t\tif (f) return f;\n\t\t\t\t// f. LOAD_INDEX(X) DEPRECATED\n\t\t\t\tf = this.loadIndex(x, extList);\n\t\t\t\tif (f) return f;\n\t\t\t\t// g. THROW \"not found\"\n\t\t\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t\t\t}\n\t\t}\n\n\t\t// 2. LOAD_INDEX(X)\n\t\treturn this.loadIndex(x, extList);\n\t}\n\n\t// LOAD_AS_DIRECTORY(X)\n\tloadAsDirectory(x, extList) {\n\t\t// 1. If X/package.json is a file,\n\t\tconst pack = this.readPackage(x);\n\t\treturn this.loadAsPackage(x, pack, extList);\n\t}\n\n\t// LOAD_NODE_MODULES(X, START)\n\tloadNodeModules(x, dirs, extList) {\n\t\t// 1. let DIRS = NODE_MODULES_PATHS(START)\n\t\t// This step is already done.\n\n\t\t// 2. for each DIR in DIRS:\n\t\tfor (let i = 0; i < dirs.length; i++) {\n\t\t\tconst dir = dirs[i];\n\t\t\t// a. LOAD_PACKAGE_EXPORTS(X, DIR)\n\t\t\tlet f = this.loadPackageExports(x, dir, extList);\n\t\t\tif (f) return f;\n\t\t\t// b. LOAD_AS_FILE(DIR/X)\n\t\t\tf = this.loadAsFile(dir + '/' + x, extList);\n\t\t\tif (f) return f;\n\t\t\t// c. LOAD_AS_DIRECTORY(DIR/X)\n\t\t\tf = this.loadAsDirectory(dir + '/' + x, extList);\n\t\t\tif (f) return f;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t// LOAD_PACKAGE_IMPORTS(X, DIR)\n\tloadPackageImports(x, dir, extList) {\n\t\t// 1. Find the closest package scope SCOPE to DIR.\n\t\tconst {data, scope} = this.readPackageScope(dir);\n\t\t// 2. If no scope was found, return.\n\t\tif (!data) return undefined;\n\t\t// 3. If the SCOPE/package.json \"imports\" is null or undefined, return.\n\t\tif (typeof data.imports !== 'object' || data.imports === null || Array.isArray(data.imports)) return undefined;\n\t\t// 4. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE),\n\t\t//   [\"node\", \"require\"]) defined in the ESM resolver.\n\n\t\t// PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)\n\t\t// 1. Assert: specifier begins with \"#\".\n\t\t// 2. If specifier is exactly equal to \"#\" or starts with \"#/\", then\n\t\tif (x === '#' || x.startsWith('#/')) {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid module specifier '${x}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 3. Let packageURL be the result of LOOKUP_PACKAGE_SCOPE(parentURL).\n\t\t// Note: packageURL === parentURL === scope\n\t\t// 4. If packageURL is not null, then\n\t\t// Always true\n\t\t// a. Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n\t\t// pjson === data\n\t\t// b. If pjson.imports is a non-null Object, then\n\t\t// Already tested\n\t\t// x. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( specifier, pjson.imports, packageURL, true, conditions).\n\t\tconst match = this.packageImportsExportsResolve(x, data.imports, scope, true, ['node', 'require'], extList);\n\t\t// y. If resolved is not null or undefined, return resolved.\n\t\tif (!match) {\n\t\t\t// 5. Throw a Package Import Not Defined error.\n\t\t\tthrow new VMError(`Package import not defined for '${x}'`, 'ERR_PACKAGE_IMPORT_NOT_DEFINED');\n\t\t}\n\t\t// END PACKAGE_IMPORTS_RESOLVE\n\n\t\t// 5. RESOLVE_ESM_MATCH(MATCH).\n\t\treturn this.resolveEsmMatch(match, x, extList);\n\t}\n\n\t// LOAD_PACKAGE_EXPORTS(X, DIR)\n\tloadPackageExports(x, dir, extList) {\n\t\t// 1. Try to interpret X as a combination of NAME and SUBPATH where the name\n\t\t//    may have a @scope/ prefix and the subpath begins with a slash (`/`).\n\t\tconst res = x.match(EXPORTS_PATTERN);\n\t\t// 2. If X does not match this pattern or DIR/NAME/package.json is not a file,\n\t\t//    return.\n\t\tif (!res) return undefined;\n\t\tconst scope = this.pathConcat(dir, res[1]);\n\t\tconst pack = this.readPackage(scope);\n\t\tif (!pack) return undefined;\n\t\t// 3. Parse DIR/NAME/package.json, and look for \"exports\" field.\n\t\t// 4. If \"exports\" is null or undefined, return.\n\t\tif (!pack.exports) return undefined;\n\t\t// 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), \".\" + SUBPATH,\n\t\t//    `package.json` \"exports\", [\"node\", \"require\"]) defined in the ESM resolver.\n\t\tconst match = this.packageExportsResolve(scope, '.' + (res[2] || ''), pack.exports, ['node', 'require'], extList);\n\t\t// 6. RESOLVE_ESM_MATCH(MATCH)\n\t\treturn this.resolveEsmMatch(match, x, extList);\n\t}\n\n\t// LOAD_PACKAGE_SELF(X, DIR)\n\tloadPackageSelf(x, dir, extList) {\n\t\t// 1. Find the closest package scope SCOPE to DIR.\n\t\tconst {data, scope} = this.readPackageScope(dir);\n\t\t// 2. If no scope was found, return.\n\t\tif (!data) return undefined;\n\t\t// 3. If the SCOPE/package.json \"exports\" is null or undefined, return.\n\t\tif (!data.exports) return undefined;\n\t\t// 4. If the SCOPE/package.json \"name\" is not the first segment of X, return.\n\t\tif (x !== data.name && !x.startsWith(data.name + '/')) return undefined;\n\t\t// 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE),\n\t\t//    \".\" + X.slice(\"name\".length), `package.json` \"exports\", [\"node\", \"require\"])\n\t\t//    defined in the ESM resolver.\n\t\tconst match = this.packageExportsResolve(scope, '.' + x.slice(data.name.length), data.exports, ['node', 'require'], extList);\n\t\t// 6. RESOLVE_ESM_MATCH(MATCH)\n\t\treturn this.resolveEsmMatch(match, x, extList);\n\t}\n\n\t// RESOLVE_ESM_MATCH(MATCH)\n\tresolveEsmMatch(match, x, extList) {\n\t\t// 1. let { RESOLVED, EXACT } = MATCH\n\t\tconst resolved = match;\n\t\tconst exact = true;\n\t\t// 2. let RESOLVED_PATH = fileURLToPath(RESOLVED)\n\t\tconst resolvedPath = resolved;\n\t\tlet f;\n\t\t// 3. If EXACT is true,\n\t\tif (exact) {\n\t\t\t// a. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension\n\t\t\t// format. STOP\n\t\t\tf = this.tryFile(resolvedPath);\n\t\t// 4. Otherwise, if EXACT is false,\n\t\t} else {\n\t\t\t// a. LOAD_AS_FILE(RESOLVED_PATH)\n\t\t\t// b. LOAD_AS_DIRECTORY(RESOLVED_PATH)\n\t\t\tf = this.loadAsFileOrDirecotry(resolvedPath, extList);\n\t\t}\n\t\tif (f) return f;\n\t\t// 5. THROW \"not found\"\n\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t}\n\n\t// PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)\n\tpackageExportsResolve(packageURL, subpath, rexports, conditions, extList) {\n\t\t// 1. If exports is an Object with both a key starting with \".\" and a key not starting with \".\", throw an Invalid Package Configuration error.\n\t\tlet hasDots = false;\n\t\tif (typeof rexports === 'object' && !Array.isArray(rexports)) {\n\t\t\tconst keys = Object.getOwnPropertyNames(rexports);\n\t\t\tif (keys.length > 0) {\n\t\t\t\thasDots = keys[0][0] === '.';\n\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\tif (hasDots !== (keys[i][0] === '.')) {\n\t\t\t\t\t\tthrow new VMError('Invalid package configuration', 'ERR_INVALID_PACKAGE_CONFIGURATION');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 2. If subpath is equal to \".\", then\n\t\tif (subpath === '.') {\n\t\t\t// a. Let mainExport be undefined.\n\t\t\tlet mainExport = undefined;\n\t\t\t// b. If exports is a String or Array, or an Object containing no keys starting with \".\", then\n\t\t\tif (typeof rexports === 'string' || Array.isArray(rexports) || !hasDots) {\n\t\t\t\t// x. Set mainExport to exports.\n\t\t\t\tmainExport = rexports;\n\t\t\t// c. Otherwise if exports is an Object containing a \".\" property, then\n\t\t\t} else if (hasDots) {\n\t\t\t\t// x. Set mainExport to exports[\".\"].\n\t\t\t\tmainExport = rexports['.'];\n\t\t\t}\n\t\t\t// d. If mainExport is not undefined, then\n\t\t\tif (mainExport) {\n\t\t\t\t// x. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, mainExport, \"\", false, false, conditions).\n\t\t\t\tconst resolved = this.packageTargetResolve(packageURL, mainExport, '', false, false, conditions, extList);\n\t\t\t\t// y. If resolved is not null or undefined, return resolved.\n\t\t\t\tif (resolved) return resolved;\n\t\t\t}\n\t\t// 3. Otherwise, if exports is an Object and all keys of exports start with \".\", then\n\t\t} else if (hasDots) {\n\t\t\t// a. Let matchKey be the string \"./\" concatenated with subpath.\n\t\t\t// Note: Here subpath starts already with './'\n\t\t\t// b. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( matchKey, exports, packageURL, false, conditions).\n\t\t\tconst resolved = this.packageImportsExportsResolve(subpath, rexports, packageURL, false, conditions, extList);\n\t\t\t// c. If resolved is not null or undefined, return resolved.\n\t\t\tif (resolved) return resolved;\n\t\t}\n\t\t// 4. Throw a Package Path Not Exported error.\n\t\tthrow new VMError(`Package path '${subpath}' is not exported`, 'ERR_PACKAGE_PATH_NOT_EXPORTED');\n\t}\n\n\t// PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports, conditions)\n\tpackageImportsExportsResolve(matchKey, matchObj, packageURL, isImports, conditions, extList) {\n\t\t// 1. If matchKey is a key of matchObj and does not contain \"*\", then\n\t\tlet target = matchObj[matchKey];\n\t\tif (target && matchKey.indexOf('*') === -1) {\n\t\t\t// a. Let target be the value of matchObj[matchKey].\n\t\t\t// b. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, \"\", false, isImports, conditions).\n\t\t\treturn this.packageTargetResolve(packageURL, target, '', false, isImports, conditions, extList);\n\t\t}\n\t\t// 2. Let expansionKeys be the list of keys of matchObj containing only a single \"*\",\n\t\t//    sorted by the sorting function PATTERN_KEY_COMPARE which orders in descending order of specificity.\n\t\tconst expansionKeys = Object.getOwnPropertyNames(matchObj);\n\t\tlet bestKey = '';\n\t\tlet bestSubpath;\n\t\t// 3. For each key expansionKey in expansionKeys, do\n\t\tfor (let i = 0; i < expansionKeys.length; i++) {\n\t\t\tconst expansionKey = expansionKeys[i];\n\t\t\tif (matchKey.length < expansionKey.length) continue;\n\t\t\t// a. Let patternBase be the substring of expansionKey up to but excluding the first \"*\" character.\n\t\t\tconst star = expansionKey.indexOf('*');\n\t\t\tif (star === -1) continue; // Note: expansionKeys was not filtered\n\t\t\tconst patternBase = expansionKey.slice(0, star);\n\t\t\t// b. If matchKey starts with but is not equal to patternBase, then\n\t\t\tif (matchKey.startsWith(patternBase) && expansionKey.indexOf('*', star + 1) === -1) { // Note: expansionKeys was not filtered\n\t\t\t\t// 1. Let patternTrailer be the substring of expansionKey from the index after the first \"*\" character.\n\t\t\t\tconst patternTrailer = expansionKey.slice(star + 1);\n\t\t\t\t// 2. If patternTrailer has zero length, or if matchKey ends with patternTrailer and the length of matchKey is greater than or\n\t\t\t\t//    equal to the length of expansionKey, then\n\t\t\t\tif (matchKey.endsWith(patternTrailer) && this.patternKeyCompare(bestKey, expansionKey) === 1) { // Note: expansionKeys was not sorted\n\t\t\t\t\t// a. Let target be the value of matchObj[expansionKey].\n\t\t\t\t\ttarget = matchObj[expansionKey];\n\t\t\t\t\t// b. Let subpath be the substring of matchKey starting at the index of the length of patternBase up to the length of\n\t\t\t\t\t//    matchKey minus the length of patternTrailer.\n\t\t\t\t\tbestKey = expansionKey;\n\t\t\t\t\tbestSubpath = matchKey.slice(patternBase.length, matchKey.length - patternTrailer.length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bestSubpath) { // Note: expansionKeys was not sorted\n\t\t\t// c. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, true, isImports, conditions).\n\t\t\treturn this.packageTargetResolve(packageURL, target, bestSubpath, true, isImports, conditions, extList);\n\t\t}\n\t\t// 4. Return null.\n\t\treturn null;\n\t}\n\n\t// PATTERN_KEY_COMPARE(keyA, keyB)\n\tpatternKeyCompare(keyA, keyB) {\n\t\t// 1. Assert: keyA ends with \"/\" or contains only a single \"*\".\n\t\t// 2. Assert: keyB ends with \"/\" or contains only a single \"*\".\n\t\t// 3. Let baseLengthA be the index of \"*\" in keyA plus one, if keyA contains \"*\", or the length of keyA otherwise.\n\t\tconst baseAStar = keyA.indexOf('*');\n\t\tconst baseLengthA = baseAStar === -1 ? keyA.length : baseAStar + 1;\n\t\t// 4. Let baseLengthB be the index of \"*\" in keyB plus one, if keyB contains \"*\", or the length of keyB otherwise.\n\t\tconst baseBStar = keyB.indexOf('*');\n\t\tconst baseLengthB = baseBStar === -1 ? keyB.length : baseBStar + 1;\n\t\t// 5. If baseLengthA is greater than baseLengthB, return -1.\n\t\tif (baseLengthA > baseLengthB) return -1;\n\t\t// 6. If baseLengthB is greater than baseLengthA, return 1.\n\t\tif (baseLengthB > baseLengthA) return 1;\n\t\t// 7. If keyA does not contain \"*\", return 1.\n\t\tif (baseAStar === -1) return 1;\n\t\t// 8. If keyB does not contain \"*\", return -1.\n\t\tif (baseBStar === -1) return -1;\n\t\t// 9. If the length of keyA is greater than the length of keyB, return -1.\n\t\tif (keyA.length > keyB.length) return -1;\n\t\t// 10. If the length of keyB is greater than the length of keyA, return 1.\n\t\tif (keyB.length > keyA.length) return 1;\n\t\t// 11. Return 0.\n\t\treturn 0;\n\t}\n\n\t// PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, pattern, internal, conditions)\n\tpackageTargetResolve(packageURL, target, subpath, pattern, internal, conditions, extList) {\n\t\t// 1. If target is a String, then\n\t\tif (typeof target === 'string') {\n\t\t\t// a. If pattern is false, subpath has non-zero length and target does not end with \"/\", throw an Invalid Module Specifier error.\n\t\t\tif (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n\t\t\t\tthrow new VMError(`Invalid package specifier '${subpath}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t\t}\n\t\t\t// b. If target does not start with \"./\", then\n\t\t\tif (!target.startsWith('./')) {\n\t\t\t\t// 1. If internal is true and target does not start with \"../\" or \"/\" and is not a valid URL, then\n\t\t\t\tif (internal && !target.startsWith('../') && !target.startsWith('/')) {\n\t\t\t\t\tlet isURL = false;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// eslint-disable-next-line no-new\n\t\t\t\t\t\tnew URL(target);\n\t\t\t\t\t\tisURL = true;\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t\tif (!isURL) {\n\t\t\t\t\t\t// a. If pattern is true, then\n\t\t\t\t\t\tif (pattern) {\n\t\t\t\t\t\t\t// 1. Return PACKAGE_RESOLVE(target with every instance of \"*\" replaced by subpath, packageURL + \"/\").\n\t\t\t\t\t\t\treturn this.packageResolve(target.replace(/\\*/g, subpath), packageURL, conditions, extList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// b. Return PACKAGE_RESOLVE(target + subpath, packageURL + \"/\").\n\t\t\t\t\t\treturn this.packageResolve(this.pathConcat(target, subpath), packageURL, conditions, extList);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise, throw an Invalid Package Target error.\n\t\t\t\tthrow new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n\t\t\t}\n\t\t\ttarget = decodeURI(target);\n\t\t\t// c. If target split on \"/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments after the first segment, case insensitive\n\t\t\t//    and including percent encoded variants, throw an Invalid Package Target error.\n\t\t\tif (target.split(/[/\\\\]/).slice(1).findIndex(x => x === '.' || x === '..' || x.toLowerCase() === 'node_modules') !== -1) {\n\t\t\t\tthrow new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n\t\t\t}\n\t\t\t// d. Let resolvedTarget be the URL resolution of the concatenation of packageURL and target.\n\t\t\tconst resolvedTarget = this.pathConcat(packageURL, target);\n\t\t\t// e. Assert: resolvedTarget is contained in packageURL.\n\t\t\tsubpath = decodeURI(subpath);\n\t\t\t// f. If subpath split on \"/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments, case insensitive and including percent\n\t\t\t//    encoded variants, throw an Invalid Module Specifier error.\n\t\t\tif (subpath.split(/[/\\\\]/).findIndex(x => x === '.' || x === '..' || x.toLowerCase() === 'node_modules') !== -1) {\n\t\t\t\tthrow new VMError(`Invalid package specifier '${subpath}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t\t}\n\t\t\t// g. If pattern is true, then\n\t\t\tif (pattern) {\n\t\t\t\t// 1. Return the URL resolution of resolvedTarget with every instance of \"*\" replaced with subpath.\n\t\t\t\treturn resolvedTarget.replace(/\\*/g, subpath);\n\t\t\t}\n\t\t\t// h. Otherwise,\n\t\t\t// 1. Return the URL resolution of the concatenation of subpath and resolvedTarget.\n\t\t\treturn this.pathConcat(resolvedTarget, subpath);\n\t\t// 3. Otherwise, if target is an Array, then\n\t\t} else if (Array.isArray(target)) {\n\t\t\t// a. If target.length is zero, return null.\n\t\t\tif (target.length === 0) return null;\n\t\t\tlet lastException = undefined;\n\t\t\t// b. For each item targetValue in target, do\n\t\t\tfor (let i = 0; i < target.length; i++) {\n\t\t\t\tconst targetValue = target[i];\n\t\t\t\t// 1. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions),\n\t\t\t\t//    continuing the loop on any Invalid Package Target error.\n\t\t\t\tlet resolved;\n\t\t\t\ttry {\n\t\t\t\t\tresolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e.code !== 'ERR_INVALID_PACKAGE_TARGET') throw e;\n\t\t\t\t\tlastException = e;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// 2. If resolved is undefined, continue the loop.\n\t\t\t\t// 3. Return resolved.\n\t\t\t\tif (resolved !== undefined) return resolved;\n\t\t\t\tif (resolved === null) {\n\t\t\t\t\tlastException = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// c. Return or throw the last fallback resolution null return or error.\n\t\t\tif (lastException === undefined || lastException === null) return lastException;\n\t\t\tthrow lastException;\n\t\t// 2. Otherwise, if target is a non-null Object, then\n\t\t} else if (typeof target === 'object' && target !== null) {\n\t\t\tconst keys = Object.getOwnPropertyNames(target);\n\t\t\t// a. If exports contains any index property keys, as defined in ECMA-262 6.1.7 Array Index, throw an Invalid Package Configuration error.\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst p = keys[i];\n\t\t\t\tif (isArrayIndex(p)) throw new VMError(`Invalid package configuration for '${subpath}'`, 'ERR_INVALID_PACKAGE_CONFIGURATION');\n\t\t\t}\n\t\t\t// b. For each property p of target, in object insertion order as,\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst p = keys[i];\n\t\t\t\t// 1. If p equals \"default\" or conditions contains an entry for p, then\n\t\t\t\tif (p === 'default' || conditions.includes(p)) {\n\t\t\t\t\t// a. Let targetValue be the value of the p property in target.\n\t\t\t\t\tconst targetValue = target[p];\n\t\t\t\t\t// b. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions).\n\t\t\t\t\tconst resolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList);\n\t\t\t\t\t// c. If resolved is equal to undefined, continue the loop.\n\t\t\t\t\t// d. Return resolved.\n\t\t\t\t\tif (resolved !== undefined) return resolved;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// c. Return undefined.\n\t\t\treturn undefined;\n\t\t// 4. Otherwise, if target is null, return null.\n\t\t} else if (target == null) {\n\t\t\treturn null;\n\t\t}\n\t\t// Otherwise throw an Invalid Package Target error.\n\t\tthrow new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n\t}\n\n\t// PACKAGE_RESOLVE(packageSpecifier, parentURL)\n\tpackageResolve(packageSpecifier, parentURL, conditions, extList) {\n\t\t// 1. Let packageName be undefined.\n\t\tlet packageName = undefined;\n\t\t// 2. If packageSpecifier is an empty string, then\n\t\tif (packageSpecifier === '') {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 3. If packageSpecifier is a Node.js builtin module name, then\n\t\tif (this.builtinModules[packageSpecifier]) {\n\t\t\t// a. Return the string \"node:\" concatenated with packageSpecifier.\n\t\t\treturn 'node:' + packageSpecifier;\n\t\t}\n\t\tlet idx = packageSpecifier.indexOf('/');\n\t\t// 5. Otherwise,\n\t\tif (packageSpecifier[0] === '@') {\n\t\t\t// a. If packageSpecifier does not contain a \"/\" separator, then\n\t\t\tif (idx === -1) {\n\t\t\t\t// x. Throw an Invalid Module Specifier error.\n\t\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t\t}\n\t\t\t// b. Set packageName to the substring of packageSpecifier until the second \"/\" separator or the end of the string.\n\t\t\tidx = packageSpecifier.indexOf('/', idx + 1);\n\t\t}\n\t\t// else\n\t\t// 4. If packageSpecifier does not start with \"@\", then\n\t\t// a. Set packageName to the substring of packageSpecifier until the first \"/\" separator or the end of the string.\n\t\tpackageName = idx === -1 ? packageSpecifier : packageSpecifier.slice(0, idx);\n\t\t// 6. If packageName starts with \".\" or contains \"\\\" or \"%\", then\n\t\tif (idx !== 0 && (packageName[0] === '.' || packageName.indexOf('\\\\') >= 0 || packageName.indexOf('%') >= 0)) {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 7. Let packageSubpath be \".\" concatenated with the substring of packageSpecifier from the position at the length of packageName.\n\t\tconst packageSubpath = '.' + packageSpecifier.slice(packageName.length);\n\t\t// 8. If packageSubpath ends in \"/\", then\n\t\tif (packageSubpath[packageSubpath.length - 1] === '/') {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 9. Let selfUrl be the result of PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL).\n\t\tconst selfUrl = this.packageSelfResolve(packageName, packageSubpath, parentURL);\n\t\t// 10. If selfUrl is not undefined, return selfUrl.\n\t\tif (selfUrl) return selfUrl;\n\t\t// 11. While parentURL is not the file system root,\n\t\tlet packageURL;\n\t\twhile (true) {\n\t\t\t// a. Let packageURL be the URL resolution of \"node_modules/\" concatenated with packageSpecifier, relative to parentURL.\n\t\t\tpackageURL = this.pathResolve(this.pathConcat(parentURL, 'node_modules', packageSpecifier));\n\t\t\t// b. Set parentURL to the parent folder URL of parentURL.\n\t\t\tconst parentParentURL = this.pathDirname(parentURL);\n\t\t\t// c. If the folder at packageURL does not exist, then\n\t\t\tif (this.isPathAllowed(packageURL) && this.pathTestIsDirectory(packageURL)) break;\n\t\t\t// 1. Continue the next loop iteration.\n\t\t\tif (parentParentURL === parentURL) {\n\t\t\t\t// 12. Throw a Module Not Found error.\n\t\t\t\tthrow new VMError(`Cannot find module '${packageSpecifier}'`, 'ENOTFOUND');\n\t\t\t}\n\t\t\tparentURL = parentParentURL;\n\t\t}\n\t\t// d. Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n\t\tconst pack = this.readPackage(packageURL);\n\t\t// e. If pjson is not null and pjson.exports is not null or undefined, then\n\t\tif (pack && pack.exports) {\n\t\t\t// 1. Return the result of PACKAGE_EXPORTS_RESOLVE(packageURL, packageSubpath, pjson.exports, defaultConditions).\n\t\t\treturn this.packageExportsResolve(packageURL, packageSubpath, pack.exports, conditions, extList);\n\t\t}\n\t\t// f. Otherwise, if packageSubpath is equal to \".\", then\n\t\tif (packageSubpath === '.') {\n\t\t\t// 1. If pjson.main is a string, then\n\t\t\t// a. Return the URL resolution of main in packageURL.\n\t\t\treturn this.loadAsPackage(packageSubpath, pack, extList);\n\t\t}\n\t\t// g. Otherwise,\n\t\t// 1. Return the URL resolution of packageSubpath in packageURL.\n\t\treturn this.pathConcat(packageURL, packageSubpath);\n\t}\n\n}\n\nexports.Resolver = Resolver;\nexports.DefaultResolver = DefaultResolver;\n"]},"metadata":{},"sourceType":"script"}