{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\nimport firebase from '@firebase/app';\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\n/**\n * @struct\n * @template T\n */\n\nvar NetworkRequest =\n/** @class */\nfunction () {\n  function NetworkRequest(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {\n    this.pendingXhr_ = null;\n    this.backoffId_ = null;\n    this.resolve_ = null;\n    this.reject_ = null;\n    this.canceled_ = false;\n    this.appDelete_ = false;\n    this.url_ = url;\n    this.method_ = method;\n    this.headers_ = headers;\n    this.body_ = body;\n    this.successCodes_ = successCodes.slice();\n    this.additionalRetryCodes_ = additionalRetryCodes.slice();\n    this.callback_ = callback;\n    this.errorCallback_ = errorCallback;\n    this.progressCallback_ = progressCallback;\n    this.timeout_ = timeout;\n    this.pool_ = pool;\n    var self = this;\n    this.promise_ = promiseimpl.make(function (resolve, reject) {\n      self.resolve_ = resolve;\n      self.reject_ = reject;\n      self.start_();\n    });\n  }\n  /**\n   * Actually starts the retry loop.\n   */\n\n\n  NetworkRequest.prototype.start_ = function () {\n    var self = this;\n\n    function doTheRequest(backoffCallback, canceled) {\n      if (canceled) {\n        backoffCallback(false, new RequestEndStatus(false, null, true));\n        return;\n      }\n\n      var xhr = self.pool_.createXhrIo();\n      self.pendingXhr_ = xhr;\n\n      function progressListener(progressEvent) {\n        var loaded = progressEvent.loaded;\n        var total = progressEvent.lengthComputable ? progressEvent.total : -1;\n\n        if (self.progressCallback_ !== null) {\n          self.progressCallback_(loaded, total);\n        }\n      }\n\n      if (self.progressCallback_ !== null) {\n        xhr.addUploadProgressListener(progressListener);\n      }\n\n      xhr.send(self.url_, self.method_, self.body_, self.headers_).then(function (xhr) {\n        if (self.progressCallback_ !== null) {\n          xhr.removeUploadProgressListener(progressListener);\n        }\n\n        self.pendingXhr_ = null;\n        xhr = xhr;\n        var hitServer = xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n        var status = xhr.getStatus();\n\n        if (!hitServer || self.isRetryStatusCode_(status)) {\n          var wasCanceled = xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n          backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));\n          return;\n        }\n\n        var successCode = array.contains(self.successCodes_, status);\n        backoffCallback(true, new RequestEndStatus(successCode, xhr));\n      });\n    }\n    /**\n     * @param requestWentThrough True if the request eventually went\n     *     through, false if it hit the retry limit or was canceled.\n     */\n\n\n    function backoffDone(requestWentThrough, status) {\n      var resolve = self.resolve_;\n      var reject = self.reject_;\n      var xhr = status.xhr;\n\n      if (status.wasSuccessCode) {\n        try {\n          var result = self.callback_(xhr, xhr.getResponseText());\n\n          if (type.isJustDef(result)) {\n            resolve(result);\n          } else {\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n      } else {\n        if (xhr !== null) {\n          var err = errorsExports.unknown();\n          err.setServerResponseProp(xhr.getResponseText());\n\n          if (self.errorCallback_) {\n            reject(self.errorCallback_(xhr, err));\n          } else {\n            reject(err);\n          }\n        } else {\n          if (status.canceled) {\n            var err = self.appDelete_ ? errorsExports.appDeleted() : errorsExports.canceled();\n            reject(err);\n          } else {\n            var err = errorsExports.retryLimitExceeded();\n            reject(err);\n          }\n        }\n      }\n    }\n\n    if (this.canceled_) {\n      backoffDone(false, new RequestEndStatus(false, null, true));\n    } else {\n      this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n    }\n  };\n  /** @inheritDoc */\n\n\n  NetworkRequest.prototype.getPromise = function () {\n    return this.promise_;\n  };\n  /** @inheritDoc */\n\n\n  NetworkRequest.prototype.cancel = function (appDelete) {\n    this.canceled_ = true;\n    this.appDelete_ = appDelete || false;\n\n    if (this.backoffId_ !== null) {\n      backoff.stop(this.backoffId_);\n    }\n\n    if (this.pendingXhr_ !== null) {\n      this.pendingXhr_.abort();\n    }\n  };\n\n  NetworkRequest.prototype.isRetryStatusCode_ = function (status) {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    var isFiveHundredCode = status >= 500 && status < 600;\n    var extraRetryCodes = [// Request Timeout: web server didn't receive full request in time.\n    408, // Too Many Requests: you're getting rate-limited, basically.\n    429];\n    var isExtraRetryCode = array.contains(extraRetryCodes, status);\n    var isRequestSpecificRetryCode = array.contains(this.additionalRetryCodes_, status);\n    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n  };\n\n  return NetworkRequest;\n}();\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\n\n\nvar RequestEndStatus =\n/** @class */\nfunction () {\n  function RequestEndStatus(wasSuccessCode, xhr, opt_canceled) {\n    this.wasSuccessCode = wasSuccessCode;\n    this.xhr = xhr;\n    this.canceled = !!opt_canceled;\n  }\n\n  return RequestEndStatus;\n}();\n\nexport { RequestEndStatus };\nexport function addAuthHeader_(headers, authToken) {\n  if (authToken !== null && authToken.length > 0) {\n    headers['Authorization'] = 'Firebase ' + authToken;\n  }\n}\nexport function addVersionHeader_(headers) {\n  var number = typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n  headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n/**\n * @template T\n */\n\nexport function makeRequest(requestInfo, authToken, pool) {\n  var queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n  var url = requestInfo.url + queryPart;\n  var headers = object.clone(requestInfo.headers);\n  addAuthHeader_(headers, authToken);\n  addVersionHeader_(headers);\n  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);\n}","map":{"version":3,"mappings":"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","names":["firebase","array","backoff","errorsExports","object","promiseimpl","type","UrlUtils","XhrIoExports","url","method","headers","body","successCodes","additionalRetryCodes","callback","errorCallback","timeout","progressCallback","pool","url_","method_","headers_","body_","successCodes_","slice","additionalRetryCodes_","callback_","errorCallback_","progressCallback_","timeout_","pool_","self","promise_","make","resolve","reject","resolve_","reject_","start_","NetworkRequest","backoffCallback","canceled","RequestEndStatus","xhr","createXhrIo","pendingXhr_","progressEvent","loaded","total","lengthComputable","addUploadProgressListener","progressListener","send","then","removeUploadProgressListener","hitServer","getErrorCode","ErrorCode","NO_ERROR","status","getStatus","isRetryStatusCode_","wasCanceled","ABORT","successCode","contains","requestWentThrough","wasSuccessCode","result","getResponseText","isJustDef","e","err","unknown","setServerResponseProp","appDelete_","appDeleted","retryLimitExceeded","canceled_","backoffDone","backoffId_","start","doTheRequest","appDelete","stop","abort","isFiveHundredCode","extraRetryCodes","isExtraRetryCode","isRequestSpecificRetryCode","opt_canceled","authToken","length","number","SDK_VERSION","requestInfo","queryPart","makeQueryString","urlParams","clone","addAuthHeader_","addVersionHeader_","handler","errorHandler"],"sources":["../src/implementation/request.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\n\nimport firebase, { FirebaseNamespace } from '@firebase/app';\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport { FirebaseStorageError } from './error';\nimport { errors } from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\nimport { Headers, XhrIo } from './xhrio';\nimport { XhrIoPool } from './xhriopool';\n\n/**\n * @template T\n */\nexport interface Request<T> {\n  getPromise(): Promise<T>;\n\n  /**\n   * Cancels the request. IMPORTANT: the promise may still be resolved with an\n   * appropriate value (if the request is finished before you call this method,\n   * but the promise has not yet been resolved), so don't just assume it will be\n   * rejected if you call this function.\n   * @param appDelete True if the cancelation came from the app being deleted.\n   */\n  cancel(appDelete?: boolean): void;\n}\n\n/**\n * @struct\n * @template T\n */\nclass NetworkRequest<T> implements Request<T> {\n  private url_: string;\n  private method_: string;\n  private headers_: Headers;\n  private body_: string | Blob | Uint8Array | null;\n  private successCodes_: number[];\n  private additionalRetryCodes_: number[];\n  private pendingXhr_: XhrIo | null = null;\n  private backoffId_: backoff.id | null = null;\n  private resolve_: Function | null = null;\n  private reject_: Function | null = null;\n  private canceled_: boolean = false;\n  private appDelete_: boolean = false;\n  private callback_: (p1: XhrIo, p2: string) => T;\n  private errorCallback_:\n    | ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError)\n    | null;\n  private progressCallback_: ((p1: number, p2: number) => void) | null;\n  private timeout_: number;\n  private pool_: XhrIoPool;\n  promise_: Promise<T>;\n\n  constructor(\n    url: string,\n    method: string,\n    headers: Headers,\n    body: string | Blob | Uint8Array | null,\n    successCodes: number[],\n    additionalRetryCodes: number[],\n    callback: (p1: XhrIo, p2: string) => T,\n    errorCallback:\n      | ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError)\n      | null,\n    timeout: number,\n    progressCallback: ((p1: number, p2: number) => void) | null,\n    pool: XhrIoPool\n  ) {\n    this.url_ = url;\n    this.method_ = method;\n    this.headers_ = headers;\n    this.body_ = body;\n    this.successCodes_ = successCodes.slice();\n    this.additionalRetryCodes_ = additionalRetryCodes.slice();\n    this.callback_ = callback;\n    this.errorCallback_ = errorCallback;\n    this.progressCallback_ = progressCallback;\n    this.timeout_ = timeout;\n    this.pool_ = pool;\n    let self = this;\n    this.promise_ = promiseimpl.make(function(resolve, reject) {\n      self.resolve_ = resolve;\n      self.reject_ = reject;\n      self.start_();\n    });\n  }\n\n  /**\n   * Actually starts the retry loop.\n   */\n  private start_() {\n    let self = this;\n\n    function doTheRequest(\n      backoffCallback: (p1: boolean, ...p2: any[]) => void,\n      canceled: boolean\n    ) {\n      if (canceled) {\n        backoffCallback(false, new RequestEndStatus(false, null, true));\n        return;\n      }\n      let xhr = self.pool_.createXhrIo();\n      self.pendingXhr_ = xhr;\n\n      function progressListener(progressEvent: ProgressEvent) {\n        let loaded = progressEvent.loaded;\n        let total = progressEvent.lengthComputable ? progressEvent.total : -1;\n        if (self.progressCallback_ !== null) {\n          self.progressCallback_(loaded, total);\n        }\n      }\n      if (self.progressCallback_ !== null) {\n        xhr.addUploadProgressListener(progressListener);\n      }\n      xhr\n        .send(self.url_, self.method_, self.body_, self.headers_)\n        .then(function(xhr: XhrIo) {\n          if (self.progressCallback_ !== null) {\n            xhr.removeUploadProgressListener(progressListener);\n          }\n          self.pendingXhr_ = null;\n          xhr = xhr as XhrIo;\n          let hitServer =\n            xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n          let status = xhr.getStatus();\n          if (!hitServer || self.isRetryStatusCode_(status)) {\n            let wasCanceled =\n              xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n            backoffCallback(\n              false,\n              new RequestEndStatus(false, null, wasCanceled)\n            );\n            return;\n          }\n          let successCode = array.contains(self.successCodes_, status);\n          backoffCallback(true, new RequestEndStatus(successCode, xhr));\n        });\n    }\n\n    /**\n     * @param requestWentThrough True if the request eventually went\n     *     through, false if it hit the retry limit or was canceled.\n     */\n    function backoffDone(\n      requestWentThrough: boolean,\n      status: RequestEndStatus\n    ) {\n      let resolve = self.resolve_ as Function;\n      let reject = self.reject_ as Function;\n      let xhr = status.xhr as XhrIo;\n      if (status.wasSuccessCode) {\n        try {\n          let result = self.callback_(xhr, xhr.getResponseText());\n          if (type.isJustDef(result)) {\n            resolve(result);\n          } else {\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n      } else {\n        if (xhr !== null) {\n          let err = errorsExports.unknown();\n          err.setServerResponseProp(xhr.getResponseText());\n          if (self.errorCallback_) {\n            reject(self.errorCallback_(xhr, err));\n          } else {\n            reject(err);\n          }\n        } else {\n          if (status.canceled) {\n            let err = self.appDelete_\n              ? errorsExports.appDeleted()\n              : errorsExports.canceled();\n            reject(err);\n          } else {\n            let err = errorsExports.retryLimitExceeded();\n            reject(err);\n          }\n        }\n      }\n    }\n    if (this.canceled_) {\n      backoffDone(false, new RequestEndStatus(false, null, true));\n    } else {\n      this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n    }\n  }\n\n  /** @inheritDoc */\n  getPromise() {\n    return this.promise_;\n  }\n\n  /** @inheritDoc */\n  cancel(appDelete?: boolean) {\n    this.canceled_ = true;\n    this.appDelete_ = appDelete || false;\n    if (this.backoffId_ !== null) {\n      backoff.stop(this.backoffId_);\n    }\n    if (this.pendingXhr_ !== null) {\n      this.pendingXhr_.abort();\n    }\n  }\n\n  private isRetryStatusCode_(status: number): boolean {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    let isFiveHundredCode = status >= 500 && status < 600;\n    let extraRetryCodes = [\n      // Request Timeout: web server didn't receive full request in time.\n      408,\n      // Too Many Requests: you're getting rate-limited, basically.\n      429\n    ];\n    let isExtraRetryCode = array.contains(extraRetryCodes, status);\n    let isRequestSpecificRetryCode = array.contains(\n      this.additionalRetryCodes_,\n      status\n    );\n    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n  }\n}\n\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\nexport class RequestEndStatus {\n  /**\n   * True if the request was canceled.\n   */\n  canceled: boolean;\n\n  constructor(\n    public wasSuccessCode: boolean,\n    public xhr: XhrIo | null,\n    opt_canceled?: boolean\n  ) {\n    this.canceled = !!opt_canceled;\n  }\n}\n\nexport function addAuthHeader_(headers: Headers, authToken: string | null) {\n  if (authToken !== null && authToken.length > 0) {\n    headers['Authorization'] = 'Firebase ' + authToken;\n  }\n}\n\nexport function addVersionHeader_(headers: Headers) {\n  let number =\n    typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n  headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n\n/**\n * @template T\n */\nexport function makeRequest<T>(\n  requestInfo: RequestInfo<T>,\n  authToken: string | null,\n  pool: XhrIoPool\n): Request<T> {\n  let queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n  let url = requestInfo.url + queryPart;\n  let headers = object.clone<Headers>(requestInfo.headers);\n  addAuthHeader_(headers, authToken);\n  addVersionHeader_(headers);\n  return new NetworkRequest<T>(\n    url,\n    requestInfo.method,\n    headers,\n    requestInfo.body,\n    requestInfo.successCodes,\n    requestInfo.additionalRetryCodes,\n    requestInfo.handler,\n    requestInfo.errorHandler,\n    requestInfo.timeout,\n    requestInfo.progressCallback,\n    pool\n  );\n}\n"]},"metadata":{},"sourceType":"module"}