{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Path_1 = require(\"../util/Path\");\n\nvar Operation_1 = require(\"./Operation\");\n\nvar AckUserWrite =\n/** @class */\nfunction () {\n  /**\n   *\n   * @param {!Path} path\n   * @param {!ImmutableTree<!boolean>} affectedTree A tree containing true for each affected path. Affected paths can't overlap.\n   * @param {!boolean} revert\n   */\n  function AckUserWrite(\n  /**@inheritDoc */\n  path,\n  /**@inheritDoc */\n  affectedTree,\n  /**@inheritDoc */\n  revert) {\n    this.path = path;\n    this.affectedTree = affectedTree;\n    this.revert = revert;\n    /** @inheritDoc */\n\n    this.type = Operation_1.OperationType.ACK_USER_WRITE;\n    /** @inheritDoc */\n\n    this.source = Operation_1.OperationSource.User;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  AckUserWrite.prototype.operationForChild = function (childName) {\n    if (!this.path.isEmpty()) {\n      util_1.assert(this.path.getFront() === childName, 'operationForChild called for unrelated child.');\n      return new AckUserWrite(this.path.popFront(), this.affectedTree, this.revert);\n    } else if (this.affectedTree.value != null) {\n      util_1.assert(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.'); // All child locations are affected as well; just return same operation.\n\n      return this;\n    } else {\n      var childTree = this.affectedTree.subtree(new Path_1.Path(childName));\n      return new AckUserWrite(Path_1.Path.Empty, childTree, this.revert);\n    }\n  };\n\n  return AckUserWrite;\n}();\n\nexports.AckUserWrite = AckUserWrite;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA;;AACA;;AACA;;AAGA;AAAA;AAAA;AAOE;;;;;;AAMA;AACE;AAAyBA,MAD3B;AAEE;AAAyBC,cAF3B;AAGE;AAAyBC,QAH3B,EAG0C;AAFf;AACA;AACA;AAf3B;;AACA,gBAAOC,0BAAcC,cAArB;AAEA;;AACA,kBAASD,4BAAgBE,IAAzB;AAYI;AAEJ;;;;;AAGAC,uDAAkBC,SAAlB,EAAmC;AACjC,QAAI,CAAC,KAAKP,IAAL,CAAUQ,OAAV,EAAL,EAA0B;AACxBC,oBACE,KAAKT,IAAL,CAAUU,QAAV,OAAyBH,SAD3B,EAEE,+CAFF;AAIA,aAAO,IAAID,YAAJ,CACL,KAAKN,IAAL,CAAUW,QAAV,EADK,EAEL,KAAKV,YAFA,EAGL,KAAKC,MAHA,CAAP;AAKD,KAVD,MAUO,IAAI,KAAKD,YAAL,CAAkBW,KAAlB,IAA2B,IAA/B,EAAqC;AAC1CH,oBACE,KAAKR,YAAL,CAAkBY,QAAlB,CAA2BL,OAA3B,EADF,EAEE,0DAFF,EAD0C,CAK1C;;AACA,aAAO,IAAP;AACD,KAPM,MAOA;AACL,UAAMM,SAAS,GAAG,KAAKb,YAAL,CAAkBc,OAAlB,CAA0B,IAAIC,WAAJ,CAAST,SAAT,CAA1B,CAAlB;AACA,aAAO,IAAID,YAAJ,CAAiBU,YAAKC,KAAtB,EAA6BH,SAA7B,EAAwC,KAAKZ,MAA7C,CAAP;AACD;AACF,GAtBD;;AAuBF;AA7CA;;AAAagB","names":["path","affectedTree","revert","Operation_1","ACK_USER_WRITE","User","AckUserWrite","childName","isEmpty","util_1","getFront","popFront","value","children","childTree","subtree","Path_1","Empty","exports"],"sources":["../src/core/operation/AckUserWrite.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Path } from '../util/Path';\nimport { Operation, OperationSource, OperationType } from './Operation';\nimport { ImmutableTree } from '../util/ImmutableTree';\n\nexport class AckUserWrite implements Operation {\n  /** @inheritDoc */\n  type = OperationType.ACK_USER_WRITE;\n\n  /** @inheritDoc */\n  source = OperationSource.User;\n\n  /**\n   *\n   * @param {!Path} path\n   * @param {!ImmutableTree<!boolean>} affectedTree A tree containing true for each affected path. Affected paths can't overlap.\n   * @param {!boolean} revert\n   */\n  constructor(\n    /**@inheritDoc */ public path: Path,\n    /**@inheritDoc */ public affectedTree: ImmutableTree<boolean>,\n    /**@inheritDoc */ public revert: boolean\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  operationForChild(childName: string): AckUserWrite {\n    if (!this.path.isEmpty()) {\n      assert(\n        this.path.getFront() === childName,\n        'operationForChild called for unrelated child.'\n      );\n      return new AckUserWrite(\n        this.path.popFront(),\n        this.affectedTree,\n        this.revert\n      );\n    } else if (this.affectedTree.value != null) {\n      assert(\n        this.affectedTree.children.isEmpty(),\n        'affectedTree should not have overlapping affected paths.'\n      );\n      // All child locations are affected as well; just return same operation.\n      return this;\n    } else {\n      const childTree = this.affectedTree.subtree(new Path(childName));\n      return new AckUserWrite(Path.Empty, childTree, this.revert);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}