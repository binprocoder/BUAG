{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Change_1 = require(\"../Change\");\n\nvar ChildrenNode_1 = require(\"../../snap/ChildrenNode\");\n\nvar PriorityIndex_1 = require(\"../../snap/indexes/PriorityIndex\");\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\n\n\nvar IndexedFilter =\n/** @class */\nfunction () {\n  function IndexedFilter(index_) {\n    this.index_ = index_;\n  }\n\n  IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n    util_1.assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');\n    var oldChild = snap.getImmediateChild(key); // Check if anything actually changed.\n\n    if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\n      // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n      // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n      // to avoid treating these cases as \"nothing changed.\"\n      if (oldChild.isEmpty() == newChild.isEmpty()) {\n        // Nothing changed.\n        // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n        //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n        return snap;\n      }\n    }\n\n    if (optChangeAccumulator != null) {\n      if (newChild.isEmpty()) {\n        if (snap.hasChild(key)) {\n          optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, oldChild));\n        } else {\n          util_1.assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');\n        }\n      } else if (oldChild.isEmpty()) {\n        optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, newChild));\n      } else {\n        optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, newChild, oldChild));\n      }\n    }\n\n    if (snap.isLeafNode() && newChild.isEmpty()) {\n      return snap;\n    } else {\n      // Make sure the node is indexed\n      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n    if (optChangeAccumulator != null) {\n      if (!oldSnap.isLeafNode()) {\n        oldSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n          if (!newSnap.hasChild(key)) {\n            optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, childNode));\n          }\n        });\n      }\n\n      if (!newSnap.isLeafNode()) {\n        newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n          if (oldSnap.hasChild(key)) {\n            var oldChild = oldSnap.getImmediateChild(key);\n\n            if (!oldChild.equals(childNode)) {\n              optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, childNode, oldChild));\n            }\n          } else {\n            optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, childNode));\n          }\n        });\n      }\n    }\n\n    return newSnap.withIndex(this.index_);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n    if (oldSnap.isEmpty()) {\n      return ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    } else {\n      return oldSnap.updatePriority(newPriority);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IndexedFilter.prototype.filtersNodes = function () {\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IndexedFilter.prototype.getIndexedFilter = function () {\n    return this;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IndexedFilter.prototype.getIndex = function () {\n    return this.index_;\n  };\n\n  return IndexedFilter;\n}();\n\nexports.IndexedFilter = IndexedFilter;","map":{"version":3,"mappings":"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","names":["index_","IndexedFilter","snap","key","newChild","affectedPath","source","optChangeAccumulator","util_1","isIndexed","oldChild","getImmediateChild","getChild","equals","isEmpty","hasChild","trackChildChange","Change_1","childRemovedChange","isLeafNode","childAddedChange","childChangedChange","updateImmediateChild","withIndex","oldSnap","newSnap","forEachChild","PriorityIndex_1","childNode","newPriority","ChildrenNode_1","EMPTY_NODE","updatePriority","exports"],"sources":["../src/core/view/filter/IndexedFilter.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Change } from '../Change';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\nimport { Node } from '../../snap/Node';\n\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\nexport class IndexedFilter implements NodeFilter {\n  constructor(private readonly index_: Index) {}\n\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    assert(\n      snap.isIndexed(this.index_),\n      'A node must be indexed if only a child is updated'\n    );\n    const oldChild = snap.getImmediateChild(key);\n    // Check if anything actually changed.\n    if (\n      oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))\n    ) {\n      // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n      // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n      // to avoid treating these cases as \"nothing changed.\"\n      if (oldChild.isEmpty() == newChild.isEmpty()) {\n        // Nothing changed.\n\n        // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n        //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n        return snap;\n      }\n    }\n\n    if (optChangeAccumulator != null) {\n      if (newChild.isEmpty()) {\n        if (snap.hasChild(key)) {\n          optChangeAccumulator.trackChildChange(\n            Change.childRemovedChange(key, oldChild)\n          );\n        } else {\n          assert(\n            snap.isLeafNode(),\n            'A child remove without an old child only makes sense on a leaf node'\n          );\n        }\n      } else if (oldChild.isEmpty()) {\n        optChangeAccumulator.trackChildChange(\n          Change.childAddedChange(key, newChild)\n        );\n      } else {\n        optChangeAccumulator.trackChildChange(\n          Change.childChangedChange(key, newChild, oldChild)\n        );\n      }\n    }\n    if (snap.isLeafNode() && newChild.isEmpty()) {\n      return snap;\n    } else {\n      // Make sure the node is indexed\n      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (optChangeAccumulator != null) {\n      if (!oldSnap.isLeafNode()) {\n        oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (!newSnap.hasChild(key)) {\n            optChangeAccumulator.trackChildChange(\n              Change.childRemovedChange(key, childNode)\n            );\n          }\n        });\n      }\n      if (!newSnap.isLeafNode()) {\n        newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (oldSnap.hasChild(key)) {\n            const oldChild = oldSnap.getImmediateChild(key);\n            if (!oldChild.equals(childNode)) {\n              optChangeAccumulator.trackChildChange(\n                Change.childChangedChange(key, childNode, oldChild)\n              );\n            }\n          } else {\n            optChangeAccumulator.trackChildChange(\n              Change.childAddedChange(key, childNode)\n            );\n          }\n        });\n      }\n    }\n    return newSnap.withIndex(this.index_);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    if (oldSnap.isEmpty()) {\n      return ChildrenNode.EMPTY_NODE;\n    } else {\n      return oldSnap.updatePriority(newPriority);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}