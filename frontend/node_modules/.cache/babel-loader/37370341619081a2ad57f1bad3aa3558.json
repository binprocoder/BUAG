{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar SortedMap_1 = require(\"./SortedMap\");\n\nvar Path_1 = require(\"./Path\");\n\nvar util_1 = require(\"./util\");\n\nvar util_2 = require(\"@firebase/util\");\n\nvar emptyChildrenSingleton;\n/**\n * Singleton empty children collection.\n *\n * @const\n * @type {!SortedMap.<string, !ImmutableTree.<?>>}\n */\n\nvar EmptyChildren = function () {\n  if (!emptyChildrenSingleton) {\n    emptyChildrenSingleton = new SortedMap_1.SortedMap(util_1.stringCompare);\n  }\n\n  return emptyChildrenSingleton;\n};\n/**\n * A tree with immutable elements.\n */\n\n\nvar ImmutableTree =\n/** @class */\nfunction () {\n  /**\n   * @template T\n   * @param {?T} value\n   * @param {SortedMap.<string, !ImmutableTree.<T>>=} children\n   */\n  function ImmutableTree(value, children) {\n    if (children === void 0) {\n      children = EmptyChildren();\n    }\n\n    this.value = value;\n    this.children = children;\n  }\n  /**\n   * @template T\n   * @param {!Object.<string, !T>} obj\n   * @return {!ImmutableTree.<!T>}\n   */\n\n\n  ImmutableTree.fromObject = function (obj) {\n    var tree = ImmutableTree.Empty;\n    util_2.forEach(obj, function (childPath, childSnap) {\n      tree = tree.set(new Path_1.Path(childPath), childSnap);\n    });\n    return tree;\n  };\n  /**\n   * True if the value is empty and there are no children\n   * @return {boolean}\n   */\n\n\n  ImmutableTree.prototype.isEmpty = function () {\n    return this.value === null && this.children.isEmpty();\n  };\n  /**\n   * Given a path and predicate, return the first node and the path to that node\n   * where the predicate returns true.\n   *\n   * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects\n   * on the way back out, it may be better to pass down a pathSoFar obj.\n   *\n   * @param {!Path} relativePath The remainder of the path\n   * @param {function(T):boolean} predicate The predicate to satisfy to return a\n   *   node\n   * @return {?{path:!Path, value:!T}}\n   */\n\n\n  ImmutableTree.prototype.findRootMostMatchingPathAndValue = function (relativePath, predicate) {\n    if (this.value != null && predicate(this.value)) {\n      return {\n        path: Path_1.Path.Empty,\n        value: this.value\n      };\n    } else {\n      if (relativePath.isEmpty()) {\n        return null;\n      } else {\n        var front = relativePath.getFront();\n        var child = this.children.get(front);\n\n        if (child !== null) {\n          var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(relativePath.popFront(), predicate);\n\n          if (childExistingPathAndValue != null) {\n            var fullPath = new Path_1.Path(front).child(childExistingPathAndValue.path);\n            return {\n              path: fullPath,\n              value: childExistingPathAndValue.value\n            };\n          } else {\n            return null;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n  };\n  /**\n   * Find, if it exists, the shortest subpath of the given path that points a defined\n   * value in the tree\n   * @param {!Path} relativePath\n   * @return {?{path: !Path, value: !T}}\n   */\n\n\n  ImmutableTree.prototype.findRootMostValueAndPath = function (relativePath) {\n    return this.findRootMostMatchingPathAndValue(relativePath, function () {\n      return true;\n    });\n  };\n  /**\n   * @param {!Path} relativePath\n   * @return {!ImmutableTree.<T>} The subtree at the given path\n   */\n\n\n  ImmutableTree.prototype.subtree = function (relativePath) {\n    if (relativePath.isEmpty()) {\n      return this;\n    } else {\n      var front = relativePath.getFront();\n      var childTree = this.children.get(front);\n\n      if (childTree !== null) {\n        return childTree.subtree(relativePath.popFront());\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  };\n  /**\n   * Sets a value at the specified path.\n   *\n   * @param {!Path} relativePath Path to set value at.\n   * @param {?T} toSet Value to set.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n\n\n  ImmutableTree.prototype.set = function (relativePath, toSet) {\n    if (relativePath.isEmpty()) {\n      return new ImmutableTree(toSet, this.children);\n    } else {\n      var front = relativePath.getFront();\n      var child = this.children.get(front) || ImmutableTree.Empty;\n      var newChild = child.set(relativePath.popFront(), toSet);\n      var newChildren = this.children.insert(front, newChild);\n      return new ImmutableTree(this.value, newChildren);\n    }\n  };\n  /**\n   * Removes the value at the specified path.\n   *\n   * @param {!Path} relativePath Path to value to remove.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n\n\n  ImmutableTree.prototype.remove = function (relativePath) {\n    if (relativePath.isEmpty()) {\n      if (this.children.isEmpty()) {\n        return ImmutableTree.Empty;\n      } else {\n        return new ImmutableTree(null, this.children);\n      }\n    } else {\n      var front = relativePath.getFront();\n      var child = this.children.get(front);\n\n      if (child) {\n        var newChild = child.remove(relativePath.popFront());\n        var newChildren = void 0;\n\n        if (newChild.isEmpty()) {\n          newChildren = this.children.remove(front);\n        } else {\n          newChildren = this.children.insert(front, newChild);\n        }\n\n        if (this.value === null && newChildren.isEmpty()) {\n          return ImmutableTree.Empty;\n        } else {\n          return new ImmutableTree(this.value, newChildren);\n        }\n      } else {\n        return this;\n      }\n    }\n  };\n  /**\n   * Gets a value from the tree.\n   *\n   * @param {!Path} relativePath Path to get value for.\n   * @return {?T} Value at path, or null.\n   */\n\n\n  ImmutableTree.prototype.get = function (relativePath) {\n    if (relativePath.isEmpty()) {\n      return this.value;\n    } else {\n      var front = relativePath.getFront();\n      var child = this.children.get(front);\n\n      if (child) {\n        return child.get(relativePath.popFront());\n      } else {\n        return null;\n      }\n    }\n  };\n  /**\n   * Replace the subtree at the specified path with the given new tree.\n   *\n   * @param {!Path} relativePath Path to replace subtree for.\n   * @param {!ImmutableTree} newTree New tree.\n   * @return {!ImmutableTree} Resulting tree.\n   */\n\n\n  ImmutableTree.prototype.setTree = function (relativePath, newTree) {\n    if (relativePath.isEmpty()) {\n      return newTree;\n    } else {\n      var front = relativePath.getFront();\n      var child = this.children.get(front) || ImmutableTree.Empty;\n      var newChild = child.setTree(relativePath.popFront(), newTree);\n      var newChildren = void 0;\n\n      if (newChild.isEmpty()) {\n        newChildren = this.children.remove(front);\n      } else {\n        newChildren = this.children.insert(front, newChild);\n      }\n\n      return new ImmutableTree(this.value, newChildren);\n    }\n  };\n  /**\n   * Performs a depth first fold on this tree. Transforms a tree into a single\n   * value, given a function that operates on the path to a node, an optional\n   * current value, and a map of child names to folded subtrees\n   * @template V\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   */\n\n\n  ImmutableTree.prototype.fold = function (fn) {\n    return this.fold_(Path_1.Path.Empty, fn);\n  };\n  /**\n   * Recursive helper for public-facing fold() method\n   * @template V\n   * @param {!Path} pathSoFar\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   * @private\n   */\n\n\n  ImmutableTree.prototype.fold_ = function (pathSoFar, fn) {\n    var accum = {};\n    this.children.inorderTraversal(function (childKey, childTree) {\n      accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);\n    });\n    return fn(pathSoFar, this.value, accum);\n  };\n  /**\n   * Find the first matching value on the given path. Return the result of applying f to it.\n   * @template V\n   * @param {!Path} path\n   * @param {!function(!Path, !T):?V} f\n   * @return {?V}\n   */\n\n\n  ImmutableTree.prototype.findOnPath = function (path, f) {\n    return this.findOnPath_(path, Path_1.Path.Empty, f);\n  };\n\n  ImmutableTree.prototype.findOnPath_ = function (pathToFollow, pathSoFar, f) {\n    var result = this.value ? f(pathSoFar, this.value) : false;\n\n    if (result) {\n      return result;\n    } else {\n      if (pathToFollow.isEmpty()) {\n        return null;\n      } else {\n        var front = pathToFollow.getFront();\n        var nextChild = this.children.get(front);\n\n        if (nextChild) {\n          return nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f);\n        } else {\n          return null;\n        }\n      }\n    }\n  };\n  /**\n   *\n   * @param {!Path} path\n   * @param {!function(!Path, !T)} f\n   * @returns {!ImmutableTree.<T>}\n   */\n\n\n  ImmutableTree.prototype.foreachOnPath = function (path, f) {\n    return this.foreachOnPath_(path, Path_1.Path.Empty, f);\n  };\n\n  ImmutableTree.prototype.foreachOnPath_ = function (pathToFollow, currentRelativePath, f) {\n    if (pathToFollow.isEmpty()) {\n      return this;\n    } else {\n      if (this.value) {\n        f(currentRelativePath, this.value);\n      }\n\n      var front = pathToFollow.getFront();\n      var nextChild = this.children.get(front);\n\n      if (nextChild) {\n        return nextChild.foreachOnPath_(pathToFollow.popFront(), currentRelativePath.child(front), f);\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  };\n  /**\n   * Calls the given function for each node in the tree that has a value.\n   *\n   * @param {function(!Path, !T)} f A function to be called with\n   *   the path from the root of the tree to a node, and the value at that node.\n   *   Called in depth-first order.\n   */\n\n\n  ImmutableTree.prototype.foreach = function (f) {\n    this.foreach_(Path_1.Path.Empty, f);\n  };\n\n  ImmutableTree.prototype.foreach_ = function (currentRelativePath, f) {\n    this.children.inorderTraversal(function (childName, childTree) {\n      childTree.foreach_(currentRelativePath.child(childName), f);\n    });\n\n    if (this.value) {\n      f(currentRelativePath, this.value);\n    }\n  };\n  /**\n   *\n   * @param {function(string, !T)} f\n   */\n\n\n  ImmutableTree.prototype.foreachChild = function (f) {\n    this.children.inorderTraversal(function (childName, childTree) {\n      if (childTree.value) {\n        f(childName, childTree.value);\n      }\n    });\n  };\n\n  ImmutableTree.Empty = new ImmutableTree(null);\n  return ImmutableTree;\n}();\n\nexports.ImmutableTree = ImmutableTree;","map":{"version":3,"mappings":"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","names":["emptyChildrenSingleton","EmptyChildren","SortedMap_1","util_1","value","children","ImmutableTree","obj","tree","Empty","util_2","childPath","childSnap","set","Path_1","isEmpty","relativePath","predicate","path","front","getFront","child","get","childExistingPathAndValue","findRootMostMatchingPathAndValue","popFront","fullPath","childTree","subtree","toSet","newChild","newChildren","insert","remove","newTree","setTree","fn","fold_","pathSoFar","accum","inorderTraversal","childKey","f","findOnPath_","pathToFollow","result","nextChild","foreachOnPath_","currentRelativePath","foreach_","childName","exports"],"sources":["../src/core/util/ImmutableTree.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SortedMap } from './SortedMap';\nimport { Path } from './Path';\nimport { stringCompare } from './util';\nimport { forEach } from '@firebase/util';\n\nlet emptyChildrenSingleton: SortedMap<string, ImmutableTree<null>>;\n\n/**\n * Singleton empty children collection.\n *\n * @const\n * @type {!SortedMap.<string, !ImmutableTree.<?>>}\n */\nconst EmptyChildren = (): SortedMap<string, ImmutableTree<null>> => {\n  if (!emptyChildrenSingleton) {\n    emptyChildrenSingleton = new SortedMap<string, ImmutableTree<null>>(\n      stringCompare\n    );\n  }\n  return emptyChildrenSingleton;\n};\n\n/**\n * A tree with immutable elements.\n */\nexport class ImmutableTree<T> {\n  static Empty = new ImmutableTree<any>(null);\n\n  /**\n   * @template T\n   * @param {!Object.<string, !T>} obj\n   * @return {!ImmutableTree.<!T>}\n   */\n  static fromObject<T>(obj: { [k: string]: T }): ImmutableTree<T> {\n    let tree: ImmutableTree<T> = ImmutableTree.Empty;\n    forEach(obj, (childPath: string, childSnap: T) => {\n      tree = tree.set(new Path(childPath), childSnap);\n    });\n    return tree;\n  }\n\n  /**\n   * @template T\n   * @param {?T} value\n   * @param {SortedMap.<string, !ImmutableTree.<T>>=} children\n   */\n  constructor(\n    public readonly value: T | null,\n    public readonly children: SortedMap<\n      string,\n      ImmutableTree<T>\n    > = EmptyChildren()\n  ) {}\n\n  /**\n   * True if the value is empty and there are no children\n   * @return {boolean}\n   */\n  isEmpty(): boolean {\n    return this.value === null && this.children.isEmpty();\n  }\n\n  /**\n   * Given a path and predicate, return the first node and the path to that node\n   * where the predicate returns true.\n   *\n   * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects\n   * on the way back out, it may be better to pass down a pathSoFar obj.\n   *\n   * @param {!Path} relativePath The remainder of the path\n   * @param {function(T):boolean} predicate The predicate to satisfy to return a\n   *   node\n   * @return {?{path:!Path, value:!T}}\n   */\n  findRootMostMatchingPathAndValue(\n    relativePath: Path,\n    predicate: (a: T) => boolean\n  ): { path: Path; value: T } | null {\n    if (this.value != null && predicate(this.value)) {\n      return { path: Path.Empty, value: this.value };\n    } else {\n      if (relativePath.isEmpty()) {\n        return null;\n      } else {\n        const front = relativePath.getFront();\n        const child = this.children.get(front);\n        if (child !== null) {\n          const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(\n            relativePath.popFront(),\n            predicate\n          );\n          if (childExistingPathAndValue != null) {\n            const fullPath = new Path(front).child(\n              childExistingPathAndValue.path\n            );\n            return { path: fullPath, value: childExistingPathAndValue.value };\n          } else {\n            return null;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n\n  /**\n   * Find, if it exists, the shortest subpath of the given path that points a defined\n   * value in the tree\n   * @param {!Path} relativePath\n   * @return {?{path: !Path, value: !T}}\n   */\n  findRootMostValueAndPath(\n    relativePath: Path\n  ): { path: Path; value: T } | null {\n    return this.findRootMostMatchingPathAndValue(relativePath, () => true);\n  }\n\n  /**\n   * @param {!Path} relativePath\n   * @return {!ImmutableTree.<T>} The subtree at the given path\n   */\n  subtree(relativePath: Path): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return this;\n    } else {\n      const front = relativePath.getFront();\n      const childTree = this.children.get(front);\n      if (childTree !== null) {\n        return childTree.subtree(relativePath.popFront());\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  }\n\n  /**\n   * Sets a value at the specified path.\n   *\n   * @param {!Path} relativePath Path to set value at.\n   * @param {?T} toSet Value to set.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  set(relativePath: Path, toSet: T | null): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return new ImmutableTree(toSet, this.children);\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front) || ImmutableTree.Empty;\n      const newChild = child.set(relativePath.popFront(), toSet);\n      const newChildren = this.children.insert(front, newChild);\n      return new ImmutableTree(this.value, newChildren);\n    }\n  }\n\n  /**\n   * Removes the value at the specified path.\n   *\n   * @param {!Path} relativePath Path to value to remove.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  remove(relativePath: Path): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      if (this.children.isEmpty()) {\n        return ImmutableTree.Empty;\n      } else {\n        return new ImmutableTree(null, this.children);\n      }\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front);\n      if (child) {\n        const newChild = child.remove(relativePath.popFront());\n        let newChildren;\n        if (newChild.isEmpty()) {\n          newChildren = this.children.remove(front);\n        } else {\n          newChildren = this.children.insert(front, newChild);\n        }\n        if (this.value === null && newChildren.isEmpty()) {\n          return ImmutableTree.Empty;\n        } else {\n          return new ImmutableTree(this.value, newChildren);\n        }\n      } else {\n        return this;\n      }\n    }\n  }\n\n  /**\n   * Gets a value from the tree.\n   *\n   * @param {!Path} relativePath Path to get value for.\n   * @return {?T} Value at path, or null.\n   */\n  get(relativePath: Path): T | null {\n    if (relativePath.isEmpty()) {\n      return this.value;\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front);\n      if (child) {\n        return child.get(relativePath.popFront());\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Replace the subtree at the specified path with the given new tree.\n   *\n   * @param {!Path} relativePath Path to replace subtree for.\n   * @param {!ImmutableTree} newTree New tree.\n   * @return {!ImmutableTree} Resulting tree.\n   */\n  setTree(relativePath: Path, newTree: ImmutableTree<T>): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return newTree;\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front) || ImmutableTree.Empty;\n      const newChild = child.setTree(relativePath.popFront(), newTree);\n      let newChildren;\n      if (newChild.isEmpty()) {\n        newChildren = this.children.remove(front);\n      } else {\n        newChildren = this.children.insert(front, newChild);\n      }\n      return new ImmutableTree(this.value, newChildren);\n    }\n  }\n\n  /**\n   * Performs a depth first fold on this tree. Transforms a tree into a single\n   * value, given a function that operates on the path to a node, an optional\n   * current value, and a map of child names to folded subtrees\n   * @template V\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   */\n  fold<V>(fn: (path: Path, value: T, children: { [k: string]: V }) => V): V {\n    return this.fold_(Path.Empty, fn);\n  }\n\n  /**\n   * Recursive helper for public-facing fold() method\n   * @template V\n   * @param {!Path} pathSoFar\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   * @private\n   */\n  private fold_<V>(\n    pathSoFar: Path,\n    fn: (path: Path, value: T | null, children: { [k: string]: V }) => V\n  ): V {\n    const accum: { [k: string]: V } = {};\n    this.children.inorderTraversal(function(\n      childKey: string,\n      childTree: ImmutableTree<T>\n    ) {\n      accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);\n    });\n    return fn(pathSoFar, this.value, accum);\n  }\n\n  /**\n   * Find the first matching value on the given path. Return the result of applying f to it.\n   * @template V\n   * @param {!Path} path\n   * @param {!function(!Path, !T):?V} f\n   * @return {?V}\n   */\n  findOnPath<V>(path: Path, f: (path: Path, value: T) => V | null): V | null {\n    return this.findOnPath_(path, Path.Empty, f);\n  }\n\n  private findOnPath_<V>(\n    pathToFollow: Path,\n    pathSoFar: Path,\n    f: (path: Path, value: T) => V | null\n  ): V | null {\n    const result = this.value ? f(pathSoFar, this.value) : false;\n    if (result) {\n      return result;\n    } else {\n      if (pathToFollow.isEmpty()) {\n        return null;\n      } else {\n        const front = pathToFollow.getFront()!;\n        const nextChild = this.children.get(front);\n        if (nextChild) {\n          return nextChild.findOnPath_(\n            pathToFollow.popFront(),\n            pathSoFar.child(front),\n            f\n          );\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {!Path} path\n   * @param {!function(!Path, !T)} f\n   * @returns {!ImmutableTree.<T>}\n   */\n  foreachOnPath(\n    path: Path,\n    f: (path: Path, value: T) => void\n  ): ImmutableTree<T> {\n    return this.foreachOnPath_(path, Path.Empty, f);\n  }\n\n  private foreachOnPath_(\n    pathToFollow: Path,\n    currentRelativePath: Path,\n    f: (path: Path, value: T) => void\n  ): ImmutableTree<T> {\n    if (pathToFollow.isEmpty()) {\n      return this;\n    } else {\n      if (this.value) {\n        f(currentRelativePath, this.value);\n      }\n      const front = pathToFollow.getFront();\n      const nextChild = this.children.get(front);\n      if (nextChild) {\n        return nextChild.foreachOnPath_(\n          pathToFollow.popFront(),\n          currentRelativePath.child(front),\n          f\n        );\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  }\n\n  /**\n   * Calls the given function for each node in the tree that has a value.\n   *\n   * @param {function(!Path, !T)} f A function to be called with\n   *   the path from the root of the tree to a node, and the value at that node.\n   *   Called in depth-first order.\n   */\n  foreach(f: (path: Path, value: T) => void) {\n    this.foreach_(Path.Empty, f);\n  }\n\n  private foreach_(\n    currentRelativePath: Path,\n    f: (path: Path, value: T) => void\n  ) {\n    this.children.inorderTraversal(function(childName, childTree) {\n      childTree.foreach_(currentRelativePath.child(childName), f);\n    });\n    if (this.value) {\n      f(currentRelativePath, this.value);\n    }\n  }\n\n  /**\n   *\n   * @param {function(string, !T)} f\n   */\n  foreachChild(f: (name: string, value: T) => void) {\n    this.children.inorderTraversal(\n      (childName: string, childTree: ImmutableTree<T>) => {\n        if (childTree.value) {\n          f(childName, childTree.value);\n        }\n      }\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}