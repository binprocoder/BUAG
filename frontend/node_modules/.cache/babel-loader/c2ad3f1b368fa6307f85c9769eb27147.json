{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Path_1 = require(\"./Path\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"./util\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar util_4 = require(\"@firebase/util\");\n/**\r\n * True for invalid Firebase keys\r\n * @type {RegExp}\r\n * @private\r\n */\n\n\nexports.INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n/**\r\n * True for invalid Firebase paths.\r\n * Allows '/' in paths.\r\n * @type {RegExp}\r\n * @private\r\n */\n\nexports.INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n/**\r\n * Maximum number of characters to allow in leaf value\r\n * @type {number}\r\n * @private\r\n */\n\nexports.MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\n/**\r\n * @param {*} key\r\n * @return {boolean}\r\n */\n\nexports.isValidKey = function (key) {\n  return typeof key === 'string' && key.length !== 0 && !exports.INVALID_KEY_REGEX_.test(key);\n};\n/**\r\n * @param {string} pathString\r\n * @return {boolean}\r\n */\n\n\nexports.isValidPathString = function (pathString) {\n  return typeof pathString === 'string' && pathString.length !== 0 && !exports.INVALID_PATH_REGEX_.test(pathString);\n};\n/**\r\n * @param {string} pathString\r\n * @return {boolean}\r\n */\n\n\nexports.isValidRootPathString = function (pathString) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  return exports.isValidPathString(pathString);\n};\n/**\r\n * @param {*} priority\r\n * @return {boolean}\r\n */\n\n\nexports.isValidPriority = function (priority) {\n  return priority === null || typeof priority === 'string' || typeof priority === 'number' && !util_2.isInvalidJSONNumber(priority) || priority && typeof priority === 'object' && util_1.contains(priority, '.sv');\n};\n/**\r\n * Pre-validate a datum passed as an argument to Firebase function.\r\n *\r\n * @param {string} fnName\r\n * @param {number} argumentNumber\r\n * @param {*} data\r\n * @param {!Path} path\r\n * @param {boolean} optional\r\n */\n\n\nexports.validateFirebaseDataArg = function (fnName, argumentNumber, data, path, optional) {\n  if (optional && data === undefined) return;\n  exports.validateFirebaseData(util_3.errorPrefix(fnName, argumentNumber, optional), data, path);\n};\n/**\r\n * Validate a data object client-side before sending to server.\r\n *\r\n * @param {string} errorPrefix\r\n * @param {*} data\r\n * @param {!Path|!ValidationPath} path_\r\n */\n\n\nexports.validateFirebaseData = function (errorPrefix, data, path_) {\n  var path = path_ instanceof Path_1.Path ? new Path_1.ValidationPath(path_, errorPrefix) : path_;\n\n  if (data === undefined) {\n    throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());\n  }\n\n  if (typeof data === 'function') {\n    throw new Error(errorPrefix + 'contains a function ' + path.toErrorString() + ' with contents = ' + data.toString());\n  }\n\n  if (util_2.isInvalidJSONNumber(data)) {\n    throw new Error(errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString());\n  } // Check max leaf size, but try to avoid the utf8 conversion if we can.\n\n\n  if (typeof data === 'string' && data.length > exports.MAX_LEAF_SIZE_ / 3 && util_4.stringLength(data) > exports.MAX_LEAF_SIZE_) {\n    throw new Error(errorPrefix + 'contains a string greater than ' + exports.MAX_LEAF_SIZE_ + ' utf8 bytes ' + path.toErrorString() + \" ('\" + data.substring(0, 50) + \"...')\");\n  } // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n  // to save extra walking of large objects.\n\n\n  if (data && typeof data === 'object') {\n    var hasDotValue_1 = false,\n        hasActualChild_1 = false;\n    util_1.forEach(data, function (key, value) {\n      if (key === '.value') {\n        hasDotValue_1 = true;\n      } else if (key !== '.priority' && key !== '.sv') {\n        hasActualChild_1 = true;\n\n        if (!exports.isValidKey(key)) {\n          throw new Error(errorPrefix + ' contains an invalid key (' + key + ') ' + path.toErrorString() + '.  Keys must be non-empty strings ' + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n        }\n      }\n\n      path.push(key);\n      exports.validateFirebaseData(errorPrefix, value, path);\n      path.pop();\n    });\n\n    if (hasDotValue_1 && hasActualChild_1) {\n      throw new Error(errorPrefix + ' contains \".value\" child ' + path.toErrorString() + ' in addition to actual children.');\n    }\n  }\n};\n/**\r\n * Pre-validate paths passed in the firebase function.\r\n *\r\n * @param {string} errorPrefix\r\n * @param {Array<!Path>} mergePaths\r\n */\n\n\nexports.validateFirebaseMergePaths = function (errorPrefix, mergePaths) {\n  var i, curPath;\n\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    var keys = curPath.slice();\n\n    for (var j = 0; j < keys.length; j++) {\n      if (keys[j] === '.priority' && j === keys.length - 1) {// .priority is OK\n      } else if (!exports.isValidKey(keys[j])) {\n        throw new Error(errorPrefix + 'contains an invalid key (' + keys[j] + ') in path ' + curPath.toString() + '. Keys must be non-empty strings ' + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n      }\n    }\n  } // Check that update keys are not descendants of each other.\n  // We rely on the property that sorting guarantees that ancestors come\n  // right before descendants.\n\n\n  mergePaths.sort(Path_1.Path.comparePaths);\n  var prevPath = null;\n\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n\n    if (prevPath !== null && prevPath.contains(curPath)) {\n      throw new Error(errorPrefix + 'contains a path ' + prevPath.toString() + ' that is ancestor of another path ' + curPath.toString());\n    }\n\n    prevPath = curPath;\n  }\n};\n/**\r\n * pre-validate an object passed as an argument to firebase function (\r\n * must be an object - e.g. for firebase.update()).\r\n *\r\n * @param {string} fnName\r\n * @param {number} argumentNumber\r\n * @param {*} data\r\n * @param {!Path} path\r\n * @param {boolean} optional\r\n */\n\n\nexports.validateFirebaseMergeDataArg = function (fnName, argumentNumber, data, path, optional) {\n  if (optional && data === undefined) return;\n  var errorPrefix = util_3.errorPrefix(fnName, argumentNumber, optional);\n\n  if (!(data && typeof data === 'object') || Array.isArray(data)) {\n    throw new Error(errorPrefix + ' must be an object containing the children to replace.');\n  }\n\n  var mergePaths = [];\n  util_1.forEach(data, function (key, value) {\n    var curPath = new Path_1.Path(key);\n    exports.validateFirebaseData(errorPrefix, value, path.child(curPath));\n\n    if (curPath.getBack() === '.priority') {\n      if (!exports.isValidPriority(value)) {\n        throw new Error(errorPrefix + \"contains an invalid value for '\" + curPath.toString() + \"', which must be a valid \" + 'Firebase priority (a string, finite number, server value, or null).');\n      }\n    }\n\n    mergePaths.push(curPath);\n  });\n  exports.validateFirebaseMergePaths(errorPrefix, mergePaths);\n};\n\nexports.validatePriority = function (fnName, argumentNumber, priority, optional) {\n  if (optional && priority === undefined) return;\n  if (util_2.isInvalidJSONNumber(priority)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'is ' + priority.toString() + ', but must be a valid Firebase priority (a string, finite number, ' + 'server value, or null).'); // Special case to allow importing data with a .sv.\n\n  if (!exports.isValidPriority(priority)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid Firebase priority ' + '(a string, finite number, server value, or null).');\n};\n\nexports.validateEventType = function (fnName, argumentNumber, eventType, optional) {\n  if (optional && eventType === undefined) return;\n\n  switch (eventType) {\n    case 'value':\n    case 'child_added':\n    case 'child_removed':\n    case 'child_changed':\n    case 'child_moved':\n      break;\n\n    default:\n      throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' + '\"child_changed\", or \"child_moved\".');\n  }\n};\n\nexports.validateKey = function (fnName, argumentNumber, key, optional) {\n  if (optional && key === undefined) return;\n  if (!exports.isValidKey(key)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'was an invalid key = \"' + key + '\".  Firebase keys must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');\n};\n\nexports.validatePathString = function (fnName, argumentNumber, pathString, optional) {\n  if (optional && pathString === undefined) return;\n  if (!exports.isValidPathString(pathString)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'was an invalid path = \"' + pathString + '\". Paths must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');\n};\n\nexports.validateRootPathString = function (fnName, argumentNumber, pathString, optional) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  exports.validatePathString(fnName, argumentNumber, pathString, optional);\n};\n\nexports.validateWritablePath = function (fnName, path) {\n  if (path.getFront() === '.info') {\n    throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n  }\n};\n\nexports.validateUrl = function (fnName, argumentNumber, parsedUrl) {\n  // TODO = Validate server better.\n  var pathString = parsedUrl.path.toString();\n\n  if (!(typeof parsedUrl.repoInfo.host === 'string') || parsedUrl.repoInfo.host.length === 0 || !exports.isValidKey(parsedUrl.repoInfo.namespace) || pathString.length !== 0 && !exports.isValidRootPathString(pathString)) {\n    throw new Error(util_3.errorPrefix(fnName, argumentNumber, false) + 'must be a valid firebase URL and ' + 'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');\n  }\n};\n\nexports.validateCredential = function (fnName, argumentNumber, cred, optional) {\n  if (optional && cred === undefined) return;\n  if (!(typeof cred === 'string')) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid credential (a string).');\n};\n\nexports.validateBoolean = function (fnName, argumentNumber, bool, optional) {\n  if (optional && bool === undefined) return;\n  if (typeof bool !== 'boolean') throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a boolean.');\n};\n\nexports.validateString = function (fnName, argumentNumber, string, optional) {\n  if (optional && string === undefined) return;\n\n  if (!(typeof string === 'string')) {\n    throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid string.');\n  }\n};\n\nexports.validateObject = function (fnName, argumentNumber, obj, optional) {\n  if (optional && obj === undefined) return;\n\n  if (!(obj && typeof obj === 'object') || obj === null) {\n    throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid object.');\n  }\n};\n\nexports.validateObjectContainsKey = function (fnName, argumentNumber, obj, key, optional, opt_type) {\n  var objectContainsKey = obj && typeof obj === 'object' && util_1.contains(obj, key);\n\n  if (!objectContainsKey) {\n    if (optional) {\n      return;\n    } else {\n      throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must contain the key \"' + key + '\"');\n    }\n  }\n\n  if (opt_type) {\n    var val = util_1.safeGet(obj, key);\n\n    if (opt_type === 'number' && !(typeof val === 'number') || opt_type === 'string' && !(typeof val === 'string') || opt_type === 'boolean' && !(typeof val === 'boolean') || opt_type === 'function' && !(typeof val === 'function') || opt_type === 'object' && !(typeof val === 'object') && val) {\n      if (optional) {\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'contains invalid value for key \"' + key + '\" (must be of type \"' + opt_type + '\")');\n      } else {\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must contain the key \"' + key + '\" with type \"' + opt_type + '\"');\n      }\n    }\n  }\n};","map":{"version":3,"mappings":"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","names":["exports","key","length","test","pathString","replace","priority","util_2","util_1","fnName","argumentNumber","data","path","optional","undefined","util_3","errorPrefix","path_","Path_1","Error","toErrorString","toString","util_4","substring","hasDotValue_1","hasActualChild_1","value","push","pop","mergePaths","i","curPath","keys","slice","j","sort","comparePaths","prevPath","contains","Array","isArray","child","getBack","eventType","getFront","parsedUrl","repoInfo","host","namespace","cred","bool","string","obj","opt_type","objectContainsKey","val"],"sources":["../src/core/util/validation.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path, ValidationPath } from './Path';\nimport { forEach, contains, safeGet } from '@firebase/util';\nimport { isInvalidJSONNumber } from './util';\nimport { errorPrefix as errorPrefixFxn } from '@firebase/util';\nimport { stringLength } from '@firebase/util';\nimport { RepoInfo } from '../RepoInfo';\n\n/**\n * True for invalid Firebase keys\n * @type {RegExp}\n * @private\n */\nexport const INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n\n/**\n * True for invalid Firebase paths.\n * Allows '/' in paths.\n * @type {RegExp}\n * @private\n */\nexport const INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n\n/**\n * Maximum number of characters to allow in leaf value\n * @type {number}\n * @private\n */\nexport const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\n\n/**\n * @param {*} key\n * @return {boolean}\n */\nexport const isValidKey = function(key: any): boolean {\n  return (\n    typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key)\n  );\n};\n\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexport const isValidPathString = function(pathString: string): boolean {\n  return (\n    typeof pathString === 'string' &&\n    pathString.length !== 0 &&\n    !INVALID_PATH_REGEX_.test(pathString)\n  );\n};\n\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexport const isValidRootPathString = function(pathString: string): boolean {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  return isValidPathString(pathString);\n};\n\n/**\n * @param {*} priority\n * @return {boolean}\n */\nexport const isValidPriority = function(priority: any): boolean {\n  return (\n    priority === null ||\n    typeof priority === 'string' ||\n    (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||\n    (priority && typeof priority === 'object' && contains(priority, '.sv'))\n  );\n};\n\n/**\n * Pre-validate a datum passed as an argument to Firebase function.\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexport const validateFirebaseDataArg = function(\n  fnName: string,\n  argumentNumber: number,\n  data: any,\n  path: Path,\n  optional: boolean\n) {\n  if (optional && data === undefined) return;\n\n  validateFirebaseData(\n    errorPrefixFxn(fnName, argumentNumber, optional),\n    data,\n    path\n  );\n};\n\n/**\n * Validate a data object client-side before sending to server.\n *\n * @param {string} errorPrefix\n * @param {*} data\n * @param {!Path|!ValidationPath} path_\n */\nexport const validateFirebaseData = function(\n  errorPrefix: string,\n  data: any,\n  path_: Path | ValidationPath\n) {\n  const path =\n    path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\n\n  if (data === undefined) {\n    throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());\n  }\n  if (typeof data === 'function') {\n    throw new Error(\n      errorPrefix +\n        'contains a function ' +\n        path.toErrorString() +\n        ' with contents = ' +\n        data.toString()\n    );\n  }\n  if (isInvalidJSONNumber(data)) {\n    throw new Error(\n      errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString()\n    );\n  }\n\n  // Check max leaf size, but try to avoid the utf8 conversion if we can.\n  if (\n    typeof data === 'string' &&\n    data.length > MAX_LEAF_SIZE_ / 3 &&\n    stringLength(data) > MAX_LEAF_SIZE_\n  ) {\n    throw new Error(\n      errorPrefix +\n        'contains a string greater than ' +\n        MAX_LEAF_SIZE_ +\n        ' utf8 bytes ' +\n        path.toErrorString() +\n        \" ('\" +\n        data.substring(0, 50) +\n        \"...')\"\n    );\n  }\n\n  // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n  // to save extra walking of large objects.\n  if (data && typeof data === 'object') {\n    let hasDotValue = false,\n      hasActualChild = false;\n    forEach(data, function(key: string, value: any) {\n      if (key === '.value') {\n        hasDotValue = true;\n      } else if (key !== '.priority' && key !== '.sv') {\n        hasActualChild = true;\n        if (!isValidKey(key)) {\n          throw new Error(\n            errorPrefix +\n              ' contains an invalid key (' +\n              key +\n              ') ' +\n              path.toErrorString() +\n              '.  Keys must be non-empty strings ' +\n              'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"'\n          );\n        }\n      }\n\n      path.push(key);\n      validateFirebaseData(errorPrefix, value, path);\n      path.pop();\n    });\n\n    if (hasDotValue && hasActualChild) {\n      throw new Error(\n        errorPrefix +\n          ' contains \".value\" child ' +\n          path.toErrorString() +\n          ' in addition to actual children.'\n      );\n    }\n  }\n};\n\n/**\n * Pre-validate paths passed in the firebase function.\n *\n * @param {string} errorPrefix\n * @param {Array<!Path>} mergePaths\n */\nexport const validateFirebaseMergePaths = function(\n  errorPrefix: string,\n  mergePaths: Path[]\n) {\n  let i, curPath;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    const keys = curPath.slice();\n    for (let j = 0; j < keys.length; j++) {\n      if (keys[j] === '.priority' && j === keys.length - 1) {\n        // .priority is OK\n      } else if (!isValidKey(keys[j])) {\n        throw new Error(\n          errorPrefix +\n            'contains an invalid key (' +\n            keys[j] +\n            ') in path ' +\n            curPath.toString() +\n            '. Keys must be non-empty strings ' +\n            'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"'\n        );\n      }\n    }\n  }\n\n  // Check that update keys are not descendants of each other.\n  // We rely on the property that sorting guarantees that ancestors come\n  // right before descendants.\n  mergePaths.sort(Path.comparePaths);\n  let prevPath: Path | null = null;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    if (prevPath !== null && prevPath.contains(curPath)) {\n      throw new Error(\n        errorPrefix +\n          'contains a path ' +\n          prevPath.toString() +\n          ' that is ancestor of another path ' +\n          curPath.toString()\n      );\n    }\n    prevPath = curPath;\n  }\n};\n\n/**\n * pre-validate an object passed as an argument to firebase function (\n * must be an object - e.g. for firebase.update()).\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexport const validateFirebaseMergeDataArg = function(\n  fnName: string,\n  argumentNumber: number,\n  data: any,\n  path: Path,\n  optional: boolean\n) {\n  if (optional && data === undefined) return;\n\n  const errorPrefix = errorPrefixFxn(fnName, argumentNumber, optional);\n\n  if (!(data && typeof data === 'object') || Array.isArray(data)) {\n    throw new Error(\n      errorPrefix + ' must be an object containing the children to replace.'\n    );\n  }\n\n  const mergePaths: Path[] = [];\n  forEach(data, function(key: string, value: any) {\n    const curPath = new Path(key);\n    validateFirebaseData(errorPrefix, value, path.child(curPath));\n    if (curPath.getBack() === '.priority') {\n      if (!isValidPriority(value)) {\n        throw new Error(\n          errorPrefix +\n            \"contains an invalid value for '\" +\n            curPath.toString() +\n            \"', which must be a valid \" +\n            'Firebase priority (a string, finite number, server value, or null).'\n        );\n      }\n    }\n    mergePaths.push(curPath);\n  });\n  validateFirebaseMergePaths(errorPrefix, mergePaths);\n};\n\nexport const validatePriority = function(\n  fnName: string,\n  argumentNumber: number,\n  priority: any,\n  optional: boolean\n) {\n  if (optional && priority === undefined) return;\n  if (isInvalidJSONNumber(priority))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'is ' +\n        priority.toString() +\n        ', but must be a valid Firebase priority (a string, finite number, ' +\n        'server value, or null).'\n    );\n  // Special case to allow importing data with a .sv.\n  if (!isValidPriority(priority))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid Firebase priority ' +\n        '(a string, finite number, server value, or null).'\n    );\n};\n\nexport const validateEventType = function(\n  fnName: string,\n  argumentNumber: number,\n  eventType: string,\n  optional: boolean\n) {\n  if (optional && eventType === undefined) return;\n\n  switch (eventType) {\n    case 'value':\n    case 'child_added':\n    case 'child_removed':\n    case 'child_changed':\n    case 'child_moved':\n      break;\n    default:\n      throw new Error(\n        errorPrefixFxn(fnName, argumentNumber, optional) +\n          'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' +\n          '\"child_changed\", or \"child_moved\".'\n      );\n  }\n};\n\nexport const validateKey = function(\n  fnName: string,\n  argumentNumber: number,\n  key: string,\n  optional: boolean\n) {\n  if (optional && key === undefined) return;\n  if (!isValidKey(key))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'was an invalid key = \"' +\n        key +\n        '\".  Firebase keys must be non-empty strings and ' +\n        'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").'\n    );\n};\n\nexport const validatePathString = function(\n  fnName: string,\n  argumentNumber: number,\n  pathString: string,\n  optional: boolean\n) {\n  if (optional && pathString === undefined) return;\n\n  if (!isValidPathString(pathString))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'was an invalid path = \"' +\n        pathString +\n        '\". Paths must be non-empty strings and ' +\n        'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"'\n    );\n};\n\nexport const validateRootPathString = function(\n  fnName: string,\n  argumentNumber: number,\n  pathString: string,\n  optional: boolean\n) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  validatePathString(fnName, argumentNumber, pathString, optional);\n};\n\nexport const validateWritablePath = function(fnName: string, path: Path) {\n  if (path.getFront() === '.info') {\n    throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n  }\n};\n\nexport const validateUrl = function(\n  fnName: string,\n  argumentNumber: number,\n  parsedUrl: { repoInfo: RepoInfo; path: Path }\n) {\n  // TODO = Validate server better.\n  const pathString = parsedUrl.path.toString();\n  if (\n    !(typeof parsedUrl.repoInfo.host === 'string') ||\n    parsedUrl.repoInfo.host.length === 0 ||\n    !isValidKey(parsedUrl.repoInfo.namespace) ||\n    (pathString.length !== 0 && !isValidRootPathString(pathString))\n  ) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, false) +\n        'must be a valid firebase URL and ' +\n        'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".'\n    );\n  }\n};\n\nexport const validateCredential = function(\n  fnName: string,\n  argumentNumber: number,\n  cred: any,\n  optional: boolean\n) {\n  if (optional && cred === undefined) return;\n  if (!(typeof cred === 'string'))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid credential (a string).'\n    );\n};\n\nexport const validateBoolean = function(\n  fnName: string,\n  argumentNumber: number,\n  bool: any,\n  optional: boolean\n) {\n  if (optional && bool === undefined) return;\n  if (typeof bool !== 'boolean')\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) + 'must be a boolean.'\n    );\n};\n\nexport const validateString = function(\n  fnName: string,\n  argumentNumber: number,\n  string: any,\n  optional: boolean\n) {\n  if (optional && string === undefined) return;\n  if (!(typeof string === 'string')) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid string.'\n    );\n  }\n};\n\nexport const validateObject = function(\n  fnName: string,\n  argumentNumber: number,\n  obj: any,\n  optional: boolean\n) {\n  if (optional && obj === undefined) return;\n  if (!(obj && typeof obj === 'object') || obj === null) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid object.'\n    );\n  }\n};\n\nexport const validateObjectContainsKey = function(\n  fnName: string,\n  argumentNumber: number,\n  obj: any,\n  key: string,\n  optional: boolean,\n  opt_type?: string\n) {\n  const objectContainsKey =\n    obj && typeof obj === 'object' && contains(obj, key);\n\n  if (!objectContainsKey) {\n    if (optional) {\n      return;\n    } else {\n      throw new Error(\n        errorPrefixFxn(fnName, argumentNumber, optional) +\n          'must contain the key \"' +\n          key +\n          '\"'\n      );\n    }\n  }\n\n  if (opt_type) {\n    const val = safeGet(obj, key);\n    if (\n      (opt_type === 'number' && !(typeof val === 'number')) ||\n      (opt_type === 'string' && !(typeof val === 'string')) ||\n      (opt_type === 'boolean' && !(typeof val === 'boolean')) ||\n      (opt_type === 'function' && !(typeof val === 'function')) ||\n      (opt_type === 'object' && !(typeof val === 'object') && val)\n    ) {\n      if (optional) {\n        throw new Error(\n          errorPrefixFxn(fnName, argumentNumber, optional) +\n            'contains invalid value for key \"' +\n            key +\n            '\" (must be of type \"' +\n            opt_type +\n            '\")'\n        );\n      } else {\n        throw new Error(\n          errorPrefixFxn(fnName, argumentNumber, optional) +\n            'must contain the key \"' +\n            key +\n            '\" with type \"' +\n            opt_type +\n            '\"'\n        );\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}