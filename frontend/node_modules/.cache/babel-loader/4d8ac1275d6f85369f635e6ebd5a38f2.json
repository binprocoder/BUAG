{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar app_1 = require(\"@firebase/app\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"@firebase/util\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar util_4 = require(\"./util/util\");\n\nvar Path_1 = require(\"./util/Path\");\n\nvar VisibilityMonitor_1 = require(\"./util/VisibilityMonitor\");\n\nvar OnlineMonitor_1 = require(\"./util/OnlineMonitor\");\n\nvar util_5 = require(\"@firebase/util\");\n\nvar Connection_1 = require(\"../realtime/Connection\");\n\nvar util_6 = require(\"@firebase/util\");\n\nvar util_7 = require(\"@firebase/util\");\n\nvar ServerActions_1 = require(\"./ServerActions\");\n\nvar RECONNECT_MIN_DELAY = 1000;\nvar RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\n\nvar RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\n\nvar RECONNECT_DELAY_MULTIPLIER = 1.3;\nvar RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\n\nvar SERVER_KILL_INTERRUPT_REASON = 'server_kill'; // If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\n\nvar INVALID_AUTH_TOKEN_THRESHOLD = 3;\n/**\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\n *\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\n * in quotes to make sure the closure compiler does not minify them.\n */\n\nvar PersistentConnection =\n/** @class */\nfunction (_super) {\n  __extends(PersistentConnection, _super);\n  /**\n   * @implements {ServerActions}\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param onConnectStatus_\n   * @param onServerInfoUpdate_\n   * @param authTokenProvider_\n   * @param authOverride_\n   */\n\n\n  function PersistentConnection(repoInfo_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, authOverride_) {\n    var _this = _super.call(this) || this;\n\n    _this.repoInfo_ = repoInfo_;\n    _this.onDataUpdate_ = onDataUpdate_;\n    _this.onConnectStatus_ = onConnectStatus_;\n    _this.onServerInfoUpdate_ = onServerInfoUpdate_;\n    _this.authTokenProvider_ = authTokenProvider_;\n    _this.authOverride_ = authOverride_; // Used for diagnostic logging.\n\n    _this.id = PersistentConnection.nextPersistentConnectionId_++;\n    _this.log_ = util_4.logWrapper('p:' + _this.id + ':');\n    /** @private {Object} */\n\n    _this.interruptReasons_ = {};\n    _this.listens_ = {};\n    _this.outstandingPuts_ = [];\n    _this.outstandingPutCount_ = 0;\n    _this.onDisconnectRequestQueue_ = [];\n    _this.connected_ = false;\n    _this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n    _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n    _this.securityDebugCallback_ = null;\n    _this.lastSessionId = null;\n    /** @private {number|null} */\n\n    _this.establishConnectionTimer_ = null;\n    /** @private {boolean} */\n\n    _this.visible_ = false; // Before we get connected, we keep a queue of pending messages to send.\n\n    _this.requestCBHash_ = {};\n    _this.requestNumber_ = 0;\n    /** @private {?{\n     *   sendRequest(Object),\n     *   close()\n     * }} */\n\n    _this.realtime_ = null;\n    /** @private {string|null} */\n\n    _this.authToken_ = null;\n    _this.forceTokenRefresh_ = false;\n    _this.invalidAuthTokenCount_ = 0;\n    _this.firstConnection_ = true;\n    _this.lastConnectionAttemptTime_ = null;\n    _this.lastConnectionEstablishedTime_ = null;\n\n    if (authOverride_ && !util_7.isNodeSdk()) {\n      throw new Error('Auth override specified in options, but not supported on non Node.js platforms');\n    }\n\n    _this.scheduleConnect_(0);\n\n    VisibilityMonitor_1.VisibilityMonitor.getInstance().on('visible', _this.onVisible_, _this);\n\n    if (repoInfo_.host.indexOf('fblocal') === -1) {\n      OnlineMonitor_1.OnlineMonitor.getInstance().on('online', _this.onOnline_, _this);\n    }\n\n    return _this;\n  }\n  /**\n   * @param {!string} action\n   * @param {*} body\n   * @param {function(*)=} onResponse\n   * @protected\n   */\n\n\n  PersistentConnection.prototype.sendRequest = function (action, body, onResponse) {\n    var curReqNum = ++this.requestNumber_;\n    var msg = {\n      r: curReqNum,\n      a: action,\n      b: body\n    };\n    this.log_(util_2.stringify(msg));\n    util_3.assert(this.connected_, \"sendRequest call when we're not connected not allowed.\");\n    this.realtime_.sendRequest(msg);\n\n    if (onResponse) {\n      this.requestCBHash_[curReqNum] = onResponse;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PersistentConnection.prototype.listen = function (query, currentHashFn, tag, onComplete) {\n    var queryId = query.queryIdentifier();\n    var pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + queryId);\n    this.listens_[pathString] = this.listens_[pathString] || {};\n    util_3.assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(), 'listen() called for non-default but complete query');\n    util_3.assert(!this.listens_[pathString][queryId], 'listen() called twice for same path/queryId.');\n    var listenSpec = {\n      onComplete: onComplete,\n      hashFn: currentHashFn,\n      query: query,\n      tag: tag\n    };\n    this.listens_[pathString][queryId] = listenSpec;\n\n    if (this.connected_) {\n      this.sendListen_(listenSpec);\n    }\n  };\n  /**\n   * @param {!{onComplete(),\n   *           hashFn():!string,\n   *           query: !Query,\n   *           tag: ?number}} listenSpec\n   * @private\n   */\n\n\n  PersistentConnection.prototype.sendListen_ = function (listenSpec) {\n    var _this = this;\n\n    var query = listenSpec.query;\n    var pathString = query.path.toString();\n    var queryId = query.queryIdentifier();\n    this.log_('Listen on ' + pathString + ' for ' + queryId);\n    var req = {\n      /*path*/\n      p: pathString\n    };\n    var action = 'q'; // Only bother to send query if it's non-default.\n\n    if (listenSpec.tag) {\n      req['q'] = query.queryObject();\n      req['t'] = listenSpec.tag;\n    }\n\n    req['h'] = listenSpec.hashFn();\n    this.sendRequest(action, req, function (message) {\n      var payload = message['d'];\n      var status = message['s']; // print warnings in any case...\n\n      PersistentConnection.warnOnListenWarnings_(payload, query);\n      var currentListenSpec = _this.listens_[pathString] && _this.listens_[pathString][queryId]; // only trigger actions if the listen hasn't been removed and readded\n\n      if (currentListenSpec === listenSpec) {\n        _this.log_('listen response', message);\n\n        if (status !== 'ok') {\n          _this.removeListen_(pathString, queryId);\n        }\n\n        if (listenSpec.onComplete) {\n          listenSpec.onComplete(status, payload);\n        }\n      }\n    });\n  };\n  /**\n   * @param {*} payload\n   * @param {!Query} query\n   * @private\n   */\n\n\n  PersistentConnection.warnOnListenWarnings_ = function (payload, query) {\n    if (payload && typeof payload === 'object' && util_1.contains(payload, 'w')) {\n      var warnings = util_1.safeGet(payload, 'w');\n\n      if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\n        var indexSpec = '\".indexOn\": \"' + query.getQueryParams().getIndex().toString() + '\"';\n        var indexPath = query.path.toString();\n        util_4.warn(\"Using an unspecified index. Your data will be downloaded and \" + (\"filtered on the client. Consider adding \" + indexSpec + \" at \") + (indexPath + \" to your security rules for better performance.\"));\n      }\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PersistentConnection.prototype.refreshAuthToken = function (token) {\n    this.authToken_ = token;\n    this.log_('Auth token refreshed');\n\n    if (this.authToken_) {\n      this.tryAuth();\n    } else {\n      //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n      //the credential so we dont become authenticated next time we connect.\n      if (this.connected_) {\n        this.sendRequest('unauth', {}, function () {});\n      }\n    }\n\n    this.reduceReconnectDelayIfAdminCredential_(token);\n  };\n  /**\n   * @param {!string} credential\n   * @private\n   */\n\n\n  PersistentConnection.prototype.reduceReconnectDelayIfAdminCredential_ = function (credential) {\n    // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n    // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n    var isFirebaseSecret = credential && credential.length === 40;\n\n    if (isFirebaseSecret || util_5.isAdmin(credential)) {\n      this.log_('Admin auth credential detected.  Reducing max reconnect time.');\n      this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n    }\n  };\n  /**\n   * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\n   * a auth revoked (the connection is closed).\n   */\n\n\n  PersistentConnection.prototype.tryAuth = function () {\n    var _this = this;\n\n    if (this.connected_ && this.authToken_) {\n      var token_1 = this.authToken_;\n      var authMethod = util_5.isValidFormat(token_1) ? 'auth' : 'gauth';\n      var requestData = {\n        cred: token_1\n      };\n\n      if (this.authOverride_ === null) {\n        requestData['noauth'] = true;\n      } else if (typeof this.authOverride_ === 'object') {\n        requestData['authvar'] = this.authOverride_;\n      }\n\n      this.sendRequest(authMethod, requestData, function (res) {\n        var status = res['s'];\n        var data = res['d'] || 'error';\n\n        if (_this.authToken_ === token_1) {\n          if (status === 'ok') {\n            _this.invalidAuthTokenCount_ = 0;\n          } else {\n            // Triggers reconnect and force refresh for auth token\n            _this.onAuthRevoked_(status, data);\n          }\n        }\n      });\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PersistentConnection.prototype.unlisten = function (query, tag) {\n    var pathString = query.path.toString();\n    var queryId = query.queryIdentifier();\n    this.log_('Unlisten called for ' + pathString + ' ' + queryId);\n    util_3.assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(), 'unlisten() called for non-default but complete query');\n    var listen = this.removeListen_(pathString, queryId);\n\n    if (listen && this.connected_) {\n      this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);\n    }\n  };\n\n  PersistentConnection.prototype.sendUnlisten_ = function (pathString, queryId, queryObj, tag) {\n    this.log_('Unlisten on ' + pathString + ' for ' + queryId);\n    var req = {\n      /*path*/\n      p: pathString\n    };\n    var action = 'n'; // Only bother sending queryId if it's non-default.\n\n    if (tag) {\n      req['q'] = queryObj;\n      req['t'] = tag;\n    }\n\n    this.sendRequest(action, req);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PersistentConnection.prototype.onDisconnectPut = function (pathString, data, onComplete) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('o', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString: pathString,\n        action: 'o',\n        data: data,\n        onComplete: onComplete\n      });\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PersistentConnection.prototype.onDisconnectMerge = function (pathString, data, onComplete) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('om', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString: pathString,\n        action: 'om',\n        data: data,\n        onComplete: onComplete\n      });\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PersistentConnection.prototype.onDisconnectCancel = function (pathString, onComplete) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('oc', pathString, null, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString: pathString,\n        action: 'oc',\n        data: null,\n        onComplete: onComplete\n      });\n    }\n  };\n\n  PersistentConnection.prototype.sendOnDisconnect_ = function (action, pathString, data, onComplete) {\n    var request = {\n      /*path*/\n      p: pathString,\n\n      /*data*/\n      d: data\n    };\n    this.log_('onDisconnect ' + action, request);\n    this.sendRequest(action, request, function (response) {\n      if (onComplete) {\n        setTimeout(function () {\n          onComplete(response['s'], response['d']);\n        }, Math.floor(0));\n      }\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {\n    this.putInternal('p', pathString, data, onComplete, hash);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PersistentConnection.prototype.merge = function (pathString, data, onComplete, hash) {\n    this.putInternal('m', pathString, data, onComplete, hash);\n  };\n\n  PersistentConnection.prototype.putInternal = function (action, pathString, data, onComplete, hash) {\n    var request = {\n      /*path*/\n      p: pathString,\n\n      /*data*/\n      d: data\n    };\n    if (hash !== undefined) request['h'] = hash; // TODO: Only keep track of the most recent put for a given path?\n\n    this.outstandingPuts_.push({\n      action: action,\n      request: request,\n      onComplete: onComplete\n    });\n    this.outstandingPutCount_++;\n    var index = this.outstandingPuts_.length - 1;\n\n    if (this.connected_) {\n      this.sendPut_(index);\n    } else {\n      this.log_('Buffering put: ' + pathString);\n    }\n  };\n\n  PersistentConnection.prototype.sendPut_ = function (index) {\n    var _this = this;\n\n    var action = this.outstandingPuts_[index].action;\n    var request = this.outstandingPuts_[index].request;\n    var onComplete = this.outstandingPuts_[index].onComplete;\n    this.outstandingPuts_[index].queued = this.connected_;\n    this.sendRequest(action, request, function (message) {\n      _this.log_(action + ' response', message);\n\n      delete _this.outstandingPuts_[index];\n      _this.outstandingPutCount_--; // Clean up array occasionally.\n\n      if (_this.outstandingPutCount_ === 0) {\n        _this.outstandingPuts_ = [];\n      }\n\n      if (onComplete) onComplete(message['s'], message['d']);\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PersistentConnection.prototype.reportStats = function (stats) {\n    var _this = this; // If we're not connected, we just drop the stats.\n\n\n    if (this.connected_) {\n      var request = {\n        /*counters*/\n        c: stats\n      };\n      this.log_('reportStats', request);\n      this.sendRequest(\n      /*stats*/\n      's', request, function (result) {\n        var status = result['s'];\n\n        if (status !== 'ok') {\n          var errorReason = result['d'];\n\n          _this.log_('reportStats', 'Error sending stats: ' + errorReason);\n        }\n      });\n    }\n  };\n  /**\n   * @param {*} message\n   * @private\n   */\n\n\n  PersistentConnection.prototype.onDataMessage_ = function (message) {\n    if ('r' in message) {\n      // this is a response\n      this.log_('from server: ' + util_2.stringify(message));\n      var reqNum = message['r'];\n      var onResponse = this.requestCBHash_[reqNum];\n\n      if (onResponse) {\n        delete this.requestCBHash_[reqNum];\n        onResponse(message['b']);\n      }\n    } else if ('error' in message) {\n      throw 'A server-side error has occurred: ' + message['error'];\n    } else if ('a' in message) {\n      // a and b are action and body, respectively\n      this.onDataPush_(message['a'], message['b']);\n    }\n  };\n\n  PersistentConnection.prototype.onDataPush_ = function (action, body) {\n    this.log_('handleServerMessage', action, body);\n    if (action === 'd') this.onDataUpdate_(body['p'], body['d'],\n    /*isMerge*/\n    false, body['t']);else if (action === 'm') this.onDataUpdate_(body['p'], body['d'],\n    /*isMerge=*/\n    true, body['t']);else if (action === 'c') this.onListenRevoked_(body['p'], body['q']);else if (action === 'ac') this.onAuthRevoked_(body['s'], body['d']);else if (action === 'sd') this.onSecurityDebugPacket_(body);else util_4.error('Unrecognized action received from server: ' + util_2.stringify(action) + '\\nAre you using the latest client?');\n  };\n\n  PersistentConnection.prototype.onReady_ = function (timestamp, sessionId) {\n    this.log_('connection ready');\n    this.connected_ = true;\n    this.lastConnectionEstablishedTime_ = new Date().getTime();\n    this.handleTimestamp_(timestamp);\n    this.lastSessionId = sessionId;\n\n    if (this.firstConnection_) {\n      this.sendConnectStats_();\n    }\n\n    this.restoreState_();\n    this.firstConnection_ = false;\n    this.onConnectStatus_(true);\n  };\n\n  PersistentConnection.prototype.scheduleConnect_ = function (timeout) {\n    var _this = this;\n\n    util_3.assert(!this.realtime_, \"Scheduling a connect when we're already connected/ing?\");\n\n    if (this.establishConnectionTimer_) {\n      clearTimeout(this.establishConnectionTimer_);\n    } // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n    // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n\n\n    this.establishConnectionTimer_ = setTimeout(function () {\n      _this.establishConnectionTimer_ = null;\n\n      _this.establishConnection_();\n    }, Math.floor(timeout));\n  };\n  /**\n   * @param {boolean} visible\n   * @private\n   */\n\n\n  PersistentConnection.prototype.onVisible_ = function (visible) {\n    // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n    if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {\n      this.log_('Window became visible.  Reducing delay.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n\n    this.visible_ = visible;\n  };\n\n  PersistentConnection.prototype.onOnline_ = function (online) {\n    if (online) {\n      this.log_('Browser went online.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    } else {\n      this.log_('Browser went offline.  Killing connection.');\n\n      if (this.realtime_) {\n        this.realtime_.close();\n      }\n    }\n  };\n\n  PersistentConnection.prototype.onRealtimeDisconnect_ = function () {\n    this.log_('data client disconnected');\n    this.connected_ = false;\n    this.realtime_ = null; // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n\n    this.cancelSentTransactions_(); // Clear out the pending requests.\n\n    this.requestCBHash_ = {};\n\n    if (this.shouldReconnect_()) {\n      if (!this.visible_) {\n        this.log_(\"Window isn't visible.  Delaying reconnect.\");\n        this.reconnectDelay_ = this.maxReconnectDelay_;\n        this.lastConnectionAttemptTime_ = new Date().getTime();\n      } else if (this.lastConnectionEstablishedTime_) {\n        // If we've been connected long enough, reset reconnect delay to minimum.\n        var timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\n        if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        this.lastConnectionEstablishedTime_ = null;\n      }\n\n      var timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\n      var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\n      reconnectDelay = Math.random() * reconnectDelay;\n      this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\n      this.scheduleConnect_(reconnectDelay); // Adjust reconnect delay for next time.\n\n      this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\n    }\n\n    this.onConnectStatus_(false);\n  };\n\n  PersistentConnection.prototype.establishConnection_ = function () {\n    if (this.shouldReconnect_()) {\n      this.log_('Making a connection attempt');\n      this.lastConnectionAttemptTime_ = new Date().getTime();\n      this.lastConnectionEstablishedTime_ = null;\n      var onDataMessage_1 = this.onDataMessage_.bind(this);\n      var onReady_1 = this.onReady_.bind(this);\n      var onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);\n      var connId_1 = this.id + ':' + PersistentConnection.nextConnectionId_++;\n      var self_1 = this;\n      var lastSessionId_1 = this.lastSessionId;\n      var canceled_1 = false;\n      var connection_1 = null;\n\n      var closeFn_1 = function () {\n        if (connection_1) {\n          connection_1.close();\n        } else {\n          canceled_1 = true;\n          onDisconnect_1();\n        }\n      };\n\n      var sendRequestFn = function (msg) {\n        util_3.assert(connection_1, \"sendRequest call when we're not connected not allowed.\");\n        connection_1.sendRequest(msg);\n      };\n\n      this.realtime_ = {\n        close: closeFn_1,\n        sendRequest: sendRequestFn\n      };\n      var forceRefresh = this.forceTokenRefresh_;\n      this.forceTokenRefresh_ = false; // First fetch auth token, and establish connection after fetching the token was successful\n\n      this.authTokenProvider_.getToken(forceRefresh).then(function (result) {\n        if (!canceled_1) {\n          util_4.log('getToken() completed. Creating connection.');\n          self_1.authToken_ = result && result.accessToken;\n          connection_1 = new Connection_1.Connection(connId_1, self_1.repoInfo_, onDataMessage_1, onReady_1, onDisconnect_1,\n          /* onKill= */\n          function (reason) {\n            util_4.warn(reason + ' (' + self_1.repoInfo_.toString() + ')');\n            self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);\n          }, lastSessionId_1);\n        } else {\n          util_4.log('getToken() completed but was canceled');\n        }\n      }).then(null, function (error) {\n        self_1.log_('Failed to get token: ' + error);\n\n        if (!canceled_1) {\n          if (util_6.CONSTANTS.NODE_ADMIN) {\n            // This may be a critical error for the Admin Node.js SDK, so log a warning.\n            // But getToken() may also just have temporarily failed, so we still want to\n            // continue retrying.\n            util_4.warn(error);\n          }\n\n          closeFn_1();\n        }\n      });\n    }\n  };\n  /**\n   * @param {string} reason\n   */\n\n\n  PersistentConnection.prototype.interrupt = function (reason) {\n    util_4.log('Interrupting connection for reason: ' + reason);\n    this.interruptReasons_[reason] = true;\n\n    if (this.realtime_) {\n      this.realtime_.close();\n    } else {\n      if (this.establishConnectionTimer_) {\n        clearTimeout(this.establishConnectionTimer_);\n        this.establishConnectionTimer_ = null;\n      }\n\n      if (this.connected_) {\n        this.onRealtimeDisconnect_();\n      }\n    }\n  };\n  /**\n   * @param {string} reason\n   */\n\n\n  PersistentConnection.prototype.resume = function (reason) {\n    util_4.log('Resuming connection for reason: ' + reason);\n    delete this.interruptReasons_[reason];\n\n    if (util_1.isEmpty(this.interruptReasons_)) {\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n  };\n\n  PersistentConnection.prototype.handleTimestamp_ = function (timestamp) {\n    var delta = timestamp - new Date().getTime();\n    this.onServerInfoUpdate_({\n      serverTimeOffset: delta\n    });\n  };\n\n  PersistentConnection.prototype.cancelSentTransactions_ = function () {\n    for (var i = 0; i < this.outstandingPuts_.length; i++) {\n      var put = this.outstandingPuts_[i];\n\n      if (put &&\n      /*hash*/\n      'h' in put.request && put.queued) {\n        if (put.onComplete) put.onComplete('disconnect');\n        delete this.outstandingPuts_[i];\n        this.outstandingPutCount_--;\n      }\n    } // Clean up array occasionally.\n\n\n    if (this.outstandingPutCount_ === 0) this.outstandingPuts_ = [];\n  };\n  /**\n   * @param {!string} pathString\n   * @param {Array.<*>=} query\n   * @private\n   */\n\n\n  PersistentConnection.prototype.onListenRevoked_ = function (pathString, query) {\n    // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n    var queryId;\n\n    if (!query) {\n      queryId = 'default';\n    } else {\n      queryId = query.map(function (q) {\n        return util_4.ObjectToUniqueKey(q);\n      }).join('$');\n    }\n\n    var listen = this.removeListen_(pathString, queryId);\n    if (listen && listen.onComplete) listen.onComplete('permission_denied');\n  };\n  /**\n   * @param {!string} pathString\n   * @param {!string} queryId\n   * @return {{queries:Array.<Query>, onComplete:function(string)}}\n   * @private\n   */\n\n\n  PersistentConnection.prototype.removeListen_ = function (pathString, queryId) {\n    var normalizedPathString = new Path_1.Path(pathString).toString(); // normalize path.\n\n    var listen;\n\n    if (this.listens_[normalizedPathString] !== undefined) {\n      listen = this.listens_[normalizedPathString][queryId];\n      delete this.listens_[normalizedPathString][queryId];\n\n      if (util_1.getCount(this.listens_[normalizedPathString]) === 0) {\n        delete this.listens_[normalizedPathString];\n      }\n    } else {\n      // all listens for this path has already been removed\n      listen = undefined;\n    }\n\n    return listen;\n  };\n\n  PersistentConnection.prototype.onAuthRevoked_ = function (statusCode, explanation) {\n    util_4.log('Auth token revoked: ' + statusCode + '/' + explanation);\n    this.authToken_ = null;\n    this.forceTokenRefresh_ = true;\n    this.realtime_.close();\n\n    if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\n      // We'll wait a couple times before logging the warning / increasing the\n      // retry period since oauth tokens will report as \"invalid\" if they're\n      // just expired. Plus there may be transient issues that resolve themselves.\n      this.invalidAuthTokenCount_++;\n\n      if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {\n        // Set a long reconnect delay because recovery is unlikely\n        this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS; // Notify the auth token provider that the token is invalid, which will log\n        // a warning\n\n        this.authTokenProvider_.notifyForInvalidToken();\n      }\n    }\n  };\n\n  PersistentConnection.prototype.onSecurityDebugPacket_ = function (body) {\n    if (this.securityDebugCallback_) {\n      this.securityDebugCallback_(body);\n    } else {\n      if ('msg' in body && typeof console !== 'undefined') {\n        console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\n      }\n    }\n  };\n\n  PersistentConnection.prototype.restoreState_ = function () {\n    var _this = this; //Re-authenticate ourselves if we have a credential stored.\n\n\n    this.tryAuth(); // Puts depend on having received the corresponding data update from the server before they complete, so we must\n    // make sure to send listens before puts.\n\n    util_1.forEach(this.listens_, function (pathString, queries) {\n      util_1.forEach(queries, function (key, listenSpec) {\n        _this.sendListen_(listenSpec);\n      });\n    });\n\n    for (var i = 0; i < this.outstandingPuts_.length; i++) {\n      if (this.outstandingPuts_[i]) this.sendPut_(i);\n    }\n\n    while (this.onDisconnectRequestQueue_.length) {\n      var request = this.onDisconnectRequestQueue_.shift();\n      this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\n    }\n  };\n  /**\n   * Sends client stats for first connection\n   * @private\n   */\n\n\n  PersistentConnection.prototype.sendConnectStats_ = function () {\n    var stats = {};\n    var clientName = 'js';\n\n    if (util_6.CONSTANTS.NODE_ADMIN) {\n      clientName = 'admin_node';\n    } else if (util_6.CONSTANTS.NODE_CLIENT) {\n      clientName = 'node';\n    }\n\n    stats['sdk.' + clientName + '.' + app_1.default.SDK_VERSION.replace(/\\./g, '-')] = 1;\n\n    if (util_7.isMobileCordova()) {\n      stats['framework.cordova'] = 1;\n    } else if (util_7.isReactNative()) {\n      stats['framework.reactnative'] = 1;\n    }\n\n    this.reportStats(stats);\n  };\n  /**\n   * @return {boolean}\n   * @private\n   */\n\n\n  PersistentConnection.prototype.shouldReconnect_ = function () {\n    var online = OnlineMonitor_1.OnlineMonitor.getInstance().currentlyOnline();\n    return util_1.isEmpty(this.interruptReasons_) && online;\n  };\n  /**\n   * @private\n   */\n\n\n  PersistentConnection.nextPersistentConnectionId_ = 0;\n  /**\n   * Counter for number of connections created. Mainly used for tagging in the logs\n   * @type {number}\n   * @private\n   */\n\n  PersistentConnection.nextConnectionId_ = 0;\n  return PersistentConnection;\n}(ServerActions_1.ServerActions);\n\nexports.PersistentConnection = PersistentConnection;","map":{"version":3,"mappings":"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","names":["RECONNECT_MIN_DELAY","RECONNECT_MAX_DELAY_DEFAULT","RECONNECT_MAX_DELAY_FOR_ADMINS","RECONNECT_DELAY_MULTIPLIER","RECONNECT_DELAY_RESET_TIMEOUT","SERVER_KILL_INTERRUPT_REASON","INVALID_AUTH_TOKEN_THRESHOLD","__extends","repoInfo_","onDataUpdate_","onConnectStatus_","onServerInfoUpdate_","authTokenProvider_","authOverride_","_super","_this","PersistentConnection","nextPersistentConnectionId_","util_4","id","util_7","Error","scheduleConnect_","VisibilityMonitor_1","getInstance","on","onVisible_","host","indexOf","OnlineMonitor_1","onOnline_","action","body","onResponse","curReqNum","requestNumber_","msg","r","a","b","log_","util_2","util_3","connected_","realtime_","sendRequest","requestCBHash_","query","currentHashFn","tag","onComplete","queryId","queryIdentifier","pathString","path","toString","listens_","getQueryParams","isDefault","loadsAllData","listenSpec","hashFn","sendListen_","req","p","queryObject","message","payload","status","warnOnListenWarnings_","currentListenSpec","removeListen_","util_1","warnings","Array","isArray","indexSpec","getIndex","indexPath","token","authToken_","tryAuth","reduceReconnectDelayIfAdminCredential_","credential","isFirebaseSecret","length","util_5","maxReconnectDelay_","token_1","authMethod","requestData","cred","res","data","invalidAuthTokenCount_","onAuthRevoked_","listen","sendUnlisten_","queryObj","sendOnDisconnect_","onDisconnectRequestQueue_","push","request","d","response","setTimeout","Math","floor","hash","putInternal","undefined","outstandingPuts_","outstandingPutCount_","index","sendPut_","queued","stats","c","result","errorReason","reqNum","onDataPush_","onListenRevoked_","onSecurityDebugPacket_","timestamp","sessionId","lastConnectionEstablishedTime_","Date","getTime","handleTimestamp_","lastSessionId","firstConnection_","sendConnectStats_","restoreState_","timeout","establishConnectionTimer_","clearTimeout","establishConnection_","visible","visible_","reconnectDelay_","online","close","cancelSentTransactions_","shouldReconnect_","lastConnectionAttemptTime_","timeSinceLastConnectSucceeded","timeSinceLastConnectAttempt","reconnectDelay","max","random","min","onDataMessage_1","onDataMessage_","bind","onReady_1","onReady_","onDisconnect_1","onRealtimeDisconnect_","connId_1","nextConnectionId_","self_1","lastSessionId_1","canceled_1","connection_1","closeFn_1","sendRequestFn","forceRefresh","forceTokenRefresh_","getToken","then","accessToken","Connection_1","reason","interrupt","error","util_6","NODE_ADMIN","interruptReasons_","delta","serverTimeOffset","i","put","map","q","join","normalizedPathString","Path_1","statusCode","explanation","notifyForInvalidToken","securityDebugCallback_","console","log","replace","queries","key","shift","clientName","NODE_CLIENT","app_1","SDK_VERSION","reportStats","currentlyOnline","ServerActions_1","exports"],"sources":["../src/core/PersistentConnection.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport { forEach, contains, isEmpty, getCount, safeGet } from '@firebase/util';\nimport { stringify } from '@firebase/util';\nimport { assert } from '@firebase/util';\nimport { error, log, logWrapper, warn, ObjectToUniqueKey } from './util/util';\nimport { Path } from './util/Path';\nimport { VisibilityMonitor } from './util/VisibilityMonitor';\nimport { OnlineMonitor } from './util/OnlineMonitor';\nimport { isAdmin, isValidFormat } from '@firebase/util';\nimport { Connection } from '../realtime/Connection';\nimport { CONSTANTS } from '@firebase/util';\nimport { isMobileCordova, isReactNative, isNodeSdk } from '@firebase/util';\nimport { ServerActions } from './ServerActions';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { RepoInfo } from './RepoInfo';\nimport { Query } from '../api/Query';\n\nconst RECONNECT_MIN_DELAY = 1000;\nconst RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\nconst RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nconst RECONNECT_DELAY_MULTIPLIER = 1.3;\nconst RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nconst SERVER_KILL_INTERRUPT_REASON = 'server_kill';\n\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nconst INVALID_AUTH_TOKEN_THRESHOLD = 3;\n\ninterface ListenSpec {\n  onComplete(s: string, p?: any): void;\n\n  hashFn(): string;\n\n  query: Query;\n  tag: number | null;\n}\n\ninterface OnDisconnectRequest {\n  pathString: string;\n  action: string;\n  data: any;\n  onComplete?: (a: string, b: string) => void;\n}\n\ninterface OutstandingPut {\n  action: string;\n  request: Object;\n  queued?: boolean;\n  onComplete: (a: string, b?: string) => void;\n}\n\n/**\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\n *\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\n * in quotes to make sure the closure compiler does not minify them.\n */\nexport class PersistentConnection extends ServerActions {\n  // Used for diagnostic logging.\n  id = PersistentConnection.nextPersistentConnectionId_++;\n  private log_ = logWrapper('p:' + this.id + ':');\n\n  /** @private {Object} */\n  private interruptReasons_: { [reason: string]: boolean } = {};\n  private listens_: { [path: string]: { [queryId: string]: ListenSpec } } = {};\n  private outstandingPuts_: OutstandingPut[] = [];\n  private outstandingPutCount_ = 0;\n  private onDisconnectRequestQueue_: OnDisconnectRequest[] = [];\n  private connected_ = false;\n  private reconnectDelay_ = RECONNECT_MIN_DELAY;\n  private maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n  private securityDebugCallback_: ((a: Object) => void) | null = null;\n  lastSessionId: string | null = null;\n\n  /** @private {number|null} */\n  private establishConnectionTimer_: number | null = null;\n\n  /** @private {boolean} */\n  private visible_: boolean = false;\n\n  // Before we get connected, we keep a queue of pending messages to send.\n  private requestCBHash_: { [k: number]: (a: any) => void } = {};\n  private requestNumber_ = 0;\n\n  /** @private {?{\n   *   sendRequest(Object),\n   *   close()\n   * }} */\n  private realtime_: {\n    sendRequest(a: Object): void;\n    close(): void;\n  } | null = null;\n\n  /** @private {string|null} */\n  private authToken_: string | null = null;\n  private forceTokenRefresh_ = false;\n  private invalidAuthTokenCount_ = 0;\n\n  private firstConnection_ = true;\n  private lastConnectionAttemptTime_: number | null = null;\n  private lastConnectionEstablishedTime_: number | null = null;\n\n  /**\n   * @private\n   */\n  private static nextPersistentConnectionId_ = 0;\n\n  /**\n   * Counter for number of connections created. Mainly used for tagging in the logs\n   * @type {number}\n   * @private\n   */\n  private static nextConnectionId_ = 0;\n\n  /**\n   * @implements {ServerActions}\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param onConnectStatus_\n   * @param onServerInfoUpdate_\n   * @param authTokenProvider_\n   * @param authOverride_\n   */\n  constructor(\n    private repoInfo_: RepoInfo,\n    private onDataUpdate_: (\n      a: string,\n      b: any,\n      c: boolean,\n      d: number | null\n    ) => void,\n    private onConnectStatus_: (a: boolean) => void,\n    private onServerInfoUpdate_: (a: any) => void,\n    private authTokenProvider_: AuthTokenProvider,\n    private authOverride_?: Object | null\n  ) {\n    super();\n\n    if (authOverride_ && !isNodeSdk()) {\n      throw new Error(\n        'Auth override specified in options, but not supported on non Node.js platforms'\n      );\n    }\n    this.scheduleConnect_(0);\n\n    VisibilityMonitor.getInstance().on('visible', this.onVisible_, this);\n\n    if (repoInfo_.host.indexOf('fblocal') === -1) {\n      OnlineMonitor.getInstance().on('online', this.onOnline_, this);\n    }\n  }\n\n  /**\n   * @param {!string} action\n   * @param {*} body\n   * @param {function(*)=} onResponse\n   * @protected\n   */\n  protected sendRequest(\n    action: string,\n    body: any,\n    onResponse?: (a: any) => void\n  ) {\n    const curReqNum = ++this.requestNumber_;\n\n    const msg = { r: curReqNum, a: action, b: body };\n    this.log_(stringify(msg));\n    assert(\n      this.connected_,\n      \"sendRequest call when we're not connected not allowed.\"\n    );\n    this.realtime_.sendRequest(msg);\n    if (onResponse) {\n      this.requestCBHash_[curReqNum] = onResponse;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  listen(\n    query: Query,\n    currentHashFn: () => string,\n    tag: number | null,\n    onComplete: (a: string, b: any) => void\n  ) {\n    const queryId = query.queryIdentifier();\n    const pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + queryId);\n    this.listens_[pathString] = this.listens_[pathString] || {};\n    assert(\n      query.getQueryParams().isDefault() ||\n        !query.getQueryParams().loadsAllData(),\n      'listen() called for non-default but complete query'\n    );\n    assert(\n      !this.listens_[pathString][queryId],\n      'listen() called twice for same path/queryId.'\n    );\n    const listenSpec: ListenSpec = {\n      onComplete: onComplete,\n      hashFn: currentHashFn,\n      query: query,\n      tag: tag\n    };\n    this.listens_[pathString][queryId] = listenSpec;\n\n    if (this.connected_) {\n      this.sendListen_(listenSpec);\n    }\n  }\n\n  /**\n   * @param {!{onComplete(),\n   *           hashFn():!string,\n   *           query: !Query,\n   *           tag: ?number}} listenSpec\n   * @private\n   */\n  private sendListen_(listenSpec: ListenSpec) {\n    const query = listenSpec.query;\n    const pathString = query.path.toString();\n    const queryId = query.queryIdentifier();\n    this.log_('Listen on ' + pathString + ' for ' + queryId);\n    const req: { [k: string]: any } = { /*path*/ p: pathString };\n\n    const action = 'q';\n\n    // Only bother to send query if it's non-default.\n    if (listenSpec.tag) {\n      req['q'] = query.queryObject();\n      req['t'] = listenSpec.tag;\n    }\n\n    req[/*hash*/ 'h'] = listenSpec.hashFn();\n\n    this.sendRequest(action, req, (message: { [k: string]: any }) => {\n      const payload: any = message[/*data*/ 'd'];\n      const status: string = message[/*status*/ 's'];\n\n      // print warnings in any case...\n      PersistentConnection.warnOnListenWarnings_(payload, query);\n\n      const currentListenSpec =\n        this.listens_[pathString] && this.listens_[pathString][queryId];\n      // only trigger actions if the listen hasn't been removed and readded\n      if (currentListenSpec === listenSpec) {\n        this.log_('listen response', message);\n\n        if (status !== 'ok') {\n          this.removeListen_(pathString, queryId);\n        }\n\n        if (listenSpec.onComplete) {\n          listenSpec.onComplete(status, payload);\n        }\n      }\n    });\n  }\n\n  /**\n   * @param {*} payload\n   * @param {!Query} query\n   * @private\n   */\n  private static warnOnListenWarnings_(payload: any, query: Query) {\n    if (payload && typeof payload === 'object' && contains(payload, 'w')) {\n      const warnings = safeGet(payload, 'w');\n      if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\n        const indexSpec =\n          '\".indexOn\": \"' +\n          query\n            .getQueryParams()\n            .getIndex()\n            .toString() +\n          '\"';\n        const indexPath = query.path.toString();\n        warn(\n          `Using an unspecified index. Your data will be downloaded and ` +\n            `filtered on the client. Consider adding ${indexSpec} at ` +\n            `${indexPath} to your security rules for better performance.`\n        );\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  refreshAuthToken(token: string) {\n    this.authToken_ = token;\n    this.log_('Auth token refreshed');\n    if (this.authToken_) {\n      this.tryAuth();\n    } else {\n      //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n      //the credential so we dont become authenticated next time we connect.\n      if (this.connected_) {\n        this.sendRequest('unauth', {}, () => {});\n      }\n    }\n\n    this.reduceReconnectDelayIfAdminCredential_(token);\n  }\n\n  /**\n   * @param {!string} credential\n   * @private\n   */\n  private reduceReconnectDelayIfAdminCredential_(credential: string) {\n    // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n    // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n    const isFirebaseSecret = credential && credential.length === 40;\n    if (isFirebaseSecret || isAdmin(credential)) {\n      this.log_(\n        'Admin auth credential detected.  Reducing max reconnect time.'\n      );\n      this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n    }\n  }\n\n  /**\n   * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\n   * a auth revoked (the connection is closed).\n   */\n  tryAuth() {\n    if (this.connected_ && this.authToken_) {\n      const token = this.authToken_;\n      const authMethod = isValidFormat(token) ? 'auth' : 'gauth';\n      const requestData: { [k: string]: any } = { cred: token };\n      if (this.authOverride_ === null) {\n        requestData['noauth'] = true;\n      } else if (typeof this.authOverride_ === 'object') {\n        requestData['authvar'] = this.authOverride_;\n      }\n      this.sendRequest(authMethod, requestData, (res: { [k: string]: any }) => {\n        const status: string = res[/*status*/ 's'];\n        const data: string = res[/*data*/ 'd'] || 'error';\n\n        if (this.authToken_ === token) {\n          if (status === 'ok') {\n            this.invalidAuthTokenCount_ = 0;\n          } else {\n            // Triggers reconnect and force refresh for auth token\n            this.onAuthRevoked_(status, data);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  unlisten(query: Query, tag: number | null) {\n    const pathString = query.path.toString();\n    const queryId = query.queryIdentifier();\n\n    this.log_('Unlisten called for ' + pathString + ' ' + queryId);\n\n    assert(\n      query.getQueryParams().isDefault() ||\n        !query.getQueryParams().loadsAllData(),\n      'unlisten() called for non-default but complete query'\n    );\n    const listen = this.removeListen_(pathString, queryId);\n    if (listen && this.connected_) {\n      this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);\n    }\n  }\n\n  private sendUnlisten_(\n    pathString: string,\n    queryId: string,\n    queryObj: Object,\n    tag: number | null\n  ) {\n    this.log_('Unlisten on ' + pathString + ' for ' + queryId);\n\n    const req: { [k: string]: any } = { /*path*/ p: pathString };\n    const action = 'n';\n    // Only bother sending queryId if it's non-default.\n    if (tag) {\n      req['q'] = queryObj;\n      req['t'] = tag;\n    }\n\n    this.sendRequest(action, req);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectPut(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('o', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'o',\n        data,\n        onComplete\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectMerge(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('om', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'om',\n        data,\n        onComplete\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectCancel(\n    pathString: string,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('oc', pathString, null, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'oc',\n        data: null,\n        onComplete\n      });\n    }\n  }\n\n  private sendOnDisconnect_(\n    action: string,\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string) => void\n  ) {\n    const request = { /*path*/ p: pathString, /*data*/ d: data };\n    this.log_('onDisconnect ' + action, request);\n    this.sendRequest(action, request, (response: { [k: string]: any }) => {\n      if (onComplete) {\n        setTimeout(function() {\n          onComplete(response[/*status*/ 's'], response[/* data */ 'd']);\n        }, Math.floor(0));\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  put(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void,\n    hash?: string\n  ) {\n    this.putInternal('p', pathString, data, onComplete, hash);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  merge(\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string | null) => void,\n    hash?: string\n  ) {\n    this.putInternal('m', pathString, data, onComplete, hash);\n  }\n\n  putInternal(\n    action: string,\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string | null) => void,\n    hash?: string\n  ) {\n    const request: { [k: string]: any } = {\n      /*path*/ p: pathString,\n      /*data*/ d: data\n    };\n\n    if (hash !== undefined) request[/*hash*/ 'h'] = hash;\n\n    // TODO: Only keep track of the most recent put for a given path?\n    this.outstandingPuts_.push({\n      action,\n      request,\n      onComplete\n    });\n\n    this.outstandingPutCount_++;\n    const index = this.outstandingPuts_.length - 1;\n\n    if (this.connected_) {\n      this.sendPut_(index);\n    } else {\n      this.log_('Buffering put: ' + pathString);\n    }\n  }\n\n  private sendPut_(index: number) {\n    const action = this.outstandingPuts_[index].action;\n    const request = this.outstandingPuts_[index].request;\n    const onComplete = this.outstandingPuts_[index].onComplete;\n    this.outstandingPuts_[index].queued = this.connected_;\n\n    this.sendRequest(action, request, (message: { [k: string]: any }) => {\n      this.log_(action + ' response', message);\n\n      delete this.outstandingPuts_[index];\n      this.outstandingPutCount_--;\n\n      // Clean up array occasionally.\n      if (this.outstandingPutCount_ === 0) {\n        this.outstandingPuts_ = [];\n      }\n\n      if (onComplete)\n        onComplete(message[/*status*/ 's'], message[/* data */ 'd']);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  reportStats(stats: { [k: string]: any }) {\n    // If we're not connected, we just drop the stats.\n    if (this.connected_) {\n      const request = { /*counters*/ c: stats };\n      this.log_('reportStats', request);\n\n      this.sendRequest(/*stats*/ 's', request, result => {\n        const status = result[/*status*/ 's'];\n        if (status !== 'ok') {\n          const errorReason = result[/* data */ 'd'];\n          this.log_('reportStats', 'Error sending stats: ' + errorReason);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param {*} message\n   * @private\n   */\n  private onDataMessage_(message: { [k: string]: any }) {\n    if ('r' in message) {\n      // this is a response\n      this.log_('from server: ' + stringify(message));\n      const reqNum = message['r'];\n      const onResponse = this.requestCBHash_[reqNum];\n      if (onResponse) {\n        delete this.requestCBHash_[reqNum];\n        onResponse(message[/*body*/ 'b']);\n      }\n    } else if ('error' in message) {\n      throw 'A server-side error has occurred: ' + message['error'];\n    } else if ('a' in message) {\n      // a and b are action and body, respectively\n      this.onDataPush_(message['a'], message['b']);\n    }\n  }\n\n  private onDataPush_(action: string, body: { [k: string]: any }) {\n    this.log_('handleServerMessage', action, body);\n    if (action === 'd')\n      this.onDataUpdate_(\n        body[/*path*/ 'p'],\n        body[/*data*/ 'd'],\n        /*isMerge*/ false,\n        body['t']\n      );\n    else if (action === 'm')\n      this.onDataUpdate_(\n        body[/*path*/ 'p'],\n        body[/*data*/ 'd'],\n        /*isMerge=*/ true,\n        body['t']\n      );\n    else if (action === 'c')\n      this.onListenRevoked_(body[/*path*/ 'p'], body[/*query*/ 'q']);\n    else if (action === 'ac')\n      this.onAuthRevoked_(\n        body[/*status code*/ 's'],\n        body[/* explanation */ 'd']\n      );\n    else if (action === 'sd') this.onSecurityDebugPacket_(body);\n    else\n      error(\n        'Unrecognized action received from server: ' +\n          stringify(action) +\n          '\\nAre you using the latest client?'\n      );\n  }\n\n  private onReady_(timestamp: number, sessionId: string) {\n    this.log_('connection ready');\n    this.connected_ = true;\n    this.lastConnectionEstablishedTime_ = new Date().getTime();\n    this.handleTimestamp_(timestamp);\n    this.lastSessionId = sessionId;\n    if (this.firstConnection_) {\n      this.sendConnectStats_();\n    }\n    this.restoreState_();\n    this.firstConnection_ = false;\n    this.onConnectStatus_(true);\n  }\n\n  private scheduleConnect_(timeout: number) {\n    assert(\n      !this.realtime_,\n      \"Scheduling a connect when we're already connected/ing?\"\n    );\n\n    if (this.establishConnectionTimer_) {\n      clearTimeout(this.establishConnectionTimer_);\n    }\n\n    // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n    // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n\n    this.establishConnectionTimer_ = setTimeout(() => {\n      this.establishConnectionTimer_ = null;\n      this.establishConnection_();\n    }, Math.floor(timeout)) as any;\n  }\n\n  /**\n   * @param {boolean} visible\n   * @private\n   */\n  private onVisible_(visible: boolean) {\n    // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n    if (\n      visible &&\n      !this.visible_ &&\n      this.reconnectDelay_ === this.maxReconnectDelay_\n    ) {\n      this.log_('Window became visible.  Reducing delay.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n    this.visible_ = visible;\n  }\n\n  private onOnline_(online: boolean) {\n    if (online) {\n      this.log_('Browser went online.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    } else {\n      this.log_('Browser went offline.  Killing connection.');\n      if (this.realtime_) {\n        this.realtime_.close();\n      }\n    }\n  }\n\n  private onRealtimeDisconnect_() {\n    this.log_('data client disconnected');\n    this.connected_ = false;\n    this.realtime_ = null;\n\n    // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n    this.cancelSentTransactions_();\n\n    // Clear out the pending requests.\n    this.requestCBHash_ = {};\n\n    if (this.shouldReconnect_()) {\n      if (!this.visible_) {\n        this.log_(\"Window isn't visible.  Delaying reconnect.\");\n        this.reconnectDelay_ = this.maxReconnectDelay_;\n        this.lastConnectionAttemptTime_ = new Date().getTime();\n      } else if (this.lastConnectionEstablishedTime_) {\n        // If we've been connected long enough, reset reconnect delay to minimum.\n        const timeSinceLastConnectSucceeded =\n          new Date().getTime() - this.lastConnectionEstablishedTime_;\n        if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT)\n          this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        this.lastConnectionEstablishedTime_ = null;\n      }\n\n      const timeSinceLastConnectAttempt =\n        new Date().getTime() - this.lastConnectionAttemptTime_;\n      let reconnectDelay = Math.max(\n        0,\n        this.reconnectDelay_ - timeSinceLastConnectAttempt\n      );\n      reconnectDelay = Math.random() * reconnectDelay;\n\n      this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\n      this.scheduleConnect_(reconnectDelay);\n\n      // Adjust reconnect delay for next time.\n      this.reconnectDelay_ = Math.min(\n        this.maxReconnectDelay_,\n        this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER\n      );\n    }\n    this.onConnectStatus_(false);\n  }\n\n  private establishConnection_() {\n    if (this.shouldReconnect_()) {\n      this.log_('Making a connection attempt');\n      this.lastConnectionAttemptTime_ = new Date().getTime();\n      this.lastConnectionEstablishedTime_ = null;\n      const onDataMessage = this.onDataMessage_.bind(this);\n      const onReady = this.onReady_.bind(this);\n      const onDisconnect = this.onRealtimeDisconnect_.bind(this);\n      const connId = this.id + ':' + PersistentConnection.nextConnectionId_++;\n      const self = this;\n      const lastSessionId = this.lastSessionId;\n      let canceled = false;\n      let connection: Connection | null = null;\n      const closeFn = function() {\n        if (connection) {\n          connection.close();\n        } else {\n          canceled = true;\n          onDisconnect();\n        }\n      };\n      const sendRequestFn = function(msg: Object) {\n        assert(\n          connection,\n          \"sendRequest call when we're not connected not allowed.\"\n        );\n        connection.sendRequest(msg);\n      };\n\n      this.realtime_ = {\n        close: closeFn,\n        sendRequest: sendRequestFn\n      };\n\n      const forceRefresh = this.forceTokenRefresh_;\n      this.forceTokenRefresh_ = false;\n\n      // First fetch auth token, and establish connection after fetching the token was successful\n      this.authTokenProvider_\n        .getToken(forceRefresh)\n        .then(function(result) {\n          if (!canceled) {\n            log('getToken() completed. Creating connection.');\n            self.authToken_ = result && result.accessToken;\n            connection = new Connection(\n              connId,\n              self.repoInfo_,\n              onDataMessage,\n              onReady,\n              onDisconnect,\n              /* onKill= */ function(reason) {\n                warn(reason + ' (' + self.repoInfo_.toString() + ')');\n                self.interrupt(SERVER_KILL_INTERRUPT_REASON);\n              },\n              lastSessionId\n            );\n          } else {\n            log('getToken() completed but was canceled');\n          }\n        })\n        .then(null, function(error) {\n          self.log_('Failed to get token: ' + error);\n          if (!canceled) {\n            if (CONSTANTS.NODE_ADMIN) {\n              // This may be a critical error for the Admin Node.js SDK, so log a warning.\n              // But getToken() may also just have temporarily failed, so we still want to\n              // continue retrying.\n              warn(error);\n            }\n            closeFn();\n          }\n        });\n    }\n  }\n\n  /**\n   * @param {string} reason\n   */\n  interrupt(reason: string) {\n    log('Interrupting connection for reason: ' + reason);\n    this.interruptReasons_[reason] = true;\n    if (this.realtime_) {\n      this.realtime_.close();\n    } else {\n      if (this.establishConnectionTimer_) {\n        clearTimeout(this.establishConnectionTimer_);\n        this.establishConnectionTimer_ = null;\n      }\n      if (this.connected_) {\n        this.onRealtimeDisconnect_();\n      }\n    }\n  }\n\n  /**\n   * @param {string} reason\n   */\n  resume(reason: string) {\n    log('Resuming connection for reason: ' + reason);\n    delete this.interruptReasons_[reason];\n    if (isEmpty(this.interruptReasons_)) {\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n  }\n\n  private handleTimestamp_(timestamp: number) {\n    const delta = timestamp - new Date().getTime();\n    this.onServerInfoUpdate_({ serverTimeOffset: delta });\n  }\n\n  private cancelSentTransactions_() {\n    for (let i = 0; i < this.outstandingPuts_.length; i++) {\n      const put = this.outstandingPuts_[i];\n      if (put && /*hash*/ 'h' in put.request && put.queued) {\n        if (put.onComplete) put.onComplete('disconnect');\n\n        delete this.outstandingPuts_[i];\n        this.outstandingPutCount_--;\n      }\n    }\n\n    // Clean up array occasionally.\n    if (this.outstandingPutCount_ === 0) this.outstandingPuts_ = [];\n  }\n\n  /**\n   * @param {!string} pathString\n   * @param {Array.<*>=} query\n   * @private\n   */\n  private onListenRevoked_(pathString: string, query?: any[]) {\n    // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n    let queryId;\n    if (!query) {\n      queryId = 'default';\n    } else {\n      queryId = query.map(q => ObjectToUniqueKey(q)).join('$');\n    }\n    const listen = this.removeListen_(pathString, queryId);\n    if (listen && listen.onComplete) listen.onComplete('permission_denied');\n  }\n\n  /**\n   * @param {!string} pathString\n   * @param {!string} queryId\n   * @return {{queries:Array.<Query>, onComplete:function(string)}}\n   * @private\n   */\n  private removeListen_(pathString: string, queryId: string): ListenSpec {\n    const normalizedPathString = new Path(pathString).toString(); // normalize path.\n    let listen;\n    if (this.listens_[normalizedPathString] !== undefined) {\n      listen = this.listens_[normalizedPathString][queryId];\n      delete this.listens_[normalizedPathString][queryId];\n      if (getCount(this.listens_[normalizedPathString]) === 0) {\n        delete this.listens_[normalizedPathString];\n      }\n    } else {\n      // all listens for this path has already been removed\n      listen = undefined;\n    }\n    return listen;\n  }\n\n  private onAuthRevoked_(statusCode: string, explanation: string) {\n    log('Auth token revoked: ' + statusCode + '/' + explanation);\n    this.authToken_ = null;\n    this.forceTokenRefresh_ = true;\n    this.realtime_.close();\n    if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\n      // We'll wait a couple times before logging the warning / increasing the\n      // retry period since oauth tokens will report as \"invalid\" if they're\n      // just expired. Plus there may be transient issues that resolve themselves.\n      this.invalidAuthTokenCount_++;\n      if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {\n        // Set a long reconnect delay because recovery is unlikely\n        this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n\n        // Notify the auth token provider that the token is invalid, which will log\n        // a warning\n        this.authTokenProvider_.notifyForInvalidToken();\n      }\n    }\n  }\n\n  private onSecurityDebugPacket_(body: { [k: string]: any }) {\n    if (this.securityDebugCallback_) {\n      this.securityDebugCallback_(body);\n    } else {\n      if ('msg' in body && typeof console !== 'undefined') {\n        console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\n      }\n    }\n  }\n\n  private restoreState_() {\n    //Re-authenticate ourselves if we have a credential stored.\n    this.tryAuth();\n\n    // Puts depend on having received the corresponding data update from the server before they complete, so we must\n    // make sure to send listens before puts.\n    forEach(this.listens_, (pathString: string, queries: Object) => {\n      forEach(queries, (key: string, listenSpec: ListenSpec) => {\n        this.sendListen_(listenSpec);\n      });\n    });\n\n    for (let i = 0; i < this.outstandingPuts_.length; i++) {\n      if (this.outstandingPuts_[i]) this.sendPut_(i);\n    }\n\n    while (this.onDisconnectRequestQueue_.length) {\n      const request = this.onDisconnectRequestQueue_.shift();\n      this.sendOnDisconnect_(\n        request.action,\n        request.pathString,\n        request.data,\n        request.onComplete\n      );\n    }\n  }\n\n  /**\n   * Sends client stats for first connection\n   * @private\n   */\n  private sendConnectStats_() {\n    const stats: { [k: string]: number } = {};\n\n    let clientName = 'js';\n    if (CONSTANTS.NODE_ADMIN) {\n      clientName = 'admin_node';\n    } else if (CONSTANTS.NODE_CLIENT) {\n      clientName = 'node';\n    }\n\n    stats[\n      'sdk.' + clientName + '.' + firebase.SDK_VERSION.replace(/\\./g, '-')\n    ] = 1;\n\n    if (isMobileCordova()) {\n      stats['framework.cordova'] = 1;\n    } else if (isReactNative()) {\n      stats['framework.reactnative'] = 1;\n    }\n    this.reportStats(stats);\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  private shouldReconnect_(): boolean {\n    const online = OnlineMonitor.getInstance().currentlyOnline();\n    return isEmpty(this.interruptReasons_) && online;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}