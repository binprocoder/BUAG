{"ast":null,"code":"/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * @param f May be invoked\r\n *     before the function returns.\r\n * @param callback Get all the arguments passed to the function\r\n *     passed to f, including the initial boolean.\r\n */\nexport function start(f, callback, timeout) {\n  // TODO(andysoto): make this code cleaner (probably refactor into an actual\n  // type instead of a bunch of functions with state shared in the closure)\n  var waitSeconds = 1; // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n\n  var timeoutId = null;\n  var hitTimeout = false;\n  var cancelState = 0;\n\n  function canceled() {\n    return cancelState === 2;\n  }\n\n  var triggeredCallback = false;\n\n  function triggerCallback() {\n    if (!triggeredCallback) {\n      triggeredCallback = true;\n      callback.apply(null, arguments);\n    }\n  }\n\n  function callWithDelay(millis) {\n    timeoutId = setTimeout(function () {\n      timeoutId = null;\n      f(handler, canceled());\n    }, millis);\n  }\n\n  function handler(success) {\n    var var_args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      var_args[_i - 1] = arguments[_i];\n    }\n\n    if (triggeredCallback) {\n      return;\n    }\n\n    if (success) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n\n    var mustStop = canceled() || hitTimeout;\n\n    if (mustStop) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n\n    if (waitSeconds < 64) {\n      /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n      waitSeconds *= 2;\n    }\n\n    var waitMillis;\n\n    if (cancelState === 1) {\n      cancelState = 2;\n      waitMillis = 0;\n    } else {\n      waitMillis = (waitSeconds + Math.random()) * 1000;\n    }\n\n    callWithDelay(waitMillis);\n  }\n\n  var stopped = false;\n\n  function stop(wasTimeout) {\n    if (stopped) {\n      return;\n    }\n\n    stopped = true;\n\n    if (triggeredCallback) {\n      return;\n    }\n\n    if (timeoutId !== null) {\n      if (!wasTimeout) {\n        cancelState = 2;\n      }\n\n      clearTimeout(timeoutId);\n      callWithDelay(0);\n    } else {\n      if (!wasTimeout) {\n        cancelState = 1;\n      }\n    }\n  }\n\n  callWithDelay(0);\n  setTimeout(function () {\n    hitTimeout = true;\n    stop(true);\n  }, timeout);\n  return stop;\n}\n/**\r\n * Stops the retry loop from repeating.\r\n * If the function is currently \"in between\" retries, it is invoked immediately\r\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\r\n * after the current invocation finishes iff the current invocation would have\r\n * triggered another retry.\r\n */\n\nexport function stop(id) {\n  id(false);\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAwBA;;;;;;AAMA,OAAM,eACJA,CADI,EAKJC,QALI,EAMJC,OANI,EAMW;AAEf;AACA;AACA,MAAIC,WAAW,GAAG,CAAlB,CAJe,CAKf;;AACA,MAAIC,SAAS,GAAQ,IAArB;AACA,MAAIC,UAAU,GAAG,KAAjB;AACA,MAAIC,WAAW,GAAG,CAAlB;;AAEA;AACE,WAAOA,WAAW,KAAK,CAAvB;AACD;;AACD,MAAIC,iBAAiB,GAAG,KAAxB;;AAEA;AACE,QAAI,CAACA,iBAAL,EAAwB;AACtBA,uBAAiB,GAAG,IAApB;AACAN,cAAQ,CAACO,KAAT,CAAe,IAAf,EAAqBC,SAArB;AACD;AACF;;AAED,yBAAuBC,MAAvB,EAAqC;AACnCN,aAAS,GAAGO,UAAU,CAAC;AACrBP,eAAS,GAAG,IAAZ;AACAJ,OAAC,CAACY,OAAD,EAAUC,QAAQ,EAAlB,CAAD;AACD,KAHqB,EAGnBH,MAHmB,CAAtB;AAID;;AAED,mBAAiBI,OAAjB,EAAiC;AAAE;;SAAA,yCAAkB;AAAlBC;;;AACjC,QAAIR,iBAAJ,EAAuB;AACrB;AACD;;AACD,QAAIO,OAAJ,EAAa;AACXE,qBAAe,CAACR,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B;AACA;AACD;;AACD,QAAIQ,QAAQ,GAAGJ,QAAQ,MAAMR,UAA7B;;AACA,QAAIY,QAAJ,EAAc;AACZD,qBAAe,CAACR,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B;AACA;AACD;;AACD,QAAIN,WAAW,GAAG,EAAlB,EAAsB;AACpB;AACAA,iBAAW,IAAI,CAAf;AACD;;AACD,QAAIe,UAAJ;;AACA,QAAIZ,WAAW,KAAK,CAApB,EAAuB;AACrBA,iBAAW,GAAG,CAAd;AACAY,gBAAU,GAAG,CAAb;AACD,KAHD,MAGO;AACLA,gBAAU,GAAG,CAACf,WAAW,GAAGgB,IAAI,CAACC,MAAL,EAAf,IAAgC,IAA7C;AACD;;AACDC,iBAAa,CAACH,UAAD,CAAb;AACD;;AACD,MAAII,OAAO,GAAG,KAAd;;AAEA,gBAAcC,UAAd,EAAiC;AAC/B,QAAID,OAAJ,EAAa;AACX;AACD;;AACDA,WAAO,GAAG,IAAV;;AACA,QAAIf,iBAAJ,EAAuB;AACrB;AACD;;AACD,QAAIH,SAAS,KAAK,IAAlB,EAAwB;AACtB,UAAI,CAACmB,UAAL,EAAiB;AACfjB,mBAAW,GAAG,CAAd;AACD;;AACDkB,kBAAY,CAACpB,SAAD,CAAZ;AACAiB,mBAAa,CAAC,CAAD,CAAb;AACD,KAND,MAMO;AACL,UAAI,CAACE,UAAL,EAAiB;AACfjB,mBAAW,GAAG,CAAd;AACD;AACF;AACF;;AACDe,eAAa,CAAC,CAAD,CAAb;AACAV,YAAU,CAAC;AACTN,cAAU,GAAG,IAAb;AACAoB,QAAI,CAAC,IAAD,CAAJ;AACD,GAHS,EAGPvB,OAHO,CAAV;AAIA,SAAOuB,IAAP;AACD;AAED;;;;;;;;AAOA,OAAM,cAAeC,EAAf,EAAqB;AACzBA,IAAE,CAAC,KAAD,CAAF;AACD","names":["f","callback","timeout","waitSeconds","timeoutId","hitTimeout","cancelState","triggeredCallback","apply","arguments","millis","setTimeout","handler","canceled","success","var_args","triggerCallback","mustStop","waitMillis","Math","random","callWithDelay","stopped","wasTimeout","clearTimeout","stop","id"],"sources":["../src/implementation/backoff.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Provides a method for running a function with exponential\n * backoff.\n */\ntype id = (p1: boolean) => void;\n\nexport { id };\n\n/**\n * @param f May be invoked\n *     before the function returns.\n * @param callback Get all the arguments passed to the function\n *     passed to f, including the initial boolean.\n */\nexport function start(\n  f: (\n    p1: (success: boolean, ...rest: any[]) => void,\n    canceled: boolean\n  ) => void,\n  callback: Function,\n  timeout: number\n): id {\n  // TODO(andysoto): make this code cleaner (probably refactor into an actual\n  // type instead of a bunch of functions with state shared in the closure)\n  let waitSeconds = 1;\n  // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n  let timeoutId: any = null;\n  let hitTimeout = false;\n  let cancelState = 0;\n\n  function canceled() {\n    return cancelState === 2;\n  }\n  let triggeredCallback = false;\n\n  function triggerCallback() {\n    if (!triggeredCallback) {\n      triggeredCallback = true;\n      callback.apply(null, arguments);\n    }\n  }\n\n  function callWithDelay(millis: number): void {\n    timeoutId = setTimeout(function() {\n      timeoutId = null;\n      f(handler, canceled());\n    }, millis);\n  }\n\n  function handler(success: boolean, ...var_args: any[]): void {\n    if (triggeredCallback) {\n      return;\n    }\n    if (success) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    let mustStop = canceled() || hitTimeout;\n    if (mustStop) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    if (waitSeconds < 64) {\n      /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n      waitSeconds *= 2;\n    }\n    let waitMillis;\n    if (cancelState === 1) {\n      cancelState = 2;\n      waitMillis = 0;\n    } else {\n      waitMillis = (waitSeconds + Math.random()) * 1000;\n    }\n    callWithDelay(waitMillis);\n  }\n  let stopped = false;\n\n  function stop(wasTimeout: boolean): void {\n    if (stopped) {\n      return;\n    }\n    stopped = true;\n    if (triggeredCallback) {\n      return;\n    }\n    if (timeoutId !== null) {\n      if (!wasTimeout) {\n        cancelState = 2;\n      }\n      clearTimeout(timeoutId);\n      callWithDelay(0);\n    } else {\n      if (!wasTimeout) {\n        cancelState = 1;\n      }\n    }\n  }\n  callWithDelay(0);\n  setTimeout(function() {\n    hitTimeout = true;\n    stop(true);\n  }, timeout);\n  return stop;\n}\n\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\nexport function stop(id: id) {\n  id(false);\n}\n"]},"metadata":{},"sourceType":"module"}