{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n/**\n * Fancy ID generator that creates 20-character string identifiers with the\n * following properties:\n *\n * 1. They're based on timestamp so that they sort *after* any existing ids.\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\n *    collide with other clients' IDs.\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\n *    that will sort properly).\n * 4. They're monotonically increasing. Even if you generate more than one in\n *    the same timestamp, the latter ones will sort after the former ones. We do\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\n *    in the case of a timestamp collision).\n */\n\n\nexports.nextPushId = function () {\n  // Modeled after base64 web-safe chars, but ordered by ASCII.\n  var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'; // Timestamp of last push, used to prevent local collisions if you push twice\n  // in one ms.\n\n  var lastPushTime = 0; // We generate 72-bits of randomness which get turned into 12 characters and\n  // appended to the timestamp to prevent collisions with other clients. We\n  // store the last characters we generated because in the event of a collision,\n  // we'll use those same characters except \"incremented\" by one.\n\n  var lastRandChars = [];\n  return function (now) {\n    var duplicateTime = now === lastPushTime;\n    lastPushTime = now;\n    var i;\n    var timeStampChars = new Array(8);\n\n    for (i = 7; i >= 0; i--) {\n      timeStampChars[i] = PUSH_CHARS.charAt(now % 64); // NOTE: Can't use << here because javascript will convert to int and lose\n      // the upper bits.\n\n      now = Math.floor(now / 64);\n    }\n\n    util_1.assert(now === 0, 'Cannot push at time == 0');\n    var id = timeStampChars.join('');\n\n    if (!duplicateTime) {\n      for (i = 0; i < 12; i++) {\n        lastRandChars[i] = Math.floor(Math.random() * 64);\n      }\n    } else {\n      // If the timestamp hasn't changed since last push, use the same random\n      // number, except incremented by 1.\n      for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n        lastRandChars[i] = 0;\n      }\n\n      lastRandChars[i]++;\n    }\n\n    for (i = 0; i < 12; i++) {\n      id += PUSH_CHARS.charAt(lastRandChars[i]);\n    }\n\n    util_1.assert(id.length === 20, 'nextPushId: Length should be 20.');\n    return id;\n  };\n}();","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA;AAEA;;;;;;;;;;;;;;;;AAcaA,qBAAc;AACzB;AACA,MAAMC,UAAU,GACd,kEADF,CAFyB,CAKzB;AACA;;AACA,MAAIC,YAAY,GAAG,CAAnB,CAPyB,CASzB;AACA;AACA;AACA;;AACA,MAAMC,aAAa,GAAa,EAAhC;AAEA,SAAO,UAASC,GAAT,EAAoB;AACzB,QAAMC,aAAa,GAAGD,GAAG,KAAKF,YAA9B;AACAA,gBAAY,GAAGE,GAAf;AAEA,QAAIE,CAAJ;AACA,QAAMC,cAAc,GAAG,IAAIC,KAAJ,CAAU,CAAV,CAAvB;;AACA,SAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,IAAI,CAAjB,EAAoBA,CAAC,EAArB,EAAyB;AACvBC,oBAAc,CAACD,CAAD,CAAd,GAAoBL,UAAU,CAACQ,MAAX,CAAkBL,GAAG,GAAG,EAAxB,CAApB,CADuB,CAEvB;AACA;;AACAA,SAAG,GAAGM,IAAI,CAACC,KAAL,CAAWP,GAAG,GAAG,EAAjB,CAAN;AACD;;AACDQ,kBAAOR,GAAG,KAAK,CAAf,EAAkB,0BAAlB;AAEA,QAAIS,EAAE,GAAGN,cAAc,CAACO,IAAf,CAAoB,EAApB,CAAT;;AAEA,QAAI,CAACT,aAAL,EAAoB;AAClB,WAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,EAAhB,EAAoBA,CAAC,EAArB,EAAyB;AACvBH,qBAAa,CAACG,CAAD,CAAb,GAAmBI,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACK,MAAL,KAAgB,EAA3B,CAAnB;AACD;AACF,KAJD,MAIO;AACL;AACA;AACA,WAAKT,CAAC,GAAG,EAAT,EAAaA,CAAC,IAAI,CAAL,IAAUH,aAAa,CAACG,CAAD,CAAb,KAAqB,EAA5C,EAAgDA,CAAC,EAAjD,EAAqD;AACnDH,qBAAa,CAACG,CAAD,CAAb,GAAmB,CAAnB;AACD;;AACDH,mBAAa,CAACG,CAAD,CAAb;AACD;;AACD,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,EAAhB,EAAoBA,CAAC,EAArB,EAAyB;AACvBO,QAAE,IAAIZ,UAAU,CAACQ,MAAX,CAAkBN,aAAa,CAACG,CAAD,CAA/B,CAAN;AACD;;AACDM,kBAAOC,EAAE,CAACG,MAAH,KAAc,EAArB,EAAyB,kCAAzB;AAEA,WAAOH,EAAP;AACD,GAlCD;AAmCD,CAlDyB,EAAb","names":["exports","PUSH_CHARS","lastPushTime","lastRandChars","now","duplicateTime","i","timeStampChars","Array","charAt","Math","floor","util_1","id","join","random","length"],"sources":["../src/core/util/NextPushId.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\n\n/**\n * Fancy ID generator that creates 20-character string identifiers with the\n * following properties:\n *\n * 1. They're based on timestamp so that they sort *after* any existing ids.\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\n *    collide with other clients' IDs.\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\n *    that will sort properly).\n * 4. They're monotonically increasing. Even if you generate more than one in\n *    the same timestamp, the latter ones will sort after the former ones. We do\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\n *    in the case of a timestamp collision).\n */\nexport const nextPushId = (function() {\n  // Modeled after base64 web-safe chars, but ordered by ASCII.\n  const PUSH_CHARS =\n    '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\n\n  // Timestamp of last push, used to prevent local collisions if you push twice\n  // in one ms.\n  let lastPushTime = 0;\n\n  // We generate 72-bits of randomness which get turned into 12 characters and\n  // appended to the timestamp to prevent collisions with other clients. We\n  // store the last characters we generated because in the event of a collision,\n  // we'll use those same characters except \"incremented\" by one.\n  const lastRandChars: number[] = [];\n\n  return function(now: number) {\n    const duplicateTime = now === lastPushTime;\n    lastPushTime = now;\n\n    let i;\n    const timeStampChars = new Array(8);\n    for (i = 7; i >= 0; i--) {\n      timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n      // NOTE: Can't use << here because javascript will convert to int and lose\n      // the upper bits.\n      now = Math.floor(now / 64);\n    }\n    assert(now === 0, 'Cannot push at time == 0');\n\n    let id = timeStampChars.join('');\n\n    if (!duplicateTime) {\n      for (i = 0; i < 12; i++) {\n        lastRandChars[i] = Math.floor(Math.random() * 64);\n      }\n    } else {\n      // If the timestamp hasn't changed since last push, use the same random\n      // number, except incremented by 1.\n      for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n        lastRandChars[i] = 0;\n      }\n      lastRandChars[i]++;\n    }\n    for (i = 0; i < 12; i++) {\n      id += PUSH_CHARS.charAt(lastRandChars[i]);\n    }\n    assert(id.length === 20, 'nextPushId: Length should be 20.');\n\n    return id;\n  };\n})();\n"]},"metadata":{},"sourceType":"script"}