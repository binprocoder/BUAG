{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar validation_1 = require(\"../core/util/validation\");\n\nvar Path_1 = require(\"../core/util/Path\");\n\nvar PriorityIndex_1 = require(\"../core/snap/indexes/PriorityIndex\");\n/**\n * Class representing a firebase data snapshot.  It wraps a SnapshotNode and\n * surfaces the public methods (val, forEach, etc.) we want to expose.\n */\n\n\nvar DataSnapshot =\n/** @class */\nfunction () {\n  /**\n   * @param {!Node} node_ A SnapshotNode to wrap.\n   * @param {!Reference} ref_ The ref of the location this snapshot came from.\n   * @param {!Index} index_ The iteration order for this snapshot\n   */\n  function DataSnapshot(node_, ref_, index_) {\n    this.node_ = node_;\n    this.ref_ = ref_;\n    this.index_ = index_;\n  }\n  /**\n   * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is\n   * empty.\n   *\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n\n\n  DataSnapshot.prototype.val = function () {\n    util_1.validateArgCount('DataSnapshot.val', 0, 0, arguments.length);\n    return this.node_.val();\n  };\n  /**\n   * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting\n   * the entire node contents.\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n\n\n  DataSnapshot.prototype.exportVal = function () {\n    util_1.validateArgCount('DataSnapshot.exportVal', 0, 0, arguments.length);\n    return this.node_.val(true);\n  }; // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users\n\n\n  DataSnapshot.prototype.toJSON = function () {\n    // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content\n    util_1.validateArgCount('DataSnapshot.toJSON', 0, 1, arguments.length);\n    return this.exportVal();\n  };\n  /**\n   * Returns whether the snapshot contains a non-null value.\n   *\n   * @return {boolean} Whether the snapshot contains a non-null value, or is empty.\n   */\n\n\n  DataSnapshot.prototype.exists = function () {\n    util_1.validateArgCount('DataSnapshot.exists', 0, 0, arguments.length);\n    return !this.node_.isEmpty();\n  };\n  /**\n   * Returns a DataSnapshot of the specified child node's contents.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {!DataSnapshot} DataSnapshot for child node.\n   */\n\n\n  DataSnapshot.prototype.child = function (childPathString) {\n    util_1.validateArgCount('DataSnapshot.child', 0, 1, arguments.length); // Ensure the childPath is a string (can be a number)\n\n    childPathString = String(childPathString);\n    validation_1.validatePathString('DataSnapshot.child', 1, childPathString, false);\n    var childPath = new Path_1.Path(childPathString);\n    var childRef = this.ref_.child(childPath);\n    return new DataSnapshot(this.node_.getChild(childPath), childRef, PriorityIndex_1.PRIORITY_INDEX);\n  };\n  /**\n   * Returns whether the snapshot contains a child at the specified path.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {boolean} Whether the child exists.\n   */\n\n\n  DataSnapshot.prototype.hasChild = function (childPathString) {\n    util_1.validateArgCount('DataSnapshot.hasChild', 1, 1, arguments.length);\n    validation_1.validatePathString('DataSnapshot.hasChild', 1, childPathString, false);\n    var childPath = new Path_1.Path(childPathString);\n    return !this.node_.getChild(childPath).isEmpty();\n  };\n  /**\n   * Returns the priority of the object, or null if no priority was set.\n   *\n   * @return {string|number|null} The priority.\n   */\n\n\n  DataSnapshot.prototype.getPriority = function () {\n    util_1.validateArgCount('DataSnapshot.getPriority', 0, 0, arguments.length); // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\n\n    return this.node_.getPriority().val();\n  };\n  /**\n   * Iterates through child nodes and calls the specified action for each one.\n   *\n   * @param {function(!DataSnapshot)} action Callback function to be called\n   * for each child.\n   * @return {boolean} True if forEach was canceled by action returning true for\n   * one of the child nodes.\n   */\n\n\n  DataSnapshot.prototype.forEach = function (action) {\n    var _this = this;\n\n    util_1.validateArgCount('DataSnapshot.forEach', 1, 1, arguments.length);\n    util_1.validateCallback('DataSnapshot.forEach', 1, action, false);\n    if (this.node_.isLeafNode()) return false;\n    var childrenNode = this.node_; // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\n\n    return !!childrenNode.forEachChild(this.index_, function (key, node) {\n      return action(new DataSnapshot(node, _this.ref_.child(key), PriorityIndex_1.PRIORITY_INDEX));\n    });\n  };\n  /**\n   * Returns whether this DataSnapshot has children.\n   * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.\n   */\n\n\n  DataSnapshot.prototype.hasChildren = function () {\n    util_1.validateArgCount('DataSnapshot.hasChildren', 0, 0, arguments.length);\n    if (this.node_.isLeafNode()) return false;else return !this.node_.isEmpty();\n  };\n\n  Object.defineProperty(DataSnapshot.prototype, \"key\", {\n    get: function () {\n      return this.ref_.getKey();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns the number of children for this DataSnapshot.\n   * @return {number} The number of children that this DataSnapshot contains.\n   */\n\n  DataSnapshot.prototype.numChildren = function () {\n    util_1.validateArgCount('DataSnapshot.numChildren', 0, 0, arguments.length);\n    return this.node_.numChildren();\n  };\n  /**\n   * @return {Reference} The Firebase reference for the location this snapshot's data came from.\n   */\n\n\n  DataSnapshot.prototype.getRef = function () {\n    util_1.validateArgCount('DataSnapshot.ref', 0, 0, arguments.length);\n    return this.ref_;\n  };\n\n  Object.defineProperty(DataSnapshot.prototype, \"ref\", {\n    get: function () {\n      return this.getRef();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DataSnapshot;\n}();\n\nexports.DataSnapshot = DataSnapshot;","map":{"version":3,"mappings":"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","names":["node_","ref_","index_","DataSnapshot","util_1","arguments","length","val","exportVal","isEmpty","childPathString","String","validation_1","childPath","Path_1","childRef","child","getChild","PriorityIndex_1","getPriority","action","isLeafNode","childrenNode","forEachChild","key","node","_this","Object","getKey","numChildren","getRef","exports"],"sources":["../src/api/DataSnapshot.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { validateArgCount, validateCallback } from '@firebase/util';\nimport { validatePathString } from '../core/util/validation';\nimport { Path } from '../core/util/Path';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { Node } from '../core/snap/Node';\nimport { Reference } from './Reference';\nimport { Index } from '../core/snap/indexes/Index';\nimport { ChildrenNode } from '../core/snap/ChildrenNode';\n\n/**\n * Class representing a firebase data snapshot.  It wraps a SnapshotNode and\n * surfaces the public methods (val, forEach, etc.) we want to expose.\n */\nexport class DataSnapshot {\n  /**\n   * @param {!Node} node_ A SnapshotNode to wrap.\n   * @param {!Reference} ref_ The ref of the location this snapshot came from.\n   * @param {!Index} index_ The iteration order for this snapshot\n   */\n  constructor(\n    private readonly node_: Node,\n    private readonly ref_: Reference,\n    private readonly index_: Index\n  ) {}\n\n  /**\n   * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is\n   * empty.\n   *\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n  val(): any {\n    validateArgCount('DataSnapshot.val', 0, 0, arguments.length);\n    return this.node_.val();\n  }\n\n  /**\n   * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting\n   * the entire node contents.\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n  exportVal(): any {\n    validateArgCount('DataSnapshot.exportVal', 0, 0, arguments.length);\n    return this.node_.val(true);\n  }\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users\n  toJSON(): any {\n    // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content\n    validateArgCount('DataSnapshot.toJSON', 0, 1, arguments.length);\n    return this.exportVal();\n  }\n\n  /**\n   * Returns whether the snapshot contains a non-null value.\n   *\n   * @return {boolean} Whether the snapshot contains a non-null value, or is empty.\n   */\n  exists(): boolean {\n    validateArgCount('DataSnapshot.exists', 0, 0, arguments.length);\n    return !this.node_.isEmpty();\n  }\n\n  /**\n   * Returns a DataSnapshot of the specified child node's contents.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {!DataSnapshot} DataSnapshot for child node.\n   */\n  child(childPathString: string): DataSnapshot {\n    validateArgCount('DataSnapshot.child', 0, 1, arguments.length);\n    // Ensure the childPath is a string (can be a number)\n    childPathString = String(childPathString);\n    validatePathString('DataSnapshot.child', 1, childPathString, false);\n\n    const childPath = new Path(childPathString);\n    const childRef = this.ref_.child(childPath);\n    return new DataSnapshot(\n      this.node_.getChild(childPath),\n      childRef,\n      PRIORITY_INDEX\n    );\n  }\n\n  /**\n   * Returns whether the snapshot contains a child at the specified path.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {boolean} Whether the child exists.\n   */\n  hasChild(childPathString: string): boolean {\n    validateArgCount('DataSnapshot.hasChild', 1, 1, arguments.length);\n    validatePathString('DataSnapshot.hasChild', 1, childPathString, false);\n\n    const childPath = new Path(childPathString);\n    return !this.node_.getChild(childPath).isEmpty();\n  }\n\n  /**\n   * Returns the priority of the object, or null if no priority was set.\n   *\n   * @return {string|number|null} The priority.\n   */\n  getPriority(): string | number | null {\n    validateArgCount('DataSnapshot.getPriority', 0, 0, arguments.length);\n\n    // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\n    return this.node_.getPriority().val() as string | number | null;\n  }\n\n  /**\n   * Iterates through child nodes and calls the specified action for each one.\n   *\n   * @param {function(!DataSnapshot)} action Callback function to be called\n   * for each child.\n   * @return {boolean} True if forEach was canceled by action returning true for\n   * one of the child nodes.\n   */\n  forEach(action: (d: DataSnapshot) => void): boolean {\n    validateArgCount('DataSnapshot.forEach', 1, 1, arguments.length);\n    validateCallback('DataSnapshot.forEach', 1, action, false);\n\n    if (this.node_.isLeafNode()) return false;\n\n    const childrenNode = this.node_ as ChildrenNode;\n    // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\n    return !!childrenNode.forEachChild(this.index_, (key, node) => {\n      return action(\n        new DataSnapshot(node, this.ref_.child(key), PRIORITY_INDEX)\n      );\n    });\n  }\n\n  /**\n   * Returns whether this DataSnapshot has children.\n   * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.\n   */\n  hasChildren(): boolean {\n    validateArgCount('DataSnapshot.hasChildren', 0, 0, arguments.length);\n\n    if (this.node_.isLeafNode()) return false;\n    else return !this.node_.isEmpty();\n  }\n\n  get key() {\n    return this.ref_.getKey();\n  }\n\n  /**\n   * Returns the number of children for this DataSnapshot.\n   * @return {number} The number of children that this DataSnapshot contains.\n   */\n  numChildren(): number {\n    validateArgCount('DataSnapshot.numChildren', 0, 0, arguments.length);\n\n    return this.node_.numChildren();\n  }\n\n  /**\n   * @return {Reference} The Firebase reference for the location this snapshot's data came from.\n   */\n  getRef(): Reference {\n    validateArgCount('DataSnapshot.ref', 0, 0, arguments.length);\n\n    return this.ref_;\n  }\n\n  get ref() {\n    return this.getRef();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}