{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"../util/util\");\n/**\n * The event queue serves a few purposes:\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\n *    events being queued.\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\n *    left off, ensuring that the events are still raised synchronously and in order.\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\n *    events are raised synchronously.\n *\n * NOTE: This can all go away if/when we move to async events.\n *\n * @constructor\n */\n\n\nvar EventQueue =\n/** @class */\nfunction () {\n  function EventQueue() {\n    /**\n     * @private\n     * @type {!Array.<EventList>}\n     */\n    this.eventLists_ = [];\n    /**\n     * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\n     * @private\n     * @type {!number}\n     */\n\n    this.recursionDepth_ = 0;\n  }\n  /**\n   * @param {!Array.<Event>} eventDataList The new events to queue.\n   */\n\n\n  EventQueue.prototype.queueEvents = function (eventDataList) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    var currList = null;\n\n    for (var i = 0; i < eventDataList.length; i++) {\n      var eventData = eventDataList[i];\n      var eventPath = eventData.getPath();\n\n      if (currList !== null && !eventPath.equals(currList.getPath())) {\n        this.eventLists_.push(currList);\n        currList = null;\n      }\n\n      if (currList === null) {\n        currList = new EventList(eventPath);\n      }\n\n      currList.add(eventData);\n    }\n\n    if (currList) {\n      this.eventLists_.push(currList);\n    }\n  };\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones)\n   * for the specified path.\n   *\n   * It is assumed that the new events are all for the specified path.\n   *\n   * @param {!Path} path The path to raise events for.\n   * @param {!Array.<Event>} eventDataList The new events to raise.\n   */\n\n\n  EventQueue.prototype.raiseEventsAtPath = function (path, eventDataList) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {\n      return eventPath.equals(path);\n    });\n  };\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones) for\n   * locations related to the specified change path (i.e. all ancestors and descendants).\n   *\n   * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\n   *\n   * @param {!Path} changedPath The path to raise events for.\n   * @param {!Array.<!Event>} eventDataList The events to raise\n   */\n\n\n  EventQueue.prototype.raiseEventsForChangedPath = function (changedPath, eventDataList) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {\n      return eventPath.contains(changedPath) || changedPath.contains(eventPath);\n    });\n  };\n  /**\n   * @param {!function(!Path):boolean} predicate\n   * @private\n   */\n\n\n  EventQueue.prototype.raiseQueuedEventsMatchingPredicate_ = function (predicate) {\n    this.recursionDepth_++;\n    var sentAll = true;\n\n    for (var i = 0; i < this.eventLists_.length; i++) {\n      var eventList = this.eventLists_[i];\n\n      if (eventList) {\n        var eventPath = eventList.getPath();\n\n        if (predicate(eventPath)) {\n          this.eventLists_[i].raise();\n          this.eventLists_[i] = null;\n        } else {\n          sentAll = false;\n        }\n      }\n    }\n\n    if (sentAll) {\n      this.eventLists_ = [];\n    }\n\n    this.recursionDepth_--;\n  };\n\n  return EventQueue;\n}();\n\nexports.EventQueue = EventQueue;\n/**\n * @param {!Path} path\n * @constructor\n */\n\nvar EventList =\n/** @class */\nfunction () {\n  function EventList(path_) {\n    this.path_ = path_;\n    /**\n     * @type {!Array.<Event>}\n     * @private\n     */\n\n    this.events_ = [];\n  }\n  /**\n   * @param {!Event} eventData\n   */\n\n\n  EventList.prototype.add = function (eventData) {\n    this.events_.push(eventData);\n  };\n  /**\n   * Iterates through the list and raises each event\n   */\n\n\n  EventList.prototype.raise = function () {\n    for (var i = 0; i < this.events_.length; i++) {\n      var eventData = this.events_[i];\n\n      if (eventData !== null) {\n        this.events_[i] = null;\n        var eventFn = eventData.getEventRunner();\n\n        if (util_1.logger) {\n          util_1.log('event: ' + eventData.toString());\n        }\n\n        util_1.exceptionGuard(eventFn);\n      }\n    }\n  };\n  /**\n   * @return {!Path}\n   */\n\n\n  EventList.prototype.getPath = function () {\n    return this.path_;\n  };\n\n  return EventList;\n}();\n\nexports.EventList = EventList;","map":{"version":3,"mappings":"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","names":["EventQueue","eventDataList","currList","i","length","eventData","eventPath","getPath","equals","eventLists_","push","EventList","add","path","queueEvents","raiseQueuedEventsMatchingPredicate_","changedPath","contains","predicate","recursionDepth_","sentAll","eventList","raise","exports","path_","events_","eventFn","getEventRunner","util_1","toString"],"sources":["../src/core/view/EventQueue.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from '../util/Path';\nimport { log, logger, exceptionGuard } from '../util/util';\nimport { Event } from './Event';\n\n/**\n * The event queue serves a few purposes:\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\n *    events being queued.\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\n *    left off, ensuring that the events are still raised synchronously and in order.\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\n *    events are raised synchronously.\n *\n * NOTE: This can all go away if/when we move to async events.\n *\n * @constructor\n */\nexport class EventQueue {\n  /**\n   * @private\n   * @type {!Array.<EventList>}\n   */\n  private eventLists_: EventList[] = [];\n\n  /**\n   * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\n   * @private\n   * @type {!number}\n   */\n  private recursionDepth_ = 0;\n\n  /**\n   * @param {!Array.<Event>} eventDataList The new events to queue.\n   */\n  queueEvents(eventDataList: Event[]) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    let currList = null;\n    for (let i = 0; i < eventDataList.length; i++) {\n      const eventData = eventDataList[i];\n      const eventPath = eventData.getPath();\n      if (currList !== null && !eventPath.equals(currList.getPath())) {\n        this.eventLists_.push(currList);\n        currList = null;\n      }\n\n      if (currList === null) {\n        currList = new EventList(eventPath);\n      }\n\n      currList.add(eventData);\n    }\n    if (currList) {\n      this.eventLists_.push(currList);\n    }\n  }\n\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones)\n   * for the specified path.\n   *\n   * It is assumed that the new events are all for the specified path.\n   *\n   * @param {!Path} path The path to raise events for.\n   * @param {!Array.<Event>} eventDataList The new events to raise.\n   */\n  raiseEventsAtPath(path: Path, eventDataList: Event[]) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_((eventPath: Path) =>\n      eventPath.equals(path)\n    );\n  }\n\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones) for\n   * locations related to the specified change path (i.e. all ancestors and descendants).\n   *\n   * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\n   *\n   * @param {!Path} changedPath The path to raise events for.\n   * @param {!Array.<!Event>} eventDataList The events to raise\n   */\n  raiseEventsForChangedPath(changedPath: Path, eventDataList: Event[]) {\n    this.queueEvents(eventDataList);\n\n    this.raiseQueuedEventsMatchingPredicate_((eventPath: Path) => {\n      return eventPath.contains(changedPath) || changedPath.contains(eventPath);\n    });\n  }\n\n  /**\n   * @param {!function(!Path):boolean} predicate\n   * @private\n   */\n  private raiseQueuedEventsMatchingPredicate_(\n    predicate: (path: Path) => boolean\n  ) {\n    this.recursionDepth_++;\n\n    let sentAll = true;\n    for (let i = 0; i < this.eventLists_.length; i++) {\n      const eventList = this.eventLists_[i];\n      if (eventList) {\n        const eventPath = eventList.getPath();\n        if (predicate(eventPath)) {\n          this.eventLists_[i].raise();\n          this.eventLists_[i] = null;\n        } else {\n          sentAll = false;\n        }\n      }\n    }\n\n    if (sentAll) {\n      this.eventLists_ = [];\n    }\n\n    this.recursionDepth_--;\n  }\n}\n\n/**\n * @param {!Path} path\n * @constructor\n */\nexport class EventList {\n  /**\n   * @type {!Array.<Event>}\n   * @private\n   */\n  private events_: Event[] = [];\n\n  constructor(private readonly path_: Path) {}\n\n  /**\n   * @param {!Event} eventData\n   */\n  add(eventData: Event) {\n    this.events_.push(eventData);\n  }\n\n  /**\n   * Iterates through the list and raises each event\n   */\n  raise() {\n    for (let i = 0; i < this.events_.length; i++) {\n      const eventData = this.events_[i];\n      if (eventData !== null) {\n        this.events_[i] = null;\n        const eventFn = eventData.getEventRunner();\n        if (logger) {\n          log('event: ' + eventData.toString());\n        }\n        exceptionGuard(eventFn);\n      }\n    }\n  }\n\n  /**\n   * @return {!Path}\n   */\n  getPath(): Path {\n    return this.path_;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}