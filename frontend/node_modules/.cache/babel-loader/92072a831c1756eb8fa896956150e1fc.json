{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Path_1 = require(\"./Path\");\n\nvar util_2 = require(\"@firebase/util\");\n/**\r\n * Node in a Tree.\r\n */\n\n\nvar TreeNode =\n/** @class */\nfunction () {\n  function TreeNode() {\n    // TODO: Consider making accessors that create children and value lazily or\n    // separate Internal / Leaf 'types'.\n    this.children = {};\n    this.childCount = 0;\n    this.value = null;\n  }\n\n  return TreeNode;\n}();\n\nexports.TreeNode = TreeNode;\n/**\r\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\r\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\r\n * children.\r\n */\n\nvar Tree =\n/** @class */\nfunction () {\n  /**\r\n   * @template T\r\n   * @param {string=} name_ Optional name of the node.\r\n   * @param {Tree=} parent_ Optional parent node.\r\n   * @param {TreeNode=} node_ Optional node to wrap.\r\n   */\n  function Tree(name_, parent_, node_) {\n    if (name_ === void 0) {\n      name_ = '';\n    }\n\n    if (parent_ === void 0) {\n      parent_ = null;\n    }\n\n    if (node_ === void 0) {\n      node_ = new TreeNode();\n    }\n\n    this.name_ = name_;\n    this.parent_ = parent_;\n    this.node_ = node_;\n  }\n  /**\r\n   * Returns a sub-Tree for the given path.\r\n   *\r\n   * @param {!(string|Path)} pathObj Path to look up.\r\n   * @return {!Tree.<T>} Tree for path.\r\n   */\n\n\n  Tree.prototype.subTree = function (pathObj) {\n    // TODO: Require pathObj to be Path?\n    var path = pathObj instanceof Path_1.Path ? pathObj : new Path_1.Path(pathObj);\n    var child = this,\n        next;\n\n    while ((next = path.getFront()) !== null) {\n      var childNode = util_2.safeGet(child.node_.children, next) || new TreeNode();\n      child = new Tree(next, child, childNode);\n      path = path.popFront();\n    }\n\n    return child;\n  };\n  /**\r\n   * Returns the data associated with this tree node.\r\n   *\r\n   * @return {?T} The data or null if no data exists.\r\n   */\n\n\n  Tree.prototype.getValue = function () {\n    return this.node_.value;\n  };\n  /**\r\n   * Sets data to this tree node.\r\n   *\r\n   * @param {!T} value Value to set.\r\n   */\n\n\n  Tree.prototype.setValue = function (value) {\n    util_1.assert(typeof value !== 'undefined', 'Cannot set value to undefined');\n    this.node_.value = value;\n    this.updateParents_();\n  };\n  /**\r\n   * Clears the contents of the tree node (its value and all children).\r\n   */\n\n\n  Tree.prototype.clear = function () {\n    this.node_.value = null;\n    this.node_.children = {};\n    this.node_.childCount = 0;\n    this.updateParents_();\n  };\n  /**\r\n   * @return {boolean} Whether the tree has any children.\r\n   */\n\n\n  Tree.prototype.hasChildren = function () {\n    return this.node_.childCount > 0;\n  };\n  /**\r\n   * @return {boolean} Whether the tree is empty (no value or children).\r\n   */\n\n\n  Tree.prototype.isEmpty = function () {\n    return this.getValue() === null && !this.hasChildren();\n  };\n  /**\r\n   * Calls action for each child of this tree node.\r\n   *\r\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\r\n   */\n\n\n  Tree.prototype.forEachChild = function (action) {\n    var _this = this;\n\n    util_2.forEach(this.node_.children, function (child, childTree) {\n      action(new Tree(child, _this, childTree));\n    });\n  };\n  /**\r\n   * Does a depth-first traversal of this node's descendants, calling action for each one.\r\n   *\r\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\r\n   * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to\r\n   *   false.\r\n   * @param {boolean=} childrenFirst Whether to call action on children before calling it on\r\n   *   parent.\r\n   */\n\n\n  Tree.prototype.forEachDescendant = function (action, includeSelf, childrenFirst) {\n    if (includeSelf && !childrenFirst) action(this);\n    this.forEachChild(function (child) {\n      child.forEachDescendant(action,\n      /*includeSelf=*/\n      true, childrenFirst);\n    });\n    if (includeSelf && childrenFirst) action(this);\n  };\n  /**\r\n   * Calls action on each ancestor node.\r\n   *\r\n   * @param {function(!Tree.<T>)} action Action to be called on each parent; return\r\n   *   true to abort.\r\n   * @param {boolean=} includeSelf Whether to call action on this node as well.\r\n   * @return {boolean} true if the action callback returned true.\r\n   */\n\n\n  Tree.prototype.forEachAncestor = function (action, includeSelf) {\n    var node = includeSelf ? this : this.parent();\n\n    while (node !== null) {\n      if (action(node)) {\n        return true;\n      }\n\n      node = node.parent();\n    }\n\n    return false;\n  };\n  /**\r\n   * Does a depth-first traversal of this node's descendants.  When a descendant with a value\r\n   * is found, action is called on it and traversal does not continue inside the node.\r\n   * Action is *not* called on this node.\r\n   *\r\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\r\n   */\n\n\n  Tree.prototype.forEachImmediateDescendantWithValue = function (action) {\n    this.forEachChild(function (child) {\n      if (child.getValue() !== null) action(child);else child.forEachImmediateDescendantWithValue(action);\n    });\n  };\n  /**\r\n   * @return {!Path} The path of this tree node, as a Path.\r\n   */\n\n\n  Tree.prototype.path = function () {\n    return new Path_1.Path(this.parent_ === null ? this.name_ : this.parent_.path() + '/' + this.name_);\n  };\n  /**\r\n   * @return {string} The name of the tree node.\r\n   */\n\n\n  Tree.prototype.name = function () {\n    return this.name_;\n  };\n  /**\r\n   * @return {?Tree} The parent tree node, or null if this is the root of the tree.\r\n   */\n\n\n  Tree.prototype.parent = function () {\n    return this.parent_;\n  };\n  /**\r\n   * Adds or removes this child from its parent based on whether it's empty or not.\r\n   *\r\n   * @private\r\n   */\n\n\n  Tree.prototype.updateParents_ = function () {\n    if (this.parent_ !== null) this.parent_.updateChild_(this.name_, this);\n  };\n  /**\r\n   * Adds or removes the passed child to this tree node, depending on whether it's empty.\r\n   *\r\n   * @param {string} childName The name of the child to update.\r\n   * @param {!Tree.<T>} child The child to update.\r\n   * @private\r\n   */\n\n\n  Tree.prototype.updateChild_ = function (childName, child) {\n    var childEmpty = child.isEmpty();\n    var childExists = util_2.contains(this.node_.children, childName);\n\n    if (childEmpty && childExists) {\n      delete this.node_.children[childName];\n      this.node_.childCount--;\n      this.updateParents_();\n    } else if (!childEmpty && !childExists) {\n      this.node_.children[childName] = child.node_;\n      this.node_.childCount++;\n      this.updateParents_();\n    }\n  };\n\n  return Tree;\n}();\n\nexports.Tree = Tree;","map":{"version":3,"mappings":"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","names":["exports","name_","parent_","node_","TreeNode","Tree","pathObj","path","Path_1","child","next","getFront","childNode","util_2","children","popFront","value","util_1","updateParents_","childCount","getValue","hasChildren","action","childTree","_this","includeSelf","childrenFirst","forEachChild","forEachDescendant","node","parent","forEachImmediateDescendantWithValue","updateChild_","childName","childEmpty","isEmpty","childExists"],"sources":["../src/core/util/Tree.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Path } from './Path';\nimport { forEach, contains, safeGet } from '@firebase/util';\n\n/**\n * Node in a Tree.\n */\nexport class TreeNode<T> {\n  // TODO: Consider making accessors that create children and value lazily or\n  // separate Internal / Leaf 'types'.\n  children: { [name: string]: TreeNode<T> } = {};\n  childCount = 0;\n  value: T | null = null;\n}\n\n/**\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\n * children.\n */\nexport class Tree<T> {\n  /**\n   * @template T\n   * @param {string=} name_ Optional name of the node.\n   * @param {Tree=} parent_ Optional parent node.\n   * @param {TreeNode=} node_ Optional node to wrap.\n   */\n  constructor(\n    private name_: string = '',\n    private parent_: Tree<T> | null = null,\n    private node_: TreeNode<T> = new TreeNode<T>()\n  ) {}\n\n  /**\n   * Returns a sub-Tree for the given path.\n   *\n   * @param {!(string|Path)} pathObj Path to look up.\n   * @return {!Tree.<T>} Tree for path.\n   */\n  subTree(pathObj: string | Path): Tree<T> {\n    // TODO: Require pathObj to be Path?\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\n    let child = this as any,\n      next;\n    while ((next = path.getFront()) !== null) {\n      const childNode = safeGet(child.node_.children, next) || new TreeNode();\n      child = new Tree(next, child, childNode);\n      path = path.popFront();\n    }\n\n    return child;\n  }\n\n  /**\n   * Returns the data associated with this tree node.\n   *\n   * @return {?T} The data or null if no data exists.\n   */\n  getValue(): T | null {\n    return this.node_.value;\n  }\n\n  /**\n   * Sets data to this tree node.\n   *\n   * @param {!T} value Value to set.\n   */\n  setValue(value: T) {\n    assert(typeof value !== 'undefined', 'Cannot set value to undefined');\n    this.node_.value = value;\n    this.updateParents_();\n  }\n\n  /**\n   * Clears the contents of the tree node (its value and all children).\n   */\n  clear() {\n    this.node_.value = null;\n    this.node_.children = {};\n    this.node_.childCount = 0;\n    this.updateParents_();\n  }\n\n  /**\n   * @return {boolean} Whether the tree has any children.\n   */\n  hasChildren(): boolean {\n    return this.node_.childCount > 0;\n  }\n\n  /**\n   * @return {boolean} Whether the tree is empty (no value or children).\n   */\n  isEmpty(): boolean {\n    return this.getValue() === null && !this.hasChildren();\n  }\n\n  /**\n   * Calls action for each child of this tree node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  forEachChild(action: (tree: Tree<T>) => void) {\n    forEach(this.node_.children, (child: string, childTree: TreeNode<T>) => {\n      action(new Tree<T>(child, this, childTree));\n    });\n  }\n\n  /**\n   * Does a depth-first traversal of this node's descendants, calling action for each one.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to\n   *   false.\n   * @param {boolean=} childrenFirst Whether to call action on children before calling it on\n   *   parent.\n   */\n  forEachDescendant(\n    action: (tree: Tree<T>) => void,\n    includeSelf?: boolean,\n    childrenFirst?: boolean\n  ) {\n    if (includeSelf && !childrenFirst) action(this);\n\n    this.forEachChild(function(child) {\n      child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);\n    });\n\n    if (includeSelf && childrenFirst) action(this);\n  }\n\n  /**\n   * Calls action on each ancestor node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called on each parent; return\n   *   true to abort.\n   * @param {boolean=} includeSelf Whether to call action on this node as well.\n   * @return {boolean} true if the action callback returned true.\n   */\n  forEachAncestor(\n    action: (tree: Tree<T>) => void,\n    includeSelf?: boolean\n  ): boolean {\n    let node = includeSelf ? this : this.parent();\n    while (node !== null) {\n      if (action(node)) {\n        return true;\n      }\n      node = node.parent();\n    }\n    return false;\n  }\n\n  /**\n   * Does a depth-first traversal of this node's descendants.  When a descendant with a value\n   * is found, action is called on it and traversal does not continue inside the node.\n   * Action is *not* called on this node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  forEachImmediateDescendantWithValue(action: (tree: Tree<T>) => void) {\n    this.forEachChild(function(child) {\n      if (child.getValue() !== null) action(child);\n      else child.forEachImmediateDescendantWithValue(action);\n    });\n  }\n\n  /**\n   * @return {!Path} The path of this tree node, as a Path.\n   */\n  path(): Path {\n    return new Path(\n      this.parent_ === null\n        ? this.name_\n        : this.parent_.path() + '/' + this.name_\n    );\n  }\n\n  /**\n   * @return {string} The name of the tree node.\n   */\n  name(): string {\n    return this.name_;\n  }\n\n  /**\n   * @return {?Tree} The parent tree node, or null if this is the root of the tree.\n   */\n  parent(): Tree<T> | null {\n    return this.parent_;\n  }\n\n  /**\n   * Adds or removes this child from its parent based on whether it's empty or not.\n   *\n   * @private\n   */\n  private updateParents_() {\n    if (this.parent_ !== null) this.parent_.updateChild_(this.name_, this);\n  }\n\n  /**\n   * Adds or removes the passed child to this tree node, depending on whether it's empty.\n   *\n   * @param {string} childName The name of the child to update.\n   * @param {!Tree.<T>} child The child to update.\n   * @private\n   */\n  private updateChild_(childName: string, child: Tree<T>) {\n    const childEmpty = child.isEmpty();\n    const childExists = contains(this.node_.children, childName);\n    if (childEmpty && childExists) {\n      delete this.node_.children[childName];\n      this.node_.childCount--;\n      this.updateParents_();\n    } else if (!childEmpty && !childExists) {\n      this.node_.children[childName] = child.node_;\n      this.node_.childCount++;\n      this.updateParents_();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}