{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"@firebase/util\");\n\nvar Path_1 = require(\"./util/Path\");\n\nvar CompoundWrite_1 = require(\"./CompoundWrite\");\n\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\n\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\n/**\r\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\r\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\r\n * and addMerge(), and removed with removeWrite().\r\n *\r\n * @constructor\r\n */\n\n\nvar WriteTree =\n/** @class */\nfunction () {\n  function WriteTree() {\n    /**\r\n     * A tree tracking the result of applying all visible writes.  This does not include transactions with\r\n     * applyLocally=false or writes that are completely shadowed by other writes.\r\n     *\r\n     * @type {!CompoundWrite}\r\n     * @private\r\n     */\n    this.visibleWrites_ = CompoundWrite_1.CompoundWrite.Empty;\n    /**\r\n     * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\r\n     * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\r\n     * used by transactions).\r\n     *\r\n     * @type {!Array.<!WriteRecord>}\r\n     * @private\r\n     */\n\n    this.allWrites_ = [];\n    this.lastWriteId_ = -1;\n  }\n  /**\r\n   * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\r\n   *\r\n   * @param {!Path} path\r\n   * @return {!WriteTreeRef}\r\n   */\n\n\n  WriteTree.prototype.childWrites = function (path) {\n    return new WriteTreeRef(path, this);\n  };\n  /**\r\n   * Record a new overwrite from user code.\r\n   *\r\n   * @param {!Path} path\r\n   * @param {!Node} snap\r\n   * @param {!number} writeId\r\n   * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\r\n   */\n\n\n  WriteTree.prototype.addOverwrite = function (path, snap, writeId, visible) {\n    util_2.assert(writeId > this.lastWriteId_, 'Stacking an older write on top of newer ones');\n\n    if (visible === undefined) {\n      visible = true;\n    }\n\n    this.allWrites_.push({\n      path: path,\n      snap: snap,\n      writeId: writeId,\n      visible: visible\n    });\n\n    if (visible) {\n      this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\n    }\n\n    this.lastWriteId_ = writeId;\n  };\n  /**\r\n   * Record a new merge from user code.\r\n   *\r\n   * @param {!Path} path\r\n   * @param {!Object.<string, !Node>} changedChildren\r\n   * @param {!number} writeId\r\n   */\n\n\n  WriteTree.prototype.addMerge = function (path, changedChildren, writeId) {\n    util_2.assert(writeId > this.lastWriteId_, 'Stacking an older merge on top of newer ones');\n    this.allWrites_.push({\n      path: path,\n      children: changedChildren,\n      writeId: writeId,\n      visible: true\n    });\n    this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\n    this.lastWriteId_ = writeId;\n  };\n  /**\r\n   * @param {!number} writeId\r\n   * @return {?WriteRecord}\r\n   */\n\n\n  WriteTree.prototype.getWrite = function (writeId) {\n    for (var i = 0; i < this.allWrites_.length; i++) {\n      var record = this.allWrites_[i];\n\n      if (record.writeId === writeId) {\n        return record;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\r\n   * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\r\n   *\r\n   * @param {!number} writeId\r\n   * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\r\n   * events as a result).\r\n   */\n\n\n  WriteTree.prototype.removeWrite = function (writeId) {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n    var _this = this;\n\n    var idx = this.allWrites_.findIndex(function (s) {\n      return s.writeId === writeId;\n    });\n    util_2.assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\n    var writeToRemove = this.allWrites_[idx];\n    this.allWrites_.splice(idx, 1);\n    var removedWriteWasVisible = writeToRemove.visible;\n    var removedWriteOverlapsWithOtherWrites = false;\n    var i = this.allWrites_.length - 1;\n\n    while (removedWriteWasVisible && i >= 0) {\n      var currentWrite = this.allWrites_[i];\n\n      if (currentWrite.visible) {\n        if (i >= idx && this.recordContainsPath_(currentWrite, writeToRemove.path)) {\n          // The removed write was completely shadowed by a subsequent write.\n          removedWriteWasVisible = false;\n        } else if (writeToRemove.path.contains(currentWrite.path)) {\n          // Either we're covering some writes or they're covering part of us (depending on which came first).\n          removedWriteOverlapsWithOtherWrites = true;\n        }\n      }\n\n      i--;\n    }\n\n    if (!removedWriteWasVisible) {\n      return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n      // There's some shadowing going on. Just rebuild the visible writes from scratch.\n      this.resetTree_();\n      return true;\n    } else {\n      // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n      if (writeToRemove.snap) {\n        this.visibleWrites_ = this.visibleWrites_.removeWrite(writeToRemove.path);\n      } else {\n        var children = writeToRemove.children;\n        util_1.forEach(children, function (childName) {\n          _this.visibleWrites_ = _this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));\n        });\n      }\n\n      return true;\n    }\n  };\n  /**\r\n   * Return a complete snapshot for the given path if there's visible write data at that path, else null.\r\n   * No server data is considered.\r\n   *\r\n   * @param {!Path} path\r\n   * @return {?Node}\r\n   */\n\n\n  WriteTree.prototype.getCompleteWriteData = function (path) {\n    return this.visibleWrites_.getCompleteNode(path);\n  };\n  /**\r\n   * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\r\n   * writes), attempt to calculate a complete snapshot for the given path\r\n   *\r\n   * @param {!Path} treePath\r\n   * @param {?Node} completeServerCache\r\n   * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\r\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\r\n   * @return {?Node}\r\n   */\n\n\n  WriteTree.prototype.calcCompleteEventCache = function (treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n      var shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\n\n      if (shadowingNode != null) {\n        return shadowingNode;\n      } else {\n        var subMerge = this.visibleWrites_.childCompoundWrite(treePath);\n\n        if (subMerge.isEmpty()) {\n          return completeServerCache;\n        } else if (completeServerCache == null && !subMerge.hasCompleteWrite(Path_1.Path.Empty)) {\n          // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n          return null;\n        } else {\n          var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          return subMerge.apply(layeredCache);\n        }\n      }\n    } else {\n      var merge = this.visibleWrites_.childCompoundWrite(treePath);\n\n      if (!includeHiddenWrites && merge.isEmpty()) {\n        return completeServerCache;\n      } else {\n        // If the server cache is null, and we don't have a complete cache, we need to return null\n        if (!includeHiddenWrites && completeServerCache == null && !merge.hasCompleteWrite(Path_1.Path.Empty)) {\n          return null;\n        } else {\n          var filter = function (write) {\n            return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (write.path.contains(treePath) || treePath.contains(write.path));\n          };\n\n          var mergeAtPath = WriteTree.layerTree_(this.allWrites_, filter, treePath);\n          var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          return mergeAtPath.apply(layeredCache);\n        }\n      }\n    }\n  };\n  /**\r\n   * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\r\n   * Used when creating new views, to pre-fill their complete event children snapshot.\r\n   *\r\n   * @param {!Path} treePath\r\n   * @param {?ChildrenNode} completeServerChildren\r\n   * @return {!ChildrenNode}\r\n   */\n\n\n  WriteTree.prototype.calcCompleteEventChildren = function (treePath, completeServerChildren) {\n    var completeChildren = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    var topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\n\n    if (topLevelSet) {\n      if (!topLevelSet.isLeafNode()) {\n        // we're shadowing everything. Return the children.\n        topLevelSet.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childSnap) {\n          completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\n        });\n      }\n\n      return completeChildren;\n    } else if (completeServerChildren) {\n      // Layer any children we have on top of this\n      // We know we don't have a top-level set, so just enumerate existing children\n      var merge_1 = this.visibleWrites_.childCompoundWrite(treePath);\n      completeServerChildren.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {\n        var node = merge_1.childCompoundWrite(new Path_1.Path(childName)).apply(childNode);\n        completeChildren = completeChildren.updateImmediateChild(childName, node);\n      }); // Add any complete children we have from the set\n\n      merge_1.getCompleteChildren().forEach(function (namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n      });\n      return completeChildren;\n    } else {\n      // We don't have anything to layer on top of. Layer on any children we have\n      // Note that we can return an empty snap if we have a defined delete\n      var merge = this.visibleWrites_.childCompoundWrite(treePath);\n      merge.getCompleteChildren().forEach(function (namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n      });\n      return completeChildren;\n    }\n  };\n  /**\r\n   * Given that the underlying server data has updated, determine what, if anything, needs to be\r\n   * applied to the event cache.\r\n   *\r\n   * Possibilities:\r\n   *\r\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n   *\r\n   * 2. Some write is completely shadowing. No events to be raised\r\n   *\r\n   * 3. Is partially shadowed. Events\r\n   *\r\n   * Either existingEventSnap or existingServerSnap must exist\r\n   *\r\n   * @param {!Path} treePath\r\n   * @param {!Path} childPath\r\n   * @param {?Node} existingEventSnap\r\n   * @param {?Node} existingServerSnap\r\n   * @return {?Node}\r\n   */\n\n\n  WriteTree.prototype.calcEventCacheAfterServerOverwrite = function (treePath, childPath, existingEventSnap, existingServerSnap) {\n    util_2.assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');\n    var path = treePath.child(childPath);\n\n    if (this.visibleWrites_.hasCompleteWrite(path)) {\n      // At this point we can probably guarantee that we're in case 2, meaning no events\n      // May need to check visibility while doing the findRootMostValueAndPath call\n      return null;\n    } else {\n      // No complete shadowing. We're either partially shadowing or not shadowing at all.\n      var childMerge = this.visibleWrites_.childCompoundWrite(path);\n\n      if (childMerge.isEmpty()) {\n        // We're not shadowing at all. Case 1\n        return existingServerSnap.getChild(childPath);\n      } else {\n        // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n        // However this is tricky to find out, since user updates don't necessary change the server\n        // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n        // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n        // only check if the updates change the serverNode.\n        // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n        return childMerge.apply(existingServerSnap.getChild(childPath));\n      }\n    }\n  };\n  /**\r\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n   * complete child for this ChildKey.\r\n   *\r\n   * @param {!Path} treePath\r\n   * @param {!string} childKey\r\n   * @param {!CacheNode} existingServerSnap\r\n   * @return {?Node}\r\n   */\n\n\n  WriteTree.prototype.calcCompleteChild = function (treePath, childKey, existingServerSnap) {\n    var path = treePath.child(childKey);\n    var shadowingNode = this.visibleWrites_.getCompleteNode(path);\n\n    if (shadowingNode != null) {\n      return shadowingNode;\n    } else {\n      if (existingServerSnap.isCompleteForChild(childKey)) {\n        var childMerge = this.visibleWrites_.childCompoundWrite(path);\n        return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));\n      } else {\n        return null;\n      }\n    }\n  };\n  /**\r\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n   * a higher path, this will return the child of that write relative to the write and this path.\r\n   * Returns null if there is no write at this path.\r\n   *\r\n   * @param {!Path} path\r\n   * @return {?Node}\r\n   */\n\n\n  WriteTree.prototype.shadowingWrite = function (path) {\n    return this.visibleWrites_.getCompleteNode(path);\n  };\n  /**\r\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n   * the window, but may now be in the window.\r\n   *\r\n   * @param {!Path} treePath\r\n   * @param {?Node} completeServerData\r\n   * @param {!NamedNode} startPost\r\n   * @param {!number} count\r\n   * @param {boolean} reverse\r\n   * @param {!Index} index\r\n   * @return {!Array.<!NamedNode>}\r\n   */\n\n\n  WriteTree.prototype.calcIndexedSlice = function (treePath, completeServerData, startPost, count, reverse, index) {\n    var toIterate;\n    var merge = this.visibleWrites_.childCompoundWrite(treePath);\n    var shadowingNode = merge.getCompleteNode(Path_1.Path.Empty);\n\n    if (shadowingNode != null) {\n      toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n      toIterate = merge.apply(completeServerData);\n    } else {\n      // no children to iterate on\n      return [];\n    }\n\n    toIterate = toIterate.withIndex(index);\n\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n      var nodes = [];\n      var cmp = index.getCompare();\n      var iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);\n      var next = iter.getNext();\n\n      while (next && nodes.length < count) {\n        if (cmp(next, startPost) !== 0) {\n          nodes.push(next);\n        }\n\n        next = iter.getNext();\n      }\n\n      return nodes;\n    } else {\n      return [];\n    }\n  };\n  /**\r\n   * @param {!WriteRecord} writeRecord\r\n   * @param {!Path} path\r\n   * @return {boolean}\r\n   * @private\r\n   */\n\n\n  WriteTree.prototype.recordContainsPath_ = function (writeRecord, path) {\n    if (writeRecord.snap) {\n      return writeRecord.path.contains(path);\n    } else {\n      // findKey can return undefined, so use !! to coerce to boolean\n      return !!util_1.findKey(writeRecord.children, function (childSnap, childName) {\n        return writeRecord.path.child(childName).contains(path);\n      });\n    }\n  };\n  /**\r\n   * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\r\n   * @private\r\n   */\n\n\n  WriteTree.prototype.resetTree_ = function () {\n    this.visibleWrites_ = WriteTree.layerTree_(this.allWrites_, WriteTree.DefaultFilter_, Path_1.Path.Empty);\n\n    if (this.allWrites_.length > 0) {\n      this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\n    } else {\n      this.lastWriteId_ = -1;\n    }\n  };\n  /**\r\n   * The default filter used when constructing the tree. Keep everything that's visible.\r\n   *\r\n   * @param {!WriteRecord} write\r\n   * @return {boolean}\r\n   * @private\r\n   */\n\n\n  WriteTree.DefaultFilter_ = function (write) {\n    return write.visible;\n  };\n  /**\r\n   * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\r\n   * event data at that path.\r\n   *\r\n   * @param {!Array.<!WriteRecord>} writes\r\n   * @param {!function(!WriteRecord):boolean} filter\r\n   * @param {!Path} treeRoot\r\n   * @return {!CompoundWrite}\r\n   * @private\r\n   */\n\n\n  WriteTree.layerTree_ = function (writes, filter, treeRoot) {\n    var compoundWrite = CompoundWrite_1.CompoundWrite.Empty;\n\n    for (var i = 0; i < writes.length; ++i) {\n      var write = writes[i]; // Theory, a later set will either:\n      // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n      // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n\n      if (filter(write)) {\n        var writePath = write.path;\n        var relativePath = void 0;\n\n        if (write.snap) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path_1.Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path_1.Path.relativePath(writePath, treeRoot);\n            compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, write.snap.getChild(relativePath));\n          } else {// There is no overlap between root path and write path, ignore write\n          }\n        } else if (write.children) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path_1.Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrites(relativePath, write.children);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path_1.Path.relativePath(writePath, treeRoot);\n\n            if (relativePath.isEmpty()) {\n              compoundWrite = compoundWrite.addWrites(Path_1.Path.Empty, write.children);\n            } else {\n              var child = util_1.safeGet(write.children, relativePath.getFront());\n\n              if (child) {\n                // There exists a child in this node that matches the root path\n                var deepNode = child.getChild(relativePath.popFront());\n                compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, deepNode);\n              }\n            }\n          } else {// There is no overlap between root path and write path, ignore write\n          }\n        } else {\n          throw util_2.assertionError('WriteRecord should have .snap or .children');\n        }\n      }\n    }\n\n    return compoundWrite;\n  };\n\n  return WriteTree;\n}();\n\nexports.WriteTree = WriteTree;\n/**\r\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\r\n * just proxy to the underlying WriteTree.\r\n *\r\n * @constructor\r\n */\n\nvar WriteTreeRef =\n/** @class */\nfunction () {\n  /**\r\n   * @param {!Path} path\r\n   * @param {!WriteTree} writeTree\r\n   */\n  function WriteTreeRef(path, writeTree) {\n    this.treePath_ = path;\n    this.writeTree_ = writeTree;\n  }\n  /**\r\n   * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\r\n   * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\r\n   * can lead to a more expensive calculation.\r\n   *\r\n   * @param {?Node} completeServerCache\r\n   * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\r\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\r\n   * @return {?Node}\r\n   */\n\n\n  WriteTreeRef.prototype.calcCompleteEventCache = function (completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    return this.writeTree_.calcCompleteEventCache(this.treePath_, completeServerCache, writeIdsToExclude, includeHiddenWrites);\n  };\n  /**\r\n   * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\r\n   * mix of the given server data and write data.\r\n   *\r\n   * @param {?ChildrenNode} completeServerChildren\r\n   * @return {!ChildrenNode}\r\n   */\n\n\n  WriteTreeRef.prototype.calcCompleteEventChildren = function (completeServerChildren) {\n    return this.writeTree_.calcCompleteEventChildren(this.treePath_, completeServerChildren);\n  };\n  /**\r\n   * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\r\n   * if anything, needs to be applied to the event cache.\r\n   *\r\n   * Possibilities:\r\n   *\r\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n   *\r\n   * 2. Some write is completely shadowing. No events to be raised\r\n   *\r\n   * 3. Is partially shadowed. Events should be raised\r\n   *\r\n   * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\r\n   *\r\n   * @param {!Path} path\r\n   * @param {?Node} existingEventSnap\r\n   * @param {?Node} existingServerSnap\r\n   * @return {?Node}\r\n   */\n\n\n  WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite = function (path, existingEventSnap, existingServerSnap) {\n    return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_, path, existingEventSnap, existingServerSnap);\n  };\n  /**\r\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n   * a higher path, this will return the child of that write relative to the write and this path.\r\n   * Returns null if there is no write at this path.\r\n   *\r\n   * @param {!Path} path\r\n   * @return {?Node}\r\n   */\n\n\n  WriteTreeRef.prototype.shadowingWrite = function (path) {\n    return this.writeTree_.shadowingWrite(this.treePath_.child(path));\n  };\n  /**\r\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n   * the window, but may now be in the window\r\n   *\r\n   * @param {?Node} completeServerData\r\n   * @param {!NamedNode} startPost\r\n   * @param {!number} count\r\n   * @param {boolean} reverse\r\n   * @param {!Index} index\r\n   * @return {!Array.<!NamedNode>}\r\n   */\n\n\n  WriteTreeRef.prototype.calcIndexedSlice = function (completeServerData, startPost, count, reverse, index) {\n    return this.writeTree_.calcIndexedSlice(this.treePath_, completeServerData, startPost, count, reverse, index);\n  };\n  /**\r\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n   * complete child for this ChildKey.\r\n   *\r\n   * @param {!string} childKey\r\n   * @param {!CacheNode} existingServerCache\r\n   * @return {?Node}\r\n   */\n\n\n  WriteTreeRef.prototype.calcCompleteChild = function (childKey, existingServerCache) {\n    return this.writeTree_.calcCompleteChild(this.treePath_, childKey, existingServerCache);\n  };\n  /**\r\n   * Return a WriteTreeRef for a child.\r\n   *\r\n   * @param {string} childName\r\n   * @return {!WriteTreeRef}\r\n   */\n\n\n  WriteTreeRef.prototype.child = function (childName) {\n    return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\n  };\n\n  return WriteTreeRef;\n}();\n\nexports.WriteTreeRef = WriteTreeRef;","map":{"version":3,"mappings":"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","names":["CompoundWrite_1","Empty","WriteTree","path","WriteTreeRef","snap","writeId","visible","util_2","lastWriteId_","undefined","allWrites_","push","visibleWrites_","addWrite","changedChildren","children","addWrites","i","length","record","idx","findIndex","s","writeToRemove","splice","removedWriteWasVisible","removedWriteOverlapsWithOtherWrites","currentWrite","recordContainsPath_","contains","resetTree_","removeWrite","util_1","childName","_this","child","getCompleteNode","treePath","completeServerCache","writeIdsToExclude","includeHiddenWrites","shadowingNode","subMerge","childCompoundWrite","isEmpty","hasCompleteWrite","Path_1","layeredCache","ChildrenNode_1","EMPTY_NODE","apply","merge","filter","write","indexOf","mergeAtPath","layerTree_","completeServerChildren","completeChildren","topLevelSet","isLeafNode","forEachChild","PriorityIndex_1","childSnap","updateImmediateChild","merge_1","childNode","node","getCompleteChildren","forEach","namedNode","name","childPath","existingEventSnap","existingServerSnap","childMerge","getChild","childKey","isCompleteForChild","getNode","getImmediateChild","completeServerData","startPost","count","reverse","index","toIterate","withIndex","nodes","cmp","getCompare","iter","getReverseIteratorFrom","getIteratorFrom","next","getNext","writeRecord","DefaultFilter_","writes","treeRoot","compoundWrite","writePath","relativePath","getFront","deepNode","popFront","exports","writeTree","treePath_","writeTree_","calcCompleteEventCache","calcCompleteEventChildren","calcEventCacheAfterServerOverwrite","shadowingWrite","calcIndexedSlice","existingServerCache","calcCompleteChild"],"sources":["../src/core/WriteTree.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { findKey, forEach, safeGet } from '@firebase/util';\nimport { assert, assertionError } from '@firebase/util';\nimport { Path } from './util/Path';\nimport { CompoundWrite } from './CompoundWrite';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { NamedNode, Node } from './snap/Node';\nimport { CacheNode } from './view/CacheNode';\nimport { Index } from './snap/indexes/Index';\n\n/**\n * Defines a single user-initiated write operation. May be the result of a set(), transaction(), or update() call. In\n * the case of a set() or transaction, snap wil be non-null.  In the case of an update(), children will be non-null.\n */\nexport interface WriteRecord {\n  writeId: number;\n  path: Path;\n  snap?: Node | null;\n  children?: { [k: string]: Node } | null;\n  visible: boolean;\n}\n\n/**\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\n * and addMerge(), and removed with removeWrite().\n *\n * @constructor\n */\nexport class WriteTree {\n  /**\n   * A tree tracking the result of applying all visible writes.  This does not include transactions with\n   * applyLocally=false or writes that are completely shadowed by other writes.\n   *\n   * @type {!CompoundWrite}\n   * @private\n   */\n  private visibleWrites_: CompoundWrite = CompoundWrite.Empty;\n\n  /**\n   * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\n   * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\n   * used by transactions).\n   *\n   * @type {!Array.<!WriteRecord>}\n   * @private\n   */\n  private allWrites_: WriteRecord[] = [];\n\n  private lastWriteId_ = -1;\n\n  /**\n   * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\n   *\n   * @param {!Path} path\n   * @return {!WriteTreeRef}\n   */\n  childWrites(path: Path): WriteTreeRef {\n    return new WriteTreeRef(path, this);\n  }\n\n  /**\n   * Record a new overwrite from user code.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} writeId\n   * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\n   */\n  addOverwrite(path: Path, snap: Node, writeId: number, visible?: boolean) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older write on top of newer ones'\n    );\n    if (visible === undefined) {\n      visible = true;\n    }\n    this.allWrites_.push({\n      path: path,\n      snap: snap,\n      writeId: writeId,\n      visible: visible\n    });\n\n    if (visible) {\n      this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\n    }\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * Record a new merge from user code.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   */\n  addMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    writeId: number\n  ) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older merge on top of newer ones'\n    );\n    this.allWrites_.push({\n      path: path,\n      children: changedChildren,\n      writeId: writeId,\n      visible: true\n    });\n\n    this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * @param {!number} writeId\n   * @return {?WriteRecord}\n   */\n  getWrite(writeId: number): WriteRecord | null {\n    for (let i = 0; i < this.allWrites_.length; i++) {\n      const record = this.allWrites_[i];\n      if (record.writeId === writeId) {\n        return record;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\n   * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\n   *\n   * @param {!number} writeId\n   * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\n   * events as a result).\n   */\n  removeWrite(writeId: number): boolean {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n\n    const idx = this.allWrites_.findIndex(function(s) {\n      return s.writeId === writeId;\n    });\n    assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\n    const writeToRemove = this.allWrites_[idx];\n    this.allWrites_.splice(idx, 1);\n\n    let removedWriteWasVisible = writeToRemove.visible;\n    let removedWriteOverlapsWithOtherWrites = false;\n\n    let i = this.allWrites_.length - 1;\n\n    while (removedWriteWasVisible && i >= 0) {\n      const currentWrite = this.allWrites_[i];\n      if (currentWrite.visible) {\n        if (\n          i >= idx &&\n          this.recordContainsPath_(currentWrite, writeToRemove.path)\n        ) {\n          // The removed write was completely shadowed by a subsequent write.\n          removedWriteWasVisible = false;\n        } else if (writeToRemove.path.contains(currentWrite.path)) {\n          // Either we're covering some writes or they're covering part of us (depending on which came first).\n          removedWriteOverlapsWithOtherWrites = true;\n        }\n      }\n      i--;\n    }\n\n    if (!removedWriteWasVisible) {\n      return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n      // There's some shadowing going on. Just rebuild the visible writes from scratch.\n      this.resetTree_();\n      return true;\n    } else {\n      // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n      if (writeToRemove.snap) {\n        this.visibleWrites_ = this.visibleWrites_.removeWrite(\n          writeToRemove.path\n        );\n      } else {\n        const children = writeToRemove.children;\n        forEach(children, (childName: string) => {\n          this.visibleWrites_ = this.visibleWrites_.removeWrite(\n            writeToRemove.path.child(childName)\n          );\n        });\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Return a complete snapshot for the given path if there's visible write data at that path, else null.\n   * No server data is considered.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  getCompleteWriteData(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\n   * writes), attempt to calculate a complete snapshot for the given path\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    treePath: Path,\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n      const shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\n      if (shadowingNode != null) {\n        return shadowingNode;\n      } else {\n        const subMerge = this.visibleWrites_.childCompoundWrite(treePath);\n        if (subMerge.isEmpty()) {\n          return completeServerCache;\n        } else if (\n          completeServerCache == null &&\n          !subMerge.hasCompleteWrite(Path.Empty)\n        ) {\n          // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n          return null;\n        } else {\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return subMerge.apply(layeredCache);\n        }\n      }\n    } else {\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      if (!includeHiddenWrites && merge.isEmpty()) {\n        return completeServerCache;\n      } else {\n        // If the server cache is null, and we don't have a complete cache, we need to return null\n        if (\n          !includeHiddenWrites &&\n          completeServerCache == null &&\n          !merge.hasCompleteWrite(Path.Empty)\n        ) {\n          return null;\n        } else {\n          const filter = function(write: WriteRecord) {\n            return (\n              (write.visible || includeHiddenWrites) &&\n              (!writeIdsToExclude ||\n                !~writeIdsToExclude.indexOf(write.writeId)) &&\n              (write.path.contains(treePath) || treePath.contains(write.path))\n            );\n          };\n          const mergeAtPath = WriteTree.layerTree_(\n            this.allWrites_,\n            filter,\n            treePath\n          );\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return mergeAtPath.apply(layeredCache);\n        }\n      }\n    }\n  }\n\n  /**\n   * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\n   * Used when creating new views, to pre-fill their complete event children snapshot.\n   *\n   * @param {!Path} treePath\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    treePath: Path,\n    completeServerChildren: ChildrenNode | null\n  ) {\n    let completeChildren = ChildrenNode.EMPTY_NODE as Node;\n    const topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\n    if (topLevelSet) {\n      if (!topLevelSet.isLeafNode()) {\n        // we're shadowing everything. Return the children.\n        topLevelSet.forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childSnap\n        ) {\n          completeChildren = completeChildren.updateImmediateChild(\n            childName,\n            childSnap\n          );\n        });\n      }\n      return completeChildren;\n    } else if (completeServerChildren) {\n      // Layer any children we have on top of this\n      // We know we don't have a top-level set, so just enumerate existing children\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      completeServerChildren.forEachChild(PRIORITY_INDEX, function(\n        childName,\n        childNode\n      ) {\n        const node = merge\n          .childCompoundWrite(new Path(childName))\n          .apply(childNode);\n        completeChildren = completeChildren.updateImmediateChild(\n          childName,\n          node\n        );\n      });\n      // Add any complete children we have from the set\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    } else {\n      // We don't have anything to layer on top of. Layer on any children we have\n      // Note that we can return an empty snap if we have a defined delete\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    }\n  }\n\n  /**\n   * Given that the underlying server data has updated, determine what, if anything, needs to be\n   * applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events\n   *\n   * Either existingEventSnap or existingServerSnap must exist\n   *\n   * @param {!Path} treePath\n   * @param {!Path} childPath\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    treePath: Path,\n    childPath: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    assert(\n      existingEventSnap || existingServerSnap,\n      'Either existingEventSnap or existingServerSnap must exist'\n    );\n    const path = treePath.child(childPath);\n    if (this.visibleWrites_.hasCompleteWrite(path)) {\n      // At this point we can probably guarantee that we're in case 2, meaning no events\n      // May need to check visibility while doing the findRootMostValueAndPath call\n      return null;\n    } else {\n      // No complete shadowing. We're either partially shadowing or not shadowing at all.\n      const childMerge = this.visibleWrites_.childCompoundWrite(path);\n      if (childMerge.isEmpty()) {\n        // We're not shadowing at all. Case 1\n        return existingServerSnap.getChild(childPath);\n      } else {\n        // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n        // However this is tricky to find out, since user updates don't necessary change the server\n        // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n        // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n        // only check if the updates change the serverNode.\n        // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n        return childMerge.apply(existingServerSnap.getChild(childPath));\n      }\n    }\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!Path} treePath\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerSnap\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    treePath: Path,\n    childKey: string,\n    existingServerSnap: CacheNode\n  ): Node | null {\n    const path = treePath.child(childKey);\n    const shadowingNode = this.visibleWrites_.getCompleteNode(path);\n    if (shadowingNode != null) {\n      return shadowingNode;\n    } else {\n      if (existingServerSnap.isCompleteForChild(childKey)) {\n        const childMerge = this.visibleWrites_.childCompoundWrite(path);\n        return childMerge.apply(\n          existingServerSnap.getNode().getImmediateChild(childKey)\n        );\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window.\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    treePath: Path,\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    let toIterate: Node;\n    const merge = this.visibleWrites_.childCompoundWrite(treePath);\n    const shadowingNode = merge.getCompleteNode(Path.Empty);\n    if (shadowingNode != null) {\n      toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n      toIterate = merge.apply(completeServerData);\n    } else {\n      // no children to iterate on\n      return [];\n    }\n    toIterate = toIterate.withIndex(index);\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n      const nodes = [];\n      const cmp = index.getCompare();\n      const iter = reverse\n        ? (toIterate as ChildrenNode).getReverseIteratorFrom(startPost, index)\n        : (toIterate as ChildrenNode).getIteratorFrom(startPost, index);\n      let next = iter.getNext();\n      while (next && nodes.length < count) {\n        if (cmp(next, startPost) !== 0) {\n          nodes.push(next);\n        }\n        next = iter.getNext();\n      }\n      return nodes;\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * @param {!WriteRecord} writeRecord\n   * @param {!Path} path\n   * @return {boolean}\n   * @private\n   */\n  private recordContainsPath_(writeRecord: WriteRecord, path: Path): boolean {\n    if (writeRecord.snap) {\n      return writeRecord.path.contains(path);\n    } else {\n      // findKey can return undefined, so use !! to coerce to boolean\n      return !!findKey(writeRecord.children, function(\n        childSnap: Node,\n        childName: string\n      ) {\n        return writeRecord.path.child(childName).contains(path);\n      });\n    }\n  }\n\n  /**\n   * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\n   * @private\n   */\n  private resetTree_() {\n    this.visibleWrites_ = WriteTree.layerTree_(\n      this.allWrites_,\n      WriteTree.DefaultFilter_,\n      Path.Empty\n    );\n    if (this.allWrites_.length > 0) {\n      this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\n    } else {\n      this.lastWriteId_ = -1;\n    }\n  }\n\n  /**\n   * The default filter used when constructing the tree. Keep everything that's visible.\n   *\n   * @param {!WriteRecord} write\n   * @return {boolean}\n   * @private\n   */\n  private static DefaultFilter_(write: WriteRecord) {\n    return write.visible;\n  }\n\n  /**\n   * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\n   * event data at that path.\n   *\n   * @param {!Array.<!WriteRecord>} writes\n   * @param {!function(!WriteRecord):boolean} filter\n   * @param {!Path} treeRoot\n   * @return {!CompoundWrite}\n   * @private\n   */\n  private static layerTree_(\n    writes: WriteRecord[],\n    filter: (w: WriteRecord) => boolean,\n    treeRoot: Path\n  ): CompoundWrite {\n    let compoundWrite = CompoundWrite.Empty;\n    for (let i = 0; i < writes.length; ++i) {\n      const write = writes[i];\n      // Theory, a later set will either:\n      // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n      // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n      if (filter(write)) {\n        const writePath = write.path;\n        let relativePath;\n        if (write.snap) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            compoundWrite = compoundWrite.addWrite(\n              Path.Empty,\n              write.snap.getChild(relativePath)\n            );\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else if (write.children) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrites(\n              relativePath,\n              write.children\n            );\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            if (relativePath.isEmpty()) {\n              compoundWrite = compoundWrite.addWrites(\n                Path.Empty,\n                write.children\n              );\n            } else {\n              const child = safeGet(write.children, relativePath.getFront());\n              if (child) {\n                // There exists a child in this node that matches the root path\n                const deepNode = child.getChild(relativePath.popFront());\n                compoundWrite = compoundWrite.addWrite(Path.Empty, deepNode);\n              }\n            }\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else {\n          throw assertionError('WriteRecord should have .snap or .children');\n        }\n      }\n    }\n    return compoundWrite;\n  }\n}\n\n/**\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\n * just proxy to the underlying WriteTree.\n *\n * @constructor\n */\nexport class WriteTreeRef {\n  /**\n   * The path to this particular write tree ref. Used for calling methods on writeTree_ while exposing a simpler\n   * interface to callers.\n   *\n   * @type {!Path}\n   * @private\n   * @const\n   */\n  private readonly treePath_: Path;\n\n  /**\n   * * A reference to the actual tree of write data. All methods are pass-through to the tree, but with the appropriate\n   * path prefixed.\n   *\n   * This lets us make cheap references to points in the tree for sync points without having to copy and maintain all of\n   * the data.\n   *\n   * @type {!WriteTree}\n   * @private\n   * @const\n   */\n  private readonly writeTree_: WriteTree;\n\n  /**\n   * @param {!Path} path\n   * @param {!WriteTree} writeTree\n   */\n  constructor(path: Path, writeTree: WriteTree) {\n    this.treePath_ = path;\n    this.writeTree_ = writeTree;\n  }\n\n  /**\n   * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\n   * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\n   * can lead to a more expensive calculation.\n   *\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    return this.writeTree_.calcCompleteEventCache(\n      this.treePath_,\n      completeServerCache,\n      writeIdsToExclude,\n      includeHiddenWrites\n    );\n  }\n\n  /**\n   * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\n   * mix of the given server data and write data.\n   *\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    completeServerChildren: ChildrenNode | null\n  ): ChildrenNode {\n    return this.writeTree_.calcCompleteEventChildren(\n      this.treePath_,\n      completeServerChildren\n    ) as ChildrenNode;\n  }\n\n  /**\n   * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\n   * if anything, needs to be applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events should be raised\n   *\n   * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\n   *\n   * @param {!Path} path\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    path: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    return this.writeTree_.calcEventCacheAfterServerOverwrite(\n      this.treePath_,\n      path,\n      existingEventSnap,\n      existingServerSnap\n    );\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.writeTree_.shadowingWrite(this.treePath_.child(path));\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window\n   *\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    return this.writeTree_.calcIndexedSlice(\n      this.treePath_,\n      completeServerData,\n      startPost,\n      count,\n      reverse,\n      index\n    );\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerCache\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    childKey: string,\n    existingServerCache: CacheNode\n  ): Node | null {\n    return this.writeTree_.calcCompleteChild(\n      this.treePath_,\n      childKey,\n      existingServerCache\n    );\n  }\n\n  /**\n   * Return a WriteTreeRef for a child.\n   *\n   * @param {string} childName\n   * @return {!WriteTreeRef}\n   */\n  child(childName: string): WriteTreeRef {\n    return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}