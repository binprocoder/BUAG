{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Path_1 = require(\"./util/Path\");\n\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\n\nvar CountedSet_1 = require(\"./util/CountedSet\");\n/**\n * Helper class to store a sparse set of snapshots.\n *\n * @constructor\n */\n\n\nvar SparseSnapshotTree =\n/** @class */\nfunction () {\n  function SparseSnapshotTree() {\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.value_ = null;\n    /**\n     * @private\n     * @type {CountedSet}\n     */\n\n    this.children_ = null;\n  }\n  /**\n   * Gets the node stored at the given path if one exists.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {?Node} The retrieved node, or null.\n   */\n\n\n  SparseSnapshotTree.prototype.find = function (path) {\n    if (this.value_ != null) {\n      return this.value_.getChild(path);\n    } else if (!path.isEmpty() && this.children_ != null) {\n      var childKey = path.getFront();\n      path = path.popFront();\n\n      if (this.children_.contains(childKey)) {\n        var childTree = this.children_.get(childKey);\n        return childTree.find(path);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Stores the given node at the specified path. If there is already a node\n   * at a shallower path, it merges the new data into that snapshot node.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @param {!Node} data The new data, or null.\n   */\n\n\n  SparseSnapshotTree.prototype.remember = function (path, data) {\n    if (path.isEmpty()) {\n      this.value_ = data;\n      this.children_ = null;\n    } else if (this.value_ !== null) {\n      this.value_ = this.value_.updateChild(path, data);\n    } else {\n      if (this.children_ == null) {\n        this.children_ = new CountedSet_1.CountedSet();\n      }\n\n      var childKey = path.getFront();\n\n      if (!this.children_.contains(childKey)) {\n        this.children_.add(childKey, new SparseSnapshotTree());\n      }\n\n      var child = this.children_.get(childKey);\n      path = path.popFront();\n      child.remember(path, data);\n    }\n  };\n  /**\n   * Purge the data at path from the cache.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {boolean} True if this node should now be removed.\n   */\n\n\n  SparseSnapshotTree.prototype.forget = function (path) {\n    if (path.isEmpty()) {\n      this.value_ = null;\n      this.children_ = null;\n      return true;\n    } else {\n      if (this.value_ !== null) {\n        if (this.value_.isLeafNode()) {\n          // We're trying to forget a node that doesn't exist\n          return false;\n        } else {\n          var value = this.value_;\n          this.value_ = null;\n          var self_1 = this;\n          value.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, tree) {\n            self_1.remember(new Path_1.Path(key), tree);\n          });\n          return this.forget(path);\n        }\n      } else if (this.children_ !== null) {\n        var childKey = path.getFront();\n        path = path.popFront();\n\n        if (this.children_.contains(childKey)) {\n          var safeToRemove = this.children_.get(childKey).forget(path);\n\n          if (safeToRemove) {\n            this.children_.remove(childKey);\n          }\n        }\n\n        if (this.children_.isEmpty()) {\n          this.children_ = null;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    }\n  };\n  /**\n   * Recursively iterates through all of the stored tree and calls the\n   * callback on each one.\n   *\n   * @param {!Path} prefixPath Path to look up node for.\n   * @param {!Function} func The function to invoke for each tree.\n   */\n\n\n  SparseSnapshotTree.prototype.forEachTree = function (prefixPath, func) {\n    if (this.value_ !== null) {\n      func(prefixPath, this.value_);\n    } else {\n      this.forEachChild(function (key, tree) {\n        var path = new Path_1.Path(prefixPath.toString() + '/' + key);\n        tree.forEachTree(path, func);\n      });\n    }\n  };\n  /**\n   * Iterates through each immediate child and triggers the callback.\n   *\n   * @param {!Function} func The function to invoke for each child.\n   */\n\n\n  SparseSnapshotTree.prototype.forEachChild = function (func) {\n    if (this.children_ !== null) {\n      this.children_.each(function (key, tree) {\n        func(key, tree);\n      });\n    }\n  };\n\n  return SparseSnapshotTree;\n}();\n\nexports.SparseSnapshotTree = SparseSnapshotTree;","map":{"version":3,"mappings":"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","names":["SparseSnapshotTree","path","value_","getChild","isEmpty","children_","childKey","getFront","popFront","contains","childTree","get","find","data","updateChild","CountedSet_1","add","child","remember","isLeafNode","value","self_1","forEachChild","PriorityIndex_1","key","tree","Path_1","forget","safeToRemove","remove","prefixPath","func","toString","forEachTree","each","exports"],"sources":["../src/core/SparseSnapshotTree.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from './util/Path';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { CountedSet } from './util/CountedSet';\nimport { Node } from './snap/Node';\n\n/**\n * Helper class to store a sparse set of snapshots.\n *\n * @constructor\n */\nexport class SparseSnapshotTree {\n  /**\n   * @private\n   * @type {Node}\n   */\n  private value_: Node | null = null;\n\n  /**\n   * @private\n   * @type {CountedSet}\n   */\n  private children_: CountedSet<string, SparseSnapshotTree> | null = null;\n\n  /**\n   * Gets the node stored at the given path if one exists.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {?Node} The retrieved node, or null.\n   */\n  find(path: Path): Node | null {\n    if (this.value_ != null) {\n      return this.value_.getChild(path);\n    } else if (!path.isEmpty() && this.children_ != null) {\n      const childKey = path.getFront();\n      path = path.popFront();\n      if (this.children_.contains(childKey)) {\n        const childTree = this.children_.get(childKey) as SparseSnapshotTree;\n        return childTree.find(path);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Stores the given node at the specified path. If there is already a node\n   * at a shallower path, it merges the new data into that snapshot node.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @param {!Node} data The new data, or null.\n   */\n  remember(path: Path, data: Node) {\n    if (path.isEmpty()) {\n      this.value_ = data;\n      this.children_ = null;\n    } else if (this.value_ !== null) {\n      this.value_ = this.value_.updateChild(path, data);\n    } else {\n      if (this.children_ == null) {\n        this.children_ = new CountedSet<string, SparseSnapshotTree>();\n      }\n\n      const childKey = path.getFront();\n      if (!this.children_.contains(childKey)) {\n        this.children_.add(childKey, new SparseSnapshotTree());\n      }\n\n      const child = this.children_.get(childKey) as SparseSnapshotTree;\n      path = path.popFront();\n      child.remember(path, data);\n    }\n  }\n\n  /**\n   * Purge the data at path from the cache.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {boolean} True if this node should now be removed.\n   */\n  forget(path: Path): boolean {\n    if (path.isEmpty()) {\n      this.value_ = null;\n      this.children_ = null;\n      return true;\n    } else {\n      if (this.value_ !== null) {\n        if (this.value_.isLeafNode()) {\n          // We're trying to forget a node that doesn't exist\n          return false;\n        } else {\n          const value = this.value_;\n          this.value_ = null;\n\n          const self = this;\n          value.forEachChild(PRIORITY_INDEX, function(key, tree) {\n            self.remember(new Path(key), tree);\n          });\n\n          return this.forget(path);\n        }\n      } else if (this.children_ !== null) {\n        const childKey = path.getFront();\n        path = path.popFront();\n        if (this.children_.contains(childKey)) {\n          const safeToRemove = (this.children_.get(\n            childKey\n          ) as SparseSnapshotTree).forget(path);\n          if (safeToRemove) {\n            this.children_.remove(childKey);\n          }\n        }\n\n        if (this.children_.isEmpty()) {\n          this.children_ = null;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Recursively iterates through all of the stored tree and calls the\n   * callback on each one.\n   *\n   * @param {!Path} prefixPath Path to look up node for.\n   * @param {!Function} func The function to invoke for each tree.\n   */\n  forEachTree(prefixPath: Path, func: (a: Path, b: Node) => any) {\n    if (this.value_ !== null) {\n      func(prefixPath, this.value_);\n    } else {\n      this.forEachChild((key, tree) => {\n        const path = new Path(prefixPath.toString() + '/' + key);\n        tree.forEachTree(path, func);\n      });\n    }\n  }\n\n  /**\n   * Iterates through each immediate child and triggers the callback.\n   *\n   * @param {!Function} func The function to invoke for each child.\n   */\n  forEachChild(func: (a: string, b: SparseSnapshotTree) => void) {\n    if (this.children_ !== null) {\n      this.children_.each((key, tree) => {\n        func(key, tree);\n      });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}