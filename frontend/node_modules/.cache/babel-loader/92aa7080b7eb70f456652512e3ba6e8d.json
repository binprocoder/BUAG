{"ast":null,"code":"/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nimport * as json from './json';\nimport { Location } from './location';\nimport * as path from './path';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nexport function noXform_(metadata, value) {\n  return value;\n}\n/**\r\n * @struct\r\n */\n\nvar Mapping =\n/** @class */\nfunction () {\n  function Mapping(server, opt_local, opt_writable, opt_xform) {\n    this.server = server;\n    this.local = opt_local || server;\n    this.writable = !!opt_writable;\n    this.xform = opt_xform || noXform_;\n  }\n\n  return Mapping;\n}();\n\nexport { Mapping };\nvar mappings_ = null;\nexport function xformPath(fullPath) {\n  var valid = type.isString(fullPath);\n\n  if (!valid || fullPath.length < 2) {\n    return fullPath;\n  } else {\n    fullPath = fullPath;\n    return path.lastComponent(fullPath);\n  }\n}\nexport function getMappings() {\n  if (mappings_) {\n    return mappings_;\n  }\n\n  var mappings = [];\n  mappings.push(new Mapping('bucket'));\n  mappings.push(new Mapping('generation'));\n  mappings.push(new Mapping('metageneration'));\n  mappings.push(new Mapping('name', 'fullPath', true));\n\n  function mappingsXformPath(metadata, fullPath) {\n    return xformPath(fullPath);\n  }\n\n  var nameMapping = new Mapping('name');\n  nameMapping.xform = mappingsXformPath;\n  mappings.push(nameMapping);\n  /**\r\n   * Coerces the second param to a number, if it is defined.\r\n   */\n\n  function xformSize(metadata, size) {\n    if (type.isDef(size)) {\n      return +size;\n    } else {\n      return size;\n    }\n  }\n\n  var sizeMapping = new Mapping('size');\n  sizeMapping.xform = xformSize;\n  mappings.push(sizeMapping);\n  mappings.push(new Mapping('timeCreated'));\n  mappings.push(new Mapping('updated'));\n  mappings.push(new Mapping('md5Hash', null, true));\n  mappings.push(new Mapping('cacheControl', null, true));\n  mappings.push(new Mapping('contentDisposition', null, true));\n  mappings.push(new Mapping('contentEncoding', null, true));\n  mappings.push(new Mapping('contentLanguage', null, true));\n  mappings.push(new Mapping('contentType', null, true));\n  mappings.push(new Mapping('metadata', 'customMetadata', true));\n  /**\r\n   * Transforms a comma-separated string of tokens into a list of download\r\n   * URLs.\r\n   */\n\n  function xformTokens(metadata, tokens) {\n    var valid = type.isString(tokens) && tokens.length > 0;\n\n    if (!valid) {\n      // This can happen if objects are uploaded through GCS and retrieved\n      // through list, so we don't want to throw an Error.\n      return [];\n    }\n\n    var encode = encodeURIComponent;\n    var tokensList = tokens.split(',');\n    var urls = tokensList.map(function (token) {\n      var bucket = metadata['bucket'];\n      var path = metadata['fullPath'];\n      var urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n      var base = UrlUtils.makeDownloadUrl(urlPart);\n      var queryString = UrlUtils.makeQueryString({\n        alt: 'media',\n        token: token\n      });\n      return base + queryString;\n    });\n    return urls;\n  }\n\n  mappings.push(new Mapping('downloadTokens', 'downloadURLs', false, xformTokens));\n  mappings_ = mappings;\n  return mappings_;\n}\nexport function addRef(metadata, authWrapper) {\n  function generateRef() {\n    var bucket = metadata['bucket'];\n    var path = metadata['fullPath'];\n    var loc = new Location(bucket, path);\n    return authWrapper.makeStorageReference(loc);\n  }\n\n  Object.defineProperty(metadata, 'ref', {\n    get: generateRef\n  });\n}\nexport function fromResource(authWrapper, resource, mappings) {\n  var metadata = {};\n  metadata['type'] = 'file';\n  var len = mappings.length;\n\n  for (var i = 0; i < len; i++) {\n    var mapping = mappings[i];\n    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n  }\n\n  addRef(metadata, authWrapper);\n  return metadata;\n}\nexport function fromResourceString(authWrapper, resourceString, mappings) {\n  var obj = json.jsonObjectOrNull(resourceString);\n\n  if (obj === null) {\n    return null;\n  }\n\n  var resource = obj;\n  return fromResource(authWrapper, resource, mappings);\n}\nexport function toResourceString(metadata, mappings) {\n  var resource = {};\n  var len = mappings.length;\n\n  for (var i = 0; i < len; i++) {\n    var mapping = mappings[i];\n\n    if (mapping.writable) {\n      resource[mapping.server] = metadata[mapping.local];\n    }\n  }\n\n  return JSON.stringify(resource);\n}\nexport function metadataValidator(p) {\n  var validType = p && type.isObject(p);\n\n  if (!validType) {\n    throw 'Expected Metadata object.';\n  }\n\n  for (var key in p) {\n    var val = p[key];\n\n    if (key === 'customMetadata') {\n      if (!type.isObject(val)) {\n        throw 'Expected object for \\'customMetadata\\' mapping.';\n      }\n    } else {\n      if (type.isNonNullObject(val)) {\n        throw \"Mapping for '\" + key + \"' cannot be an object.\";\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["json","Location","path","type","UrlUtils","metadata","value","server","opt_local","opt_writable","opt_xform","local","writable","xform","noXform_","mappings_","fullPath","valid","isString","length","lastComponent","mappings","push","Mapping","xformPath","nameMapping","mappingsXformPath","size","isDef","sizeMapping","xformSize","tokens","encode","encodeURIComponent","tokensList","split","urls","map","token","bucket","urlPart","base","makeDownloadUrl","queryString","makeQueryString","alt","xformTokens","authWrapper","loc","makeStorageReference","Object","defineProperty","get","generateRef","resource","len","i","mapping","addRef","resourceString","obj","jsonObjectOrNull","fromResource","JSON","stringify","p","validType","isObject","key","val","isNonNullObject"],"sources":["../src/implementation/metadata.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Documentation for the metadata format\n */\nimport { Metadata } from '../metadata';\n\nimport { AuthWrapper } from './authwrapper';\nimport * as json from './json';\nimport { Location } from './location';\nimport * as path from './path';\nimport * as type from './type';\nimport * as UrlUtils from './url';\n\nexport function noXform_(metadata: Metadata, value: any): any {\n  return value;\n}\n\n/**\n * @struct\n */\nexport class Mapping {\n  local: string;\n  writable: boolean;\n  xform: (p1: Metadata, p2: any) => any;\n\n  constructor(\n    public server: string,\n    opt_local?: string | null,\n    opt_writable?: boolean,\n    opt_xform?: (p1: Metadata, p2: any) => any | null\n  ) {\n    this.local = opt_local || server;\n    this.writable = !!opt_writable;\n    this.xform = opt_xform || noXform_;\n  }\n}\ntype Mappings = Mapping[];\n\nexport { Mappings };\n\nlet mappings_: Mappings | null = null;\n\nexport function xformPath(fullPath: any): string {\n  let valid = type.isString(fullPath);\n  if (!valid || fullPath.length < 2) {\n    return fullPath;\n  } else {\n    fullPath = fullPath as string;\n    return path.lastComponent(fullPath);\n  }\n}\n\nexport function getMappings(): Mappings {\n  if (mappings_) {\n    return mappings_;\n  }\n  let mappings = [];\n  mappings.push(new Mapping('bucket'));\n  mappings.push(new Mapping('generation'));\n  mappings.push(new Mapping('metageneration'));\n  mappings.push(new Mapping('name', 'fullPath', true));\n\n  function mappingsXformPath(metadata: Metadata, fullPath: any): string {\n    return xformPath(fullPath);\n  }\n  let nameMapping = new Mapping('name');\n  nameMapping.xform = mappingsXformPath;\n  mappings.push(nameMapping);\n\n  /**\n   * Coerces the second param to a number, if it is defined.\n   */\n  function xformSize(metadata: Metadata, size: any): number | null | undefined {\n    if (type.isDef(size)) {\n      return +(size as number);\n    } else {\n      return size;\n    }\n  }\n  let sizeMapping = new Mapping('size');\n  sizeMapping.xform = xformSize;\n  mappings.push(sizeMapping);\n  mappings.push(new Mapping('timeCreated'));\n  mappings.push(new Mapping('updated'));\n  mappings.push(new Mapping('md5Hash', null, true));\n  mappings.push(new Mapping('cacheControl', null, true));\n  mappings.push(new Mapping('contentDisposition', null, true));\n  mappings.push(new Mapping('contentEncoding', null, true));\n  mappings.push(new Mapping('contentLanguage', null, true));\n  mappings.push(new Mapping('contentType', null, true));\n  mappings.push(new Mapping('metadata', 'customMetadata', true));\n\n  /**\n   * Transforms a comma-separated string of tokens into a list of download\n   * URLs.\n   */\n  function xformTokens(metadata: Metadata, tokens: any): string[] {\n    let valid = type.isString(tokens) && tokens.length > 0;\n    if (!valid) {\n      // This can happen if objects are uploaded through GCS and retrieved\n      // through list, so we don't want to throw an Error.\n      return [];\n    }\n    let encode = encodeURIComponent;\n    let tokensList = tokens.split(',');\n    let urls = tokensList.map(function(token: string) {\n      let bucket: string = metadata['bucket'] as string;\n      let path: string = metadata['fullPath'] as string;\n      let urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n      let base = UrlUtils.makeDownloadUrl(urlPart);\n      let queryString = UrlUtils.makeQueryString({\n        alt: 'media',\n        token: token\n      });\n      return base + queryString;\n    });\n    return urls;\n  }\n  mappings.push(\n    new Mapping('downloadTokens', 'downloadURLs', false, xformTokens)\n  );\n  mappings_ = mappings;\n  return mappings_;\n}\n\nexport function addRef(metadata: Metadata, authWrapper: AuthWrapper) {\n  function generateRef() {\n    let bucket: string = metadata['bucket'] as string;\n    let path: string = metadata['fullPath'] as string;\n    let loc = new Location(bucket, path);\n    return authWrapper.makeStorageReference(loc);\n  }\n  Object.defineProperty(metadata, 'ref', { get: generateRef });\n}\n\nexport function fromResource(\n  authWrapper: AuthWrapper,\n  resource: { [name: string]: any },\n  mappings: Mappings\n): Metadata {\n  let metadata: Metadata = {} as Metadata;\n  metadata['type'] = 'file';\n  let len = mappings.length;\n  for (let i = 0; i < len; i++) {\n    let mapping = mappings[i];\n    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n  }\n  addRef(metadata, authWrapper);\n  return metadata;\n}\n\nexport function fromResourceString(\n  authWrapper: AuthWrapper,\n  resourceString: string,\n  mappings: Mappings\n): Metadata | null {\n  let obj = json.jsonObjectOrNull(resourceString);\n  if (obj === null) {\n    return null;\n  }\n  let resource = obj as Metadata;\n  return fromResource(authWrapper, resource, mappings);\n}\n\nexport function toResourceString(\n  metadata: Metadata,\n  mappings: Mappings\n): string {\n  let resource: {\n    [prop: string]: any;\n  } = {};\n  let len = mappings.length;\n  for (let i = 0; i < len; i++) {\n    let mapping = mappings[i];\n    if (mapping.writable) {\n      resource[mapping.server] = metadata[mapping.local];\n    }\n  }\n  return JSON.stringify(resource);\n}\n\nexport function metadataValidator(p: any) {\n  let validType = p && type.isObject(p);\n  if (!validType) {\n    throw 'Expected Metadata object.';\n  }\n  for (let key in p) {\n    let val = p[key];\n    if (key === 'customMetadata') {\n      if (!type.isObject(val)) {\n        throw 'Expected object for \\'customMetadata\\' mapping.';\n      }\n    } else {\n      if (type.isNonNullObject(val)) {\n        throw \"Mapping for '\" + key + \"' cannot be an object.\";\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}