{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar IndexedFilter_1 = require(\"./IndexedFilter\");\n\nvar PriorityIndex_1 = require(\"../../snap/indexes/PriorityIndex\");\n\nvar Node_1 = require(\"../../../core/snap/Node\");\n\nvar ChildrenNode_1 = require(\"../../snap/ChildrenNode\");\n/**\r\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\r\n *\r\n * @constructor\r\n * @implements {NodeFilter}\r\n */\n\n\nvar RangedFilter =\n/** @class */\nfunction () {\n  /**\r\n   * @param {!QueryParams} params\r\n   */\n  function RangedFilter(params) {\n    this.indexedFilter_ = new IndexedFilter_1.IndexedFilter(params.getIndex());\n    this.index_ = params.getIndex();\n    this.startPost_ = RangedFilter.getStartPost_(params);\n    this.endPost_ = RangedFilter.getEndPost_(params);\n  }\n  /**\r\n   * @return {!NamedNode}\r\n   */\n\n\n  RangedFilter.prototype.getStartPost = function () {\n    return this.startPost_;\n  };\n  /**\r\n   * @return {!NamedNode}\r\n   */\n\n\n  RangedFilter.prototype.getEndPost = function () {\n    return this.endPost_;\n  };\n  /**\r\n   * @param {!NamedNode} node\r\n   * @return {boolean}\r\n   */\n\n\n  RangedFilter.prototype.matches = function (node) {\n    return this.index_.compare(this.getStartPost(), node) <= 0 && this.index_.compare(node, this.getEndPost()) <= 0;\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  RangedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n    if (!this.matches(new Node_1.NamedNode(key, newChild))) {\n      newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    }\n\n    return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  RangedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n    if (newSnap.isLeafNode()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      newSnap = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    }\n\n    var filtered = newSnap.withIndex(this.index_); // Don't support priorities on queries\n\n    filtered = filtered.updatePriority(ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n    var self = this;\n    newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n      if (!self.matches(new Node_1.NamedNode(key, childNode))) {\n        filtered = filtered.updateImmediateChild(key, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n      }\n    });\n    return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  RangedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n    // Don't support priorities on queries\n    return oldSnap;\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  RangedFilter.prototype.filtersNodes = function () {\n    return true;\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  RangedFilter.prototype.getIndexedFilter = function () {\n    return this.indexedFilter_;\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  RangedFilter.prototype.getIndex = function () {\n    return this.index_;\n  };\n  /**\r\n   * @param {!QueryParams} params\r\n   * @return {!NamedNode}\r\n   * @private\r\n   */\n\n\n  RangedFilter.getStartPost_ = function (params) {\n    if (params.hasStart()) {\n      var startName = params.getIndexStartName();\n      return params.getIndex().makePost(params.getIndexStartValue(), startName);\n    } else {\n      return params.getIndex().minPost();\n    }\n  };\n  /**\r\n   * @param {!QueryParams} params\r\n   * @return {!NamedNode}\r\n   * @private\r\n   */\n\n\n  RangedFilter.getEndPost_ = function (params) {\n    if (params.hasEnd()) {\n      var endName = params.getIndexEndName();\n      return params.getIndex().makePost(params.getIndexEndValue(), endName);\n    } else {\n      return params.getIndex().maxPost();\n    }\n  };\n\n  return RangedFilter;\n}();\n\nexports.RangedFilter = RangedFilter;","map":{"version":3,"mappings":"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","names":["params","indexedFilter_","IndexedFilter_1","getIndex","index_","startPost_","RangedFilter","getStartPost_","endPost_","getEndPost_","node","compare","getStartPost","getEndPost","snap","key","newChild","affectedPath","source","optChangeAccumulator","matches","Node_1","ChildrenNode_1","EMPTY_NODE","updateChild","oldSnap","newSnap","isLeafNode","filtered","withIndex","updatePriority","self","forEachChild","PriorityIndex_1","childNode","updateImmediateChild","updateFullNode","newPriority","hasStart","startName","getIndexStartName","makePost","getIndexStartValue","minPost","hasEnd","endName","getIndexEndName","getIndexEndValue","maxPost","exports"],"sources":["../src/core/view/filter/RangedFilter.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexedFilter } from './IndexedFilter';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NamedNode, Node } from '../../../core/snap/Node';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { NodeFilter } from './NodeFilter';\nimport { QueryParams } from '../QueryParams';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\n\n/**\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\n *\n * @constructor\n * @implements {NodeFilter}\n */\nexport class RangedFilter implements NodeFilter {\n  /**\n   * @type {!IndexedFilter}\n   * @const\n   * @private\n   */\n  private indexedFilter_: IndexedFilter;\n\n  /**\n   * @const\n   * @type {!Index}\n   * @private\n   */\n  private index_: Index;\n\n  /**\n   * @const\n   * @type {!NamedNode}\n   * @private\n   */\n  private startPost_: NamedNode;\n\n  /**\n   * @const\n   * @type {!NamedNode}\n   * @private\n   */\n  private endPost_: NamedNode;\n\n  /**\n   * @param {!QueryParams} params\n   */\n  constructor(params: QueryParams) {\n    this.indexedFilter_ = new IndexedFilter(params.getIndex());\n    this.index_ = params.getIndex();\n    this.startPost_ = RangedFilter.getStartPost_(params);\n    this.endPost_ = RangedFilter.getEndPost_(params);\n  }\n\n  /**\n   * @return {!NamedNode}\n   */\n  getStartPost(): NamedNode {\n    return this.startPost_;\n  }\n\n  /**\n   * @return {!NamedNode}\n   */\n  getEndPost(): NamedNode {\n    return this.endPost_;\n  }\n\n  /**\n   * @param {!NamedNode} node\n   * @return {boolean}\n   */\n  matches(node: NamedNode): boolean {\n    return (\n      this.index_.compare(this.getStartPost(), node) <= 0 &&\n      this.index_.compare(node, this.getEndPost()) <= 0\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (!this.matches(new NamedNode(key, newChild))) {\n      newChild = ChildrenNode.EMPTY_NODE;\n    }\n    return this.indexedFilter_.updateChild(\n      snap,\n      key,\n      newChild,\n      affectedPath,\n      source,\n      optChangeAccumulator\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (newSnap.isLeafNode()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      newSnap = ChildrenNode.EMPTY_NODE;\n    }\n    let filtered = newSnap.withIndex(this.index_);\n    // Don't support priorities on queries\n    filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n    const self = this;\n    newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n      if (!self.matches(new NamedNode(key, childNode))) {\n        filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\n      }\n    });\n    return this.indexedFilter_.updateFullNode(\n      oldSnap,\n      filtered,\n      optChangeAccumulator\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    // Don't support priorities on queries\n    return oldSnap;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this.indexedFilter_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n  private static getStartPost_(params: QueryParams): NamedNode {\n    if (params.hasStart()) {\n      const startName = params.getIndexStartName();\n      return params.getIndex().makePost(params.getIndexStartValue(), startName);\n    } else {\n      return params.getIndex().minPost();\n    }\n  }\n\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n  private static getEndPost_(params: QueryParams): NamedNode {\n    if (params.hasEnd()) {\n      const endName = params.getIndexEndName();\n      return params.getIndex().makePost(params.getIndexEndValue(), endName);\n    } else {\n      return params.getIndex().maxPost();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}