{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DataSnapshot_1 = require(\"../../api/DataSnapshot\");\n\nvar Event_1 = require(\"./Event\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"@firebase/util\");\n/**\r\n * Represents registration for 'value' events.\r\n */\n\n\nvar ValueEventRegistration =\n/** @class */\nfunction () {\n  /**\r\n   * @param {?function(!DataSnapshot)} callback_\r\n   * @param {?function(Error)} cancelCallback_\r\n   * @param {?Object} context_\r\n   */\n  function ValueEventRegistration(callback_, cancelCallback_, context_) {\n    this.callback_ = callback_;\n    this.cancelCallback_ = cancelCallback_;\n    this.context_ = context_;\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ValueEventRegistration.prototype.respondsTo = function (eventType) {\n    return eventType === 'value';\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ValueEventRegistration.prototype.createEvent = function (change, query) {\n    var index = query.getQueryParams().getIndex();\n    return new Event_1.DataEvent('value', this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, query.getRef(), index));\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ValueEventRegistration.prototype.getEventRunner = function (eventData) {\n    var ctx = this.context_;\n\n    if (eventData.getEventType() === 'cancel') {\n      util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');\n      var cancelCB_1 = this.cancelCallback_;\n      return function () {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB_1.call(ctx, eventData.error);\n      };\n    } else {\n      var cb_1 = this.callback_;\n      return function () {\n        cb_1.call(ctx, eventData.snapshot);\n      };\n    }\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ValueEventRegistration.prototype.createCancelEvent = function (error, path) {\n    if (this.cancelCallback_) {\n      return new Event_1.CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ValueEventRegistration.prototype.matches = function (other) {\n    if (!(other instanceof ValueEventRegistration)) {\n      return false;\n    } else if (!other.callback_ || !this.callback_) {\n      // If no callback specified, we consider it to match any callback.\n      return true;\n    } else {\n      return other.callback_ === this.callback_ && other.context_ === this.context_;\n    }\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ValueEventRegistration.prototype.hasAnyCallback = function () {\n    return this.callback_ !== null;\n  };\n\n  return ValueEventRegistration;\n}();\n\nexports.ValueEventRegistration = ValueEventRegistration;\n/**\r\n * Represents the registration of 1 or more child_xxx events.\r\n *\r\n * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you\r\n * register a group of callbacks together in the future.\r\n *\r\n * @constructor\r\n * @implements {EventRegistration}\r\n */\n\nvar ChildEventRegistration =\n/** @class */\nfunction () {\n  /**\r\n   * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_\r\n   * @param {?function(Error)} cancelCallback_\r\n   * @param {Object=} context_\r\n   */\n  function ChildEventRegistration(callbacks_, cancelCallback_, context_) {\n    this.callbacks_ = callbacks_;\n    this.cancelCallback_ = cancelCallback_;\n    this.context_ = context_;\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ChildEventRegistration.prototype.respondsTo = function (eventType) {\n    var eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;\n    eventToCheck = eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\n    return util_1.contains(this.callbacks_, eventToCheck);\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ChildEventRegistration.prototype.createCancelEvent = function (error, path) {\n    if (this.cancelCallback_) {\n      return new Event_1.CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ChildEventRegistration.prototype.createEvent = function (change, query) {\n    util_2.assert(change.childName != null, 'Child events should have a childName.');\n    var ref = query.getRef().child(\n    /** @type {!string} */\n    change.childName);\n    var index = query.getQueryParams().getIndex();\n    return new Event_1.DataEvent(change.type, this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, ref, index), change.prevName);\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ChildEventRegistration.prototype.getEventRunner = function (eventData) {\n    var ctx = this.context_;\n\n    if (eventData.getEventType() === 'cancel') {\n      util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');\n      var cancelCB_2 = this.cancelCallback_;\n      return function () {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB_2.call(ctx, eventData.error);\n      };\n    } else {\n      var cb_2 = this.callbacks_[eventData.eventType];\n      return function () {\n        cb_2.call(ctx, eventData.snapshot, eventData.prevName);\n      };\n    }\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ChildEventRegistration.prototype.matches = function (other) {\n    if (other instanceof ChildEventRegistration) {\n      if (!this.callbacks_ || !other.callbacks_) {\n        return true;\n      } else if (this.context_ === other.context_) {\n        var otherCount = util_1.getCount(other.callbacks_);\n        var thisCount = util_1.getCount(this.callbacks_);\n\n        if (otherCount === thisCount) {\n          // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.\n          //  If event types don't match, not a match\n          // If count is not 1, exact match across all\n          if (otherCount === 1) {\n            var otherKey\n            /** @type {!string} */\n            = util_1.getAnyKey(other.callbacks_);\n            var thisKey\n            /** @type {!string} */\n            = util_1.getAnyKey(this.callbacks_);\n            return thisKey === otherKey && (!other.callbacks_[otherKey] || !this.callbacks_[thisKey] || other.callbacks_[otherKey] === this.callbacks_[thisKey]);\n          } else {\n            // Exact match on each key.\n            return util_1.every(this.callbacks_, function (eventType, cb) {\n              return other.callbacks_[eventType] === cb;\n            });\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  ChildEventRegistration.prototype.hasAnyCallback = function () {\n    return this.callbacks_ !== null;\n  };\n\n  return ChildEventRegistration;\n}();\n\nexports.ChildEventRegistration = ChildEventRegistration;","map":{"version":3,"mappings":"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","names":["callback_","cancelCallback_","context_","ValueEventRegistration","eventType","change","query","index","getQueryParams","getIndex","Event_1","DataSnapshot_1","snapshotNode","getRef","eventData","ctx","getEventType","util_2","cancelCB_1","call","error","cb_1","snapshot","path","other","exports","callbacks_","ChildEventRegistration","eventToCheck","util_1","childName","ref","child","type","prevName","cancelCB_2","cb_2","otherCount","thisCount","otherKey","thisKey","cb"],"sources":["../src/core/view/EventRegistration.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataSnapshot } from '../../api/DataSnapshot';\nimport { DataEvent, CancelEvent, Event } from './Event';\nimport { contains, getCount, getAnyKey, every } from '@firebase/util';\nimport { assert } from '@firebase/util';\nimport { Path } from '../util/Path';\nimport { Change } from './Change';\nimport { Query } from '../../api/Query';\n\n/**\n * An EventRegistration is basically an event type ('value', 'child_added', etc.) and a callback\n * to be notified of that type of event.\n *\n * That said, it can also contain a cancel callback to be notified if the event is canceled.  And\n * currently, this code is organized around the idea that you would register multiple child_ callbacks\n * together, as a single EventRegistration.  Though currently we don't do that.\n */\nexport interface EventRegistration {\n  /**\n   * True if this container has a callback to trigger for this event type\n   * @param {!string} eventType\n   * @return {boolean}\n   */\n  respondsTo(eventType: string): boolean;\n\n  /**\n   * @param {!Change} change\n   * @param {!Query} query\n   * @return {!Event}\n   */\n  createEvent(change: Change, query: Query): Event;\n\n  /**\n   * Given event data, return a function to trigger the user's callback\n   * @param {!Event} eventData\n   * @return {function()}\n   */\n  getEventRunner(eventData: Event): () => void;\n\n  /**\n   * @param {!Error} error\n   * @param {!Path} path\n   * @return {?CancelEvent}\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null;\n\n  /**\n   * @param {!EventRegistration} other\n   * @return {boolean}\n   */\n  matches(other: EventRegistration): boolean;\n\n  /**\n   * False basically means this is a \"dummy\" callback container being used as a sentinel\n   * to remove all callback containers of a particular type.  (e.g. if the user does\n   * ref.off('value') without specifying a specific callback).\n   *\n   * (TODO: Rework this, since it's hacky)\n   *\n   * @return {boolean}\n   */\n  hasAnyCallback(): boolean;\n}\n\n/**\n * Represents registration for 'value' events.\n */\nexport class ValueEventRegistration implements EventRegistration {\n  /**\n   * @param {?function(!DataSnapshot)} callback_\n   * @param {?function(Error)} cancelCallback_\n   * @param {?Object} context_\n   */\n  constructor(\n    private callback_: ((d: DataSnapshot) => void) | null,\n    private cancelCallback_: ((e: Error) => void) | null,\n    private context_: Object | null\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  respondsTo(eventType: string): boolean {\n    return eventType === 'value';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createEvent(change: Change, query: Query): DataEvent {\n    const index = query.getQueryParams().getIndex();\n    return new DataEvent(\n      'value',\n      this,\n      new DataSnapshot(change.snapshotNode, query.getRef(), index)\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(eventData: CancelEvent | DataEvent): () => void {\n    const ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      assert(\n        this.cancelCallback_,\n        'Raising a cancel event on a listener with no cancel callback'\n      );\n      const cancelCB = this.cancelCallback_;\n      return function() {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB.call(ctx, (eventData as CancelEvent).error);\n      };\n    } else {\n      const cb = this.callback_;\n      return function() {\n        cb.call(ctx, (eventData as DataEvent).snapshot);\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null {\n    if (this.cancelCallback_) {\n      return new CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  matches(other: EventRegistration): boolean {\n    if (!(other instanceof ValueEventRegistration)) {\n      return false;\n    } else if (!other.callback_ || !this.callback_) {\n      // If no callback specified, we consider it to match any callback.\n      return true;\n    } else {\n      return (\n        other.callback_ === this.callback_ && other.context_ === this.context_\n      );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasAnyCallback(): boolean {\n    return this.callback_ !== null;\n  }\n}\n\n/**\n * Represents the registration of 1 or more child_xxx events.\n *\n * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you\n * register a group of callbacks together in the future.\n *\n * @constructor\n * @implements {EventRegistration}\n */\nexport class ChildEventRegistration implements EventRegistration {\n  /**\n   * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_\n   * @param {?function(Error)} cancelCallback_\n   * @param {Object=} context_\n   */\n  constructor(\n    private callbacks_:\n      | ({ [k: string]: (d: DataSnapshot, s?: string | null) => void })\n      | null,\n    private cancelCallback_: ((e: Error) => void) | null,\n    private context_?: Object\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  respondsTo(eventType: string): boolean {\n    let eventToCheck =\n      eventType === 'children_added' ? 'child_added' : eventType;\n    eventToCheck =\n      eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\n    return contains(this.callbacks_, eventToCheck);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null {\n    if (this.cancelCallback_) {\n      return new CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createEvent(change: Change, query: Query): DataEvent {\n    assert(change.childName != null, 'Child events should have a childName.');\n    const ref = query.getRef().child(/** @type {!string} */ (change.childName));\n    const index = query.getQueryParams().getIndex();\n    return new DataEvent(\n      change.type as any,\n      this,\n      new DataSnapshot(change.snapshotNode, ref, index as any),\n      change.prevName\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(eventData: CancelEvent | DataEvent): () => void {\n    const ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      assert(\n        this.cancelCallback_,\n        'Raising a cancel event on a listener with no cancel callback'\n      );\n      const cancelCB = this.cancelCallback_;\n      return function() {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB.call(ctx, (eventData as CancelEvent).error);\n      };\n    } else {\n      const cb = this.callbacks_[(eventData as DataEvent).eventType];\n      return function() {\n        cb.call(\n          ctx,\n          (eventData as DataEvent).snapshot,\n          (eventData as DataEvent).prevName\n        );\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  matches(other: EventRegistration): boolean {\n    if (other instanceof ChildEventRegistration) {\n      if (!this.callbacks_ || !other.callbacks_) {\n        return true;\n      } else if (this.context_ === other.context_) {\n        const otherCount = getCount(other.callbacks_);\n        const thisCount = getCount(this.callbacks_);\n        if (otherCount === thisCount) {\n          // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.\n          //  If event types don't match, not a match\n          // If count is not 1, exact match across all\n\n          if (otherCount === 1) {\n            const otherKey /** @type {!string} */ = getAnyKey(other.callbacks_);\n            const thisKey /** @type {!string} */ = getAnyKey(this.callbacks_);\n            return (\n              thisKey === otherKey &&\n              (!other.callbacks_[otherKey] ||\n                !this.callbacks_[thisKey] ||\n                other.callbacks_[otherKey] === this.callbacks_[thisKey])\n            );\n          } else {\n            // Exact match on each key.\n            return every(\n              this.callbacks_,\n              (eventType, cb) => other.callbacks_[eventType] === cb\n            );\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasAnyCallback(): boolean {\n    return this.callbacks_ !== null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}