{"ast":null,"code":"'use strict';\n\nmodule.exports = {\n  request,\n  chain_requests\n};\n\nconst fetch = require('node-fetch').default;\n\nconst defaultsDeep = require('lodash/defaultsDeep');\n\nconst isPlainObject = require('lodash/isPlainObject');\n\nconst pick = require('lodash/pick');\n\nconst version = require('../package.json').version;\n\nconst objectToQueryString = require('./utils').objectToQueryString;\n\nconst MonkeyLearnError = require('./monkeylearn-error');\n\nconst MonkeyLearnResponse = require('./response');\n\nconst default_seconds_to_retry = 2;\nconst default_max_retries = 3; // adapted from rest.js https://github.com/octokit/rest.js/blob/master/lib/request/request.js\n// requestOptions will get passed to fetch, but also takes the:\n//   \"query_params\" param, which is an object\n//   \"retries\" param, which is a number\n//   \"parse_response\", which is a boolean that indicates if the response should be a MonkeyLearnResponse\n//    or a raw_response, which is an object {body, status, headers}\n//    this adds a MonkeyLearnResponse to the errors\n\nfunction request(ml, requestOptions) {\n  defaultsDeep(requestOptions, {\n    headers: {\n      // TODO: test that the user agent is working properly\n      'User-Agent': `node-sdk-${version}`,\n      'authorization': `Token ${ml.api_key}`\n    },\n    query_params: {},\n    retries: ml.settings.throttling_max_retries,\n    parse_response: true\n  });\n\n  if (requestOptions.body) {\n    defaultsDeep(requestOptions.headers, {\n      'content-type': 'application/json'\n    });\n  } // https://fetch.spec.whatwg.org/#methods\n\n\n  requestOptions.method = requestOptions.method.toUpperCase();\n\n  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {\n    requestOptions.body = JSON.stringify(requestOptions.body);\n  }\n\n  let url = `${requestOptions.url}?${objectToQueryString(requestOptions.query_params)}`;\n  let headers = {};\n  let status;\n  return fetch(url, pick(requestOptions, 'method', 'body', 'headers')).then(response => {\n    status = response.status;\n\n    for (const keyAndValue of response.headers.entries()) {\n      headers[keyAndValue[0]] = keyAndValue[1];\n    }\n\n    if (status === 429 && ml.settings.retry_if_throttled) {\n      // logic for retry if throttled\n      return response.json().then(body => {\n        let seconds_to_wait;\n\n        if (body.error_code === 'PLAN_RATE_LIMIT') {\n          seconds_to_wait = body.seconds_to_wait + 1;\n        } else if (body.error_code === 'CONCURRENCY_RATE_LIMIT') {\n          seconds_to_wait = default_seconds_to_retry;\n        } else {\n          throw new MonkeyLearnError(body.error_code, {\n            body,\n            status,\n            headers\n          }, body.detail);\n        } // based on https://stackoverflow.com/questions/39538473/using-settimeout-on-promise-chain\n\n\n        return new Promise((resolve, reject) => setTimeout(resolve, seconds_to_wait * 1000, body));\n      }).then(body => {\n        requestOptions.retries -= 1;\n\n        if (requestOptions.retries === 0) {\n          throw new MonkeyLearnError(body.error_code, {\n            body,\n            status,\n            headers\n          }, `${body.detail} [SDK reached limit of throttling retries]`);\n        }\n\n        return request(ml, requestOptions);\n      });\n    } else if (status >= 400) {\n      return response.json().then(body => {\n        throw new MonkeyLearnError(body.error_code, {\n          body,\n          status,\n          headers\n        }, body.detail);\n      });\n    }\n\n    const contentType = response.headers.get('content-type');\n\n    if (/application\\/json/.test(contentType)) {\n      return response.json() // create a raw_response\n      .then(body => {\n        return {\n          body,\n          status,\n          headers\n        };\n      });\n    } // default case\n\n\n    return response.buffer() // create a raw_response\n    .then(body => {\n      return {\n        body,\n        status,\n        headers\n      };\n    });\n  }).then(response => {\n    // The response that reaches this step may or may not be a raw_response.\n    // (depends on auto retry)\n    // If it is a parsed response, just let it through unchanged\n    if (requestOptions.parse_response && !response.hasOwnProperty('raw_responses')) {\n      return new MonkeyLearnResponse(response);\n    }\n\n    return response;\n  }).catch(error => {\n    // Transform the response inside the error (if present) into a MonkeyLearnResponse\n    // if it isn't one already.\n    if (requestOptions.parse_response && error.hasOwnProperty('response') && !error.response.hasOwnProperty('raw_responses')) {\n      error.response = new MonkeyLearnResponse(error.response);\n    }\n\n    throw error;\n  });\n} // returns a function that takes an array of batches and generates a request for each\n// the requests are done sequentially\n\n\nfunction chain_requests(ml, url) {\n  return batches => {\n    let promise = new Promise((resolve, reject) => resolve(new MonkeyLearnResponse())); // attach requests for all the batches sequentially to the original promise and return _that_\n\n    return batches.reduce((promise, batch) => promise.then(response => request(ml, {\n      url: url,\n      method: 'POST',\n      body: batch,\n      parse_response: false\n    }).then(raw_response => {\n      response._add_raw_response(raw_response);\n\n      return response;\n    }).catch(error => {\n      if (error.hasOwnProperty('response')) {\n        response._add_raw_response(error.response);\n\n        error.response = response;\n      } else {\n        // if it's not a MonkeyLearn Error (so, some other js runtime error),\n        // return as-is but add the response\n        // not the cleanest solution but I don't want the error to lose the context\n        error.response = response;\n        error.error_code = '';\n      }\n\n      throw error;\n    })), promise);\n  };\n}","map":{"version":3,"sources":["C:/Users/Admin/Desktop/BUAG/frontend/node_modules/monkeylearn/lib/request.js"],"names":["module","exports","request","chain_requests","fetch","require","default","defaultsDeep","isPlainObject","pick","version","objectToQueryString","MonkeyLearnError","MonkeyLearnResponse","default_seconds_to_retry","default_max_retries","ml","requestOptions","headers","api_key","query_params","retries","settings","throttling_max_retries","parse_response","body","method","toUpperCase","Array","isArray","JSON","stringify","url","status","then","response","keyAndValue","entries","retry_if_throttled","json","seconds_to_wait","error_code","detail","Promise","resolve","reject","setTimeout","contentType","get","test","buffer","hasOwnProperty","catch","error","batches","promise","reduce","batch","raw_response","_add_raw_response"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nmodule.exports = {request, chain_requests};\r\n\r\nconst fetch = require('node-fetch').default;\r\nconst defaultsDeep = require('lodash/defaultsDeep');\r\nconst isPlainObject = require('lodash/isPlainObject');\r\nconst pick = require('lodash/pick');\r\n\r\nconst version = require('../package.json').version;\r\nconst objectToQueryString = require('./utils').objectToQueryString;\r\nconst MonkeyLearnError = require('./monkeylearn-error');\r\nconst MonkeyLearnResponse = require('./response');\r\n\r\nconst default_seconds_to_retry = 2;\r\nconst default_max_retries = 3;\r\n\r\n// adapted from rest.js https://github.com/octokit/rest.js/blob/master/lib/request/request.js\r\n// requestOptions will get passed to fetch, but also takes the:\r\n//   \"query_params\" param, which is an object\r\n//   \"retries\" param, which is a number\r\n//   \"parse_response\", which is a boolean that indicates if the response should be a MonkeyLearnResponse\r\n//    or a raw_response, which is an object {body, status, headers}\r\n//    this adds a MonkeyLearnResponse to the errors\r\nfunction request(ml, requestOptions) {\r\n\r\n  defaultsDeep(requestOptions, {\r\n    headers: {\r\n      // TODO: test that the user agent is working properly\r\n      'User-Agent': `node-sdk-${version}`,\r\n      'authorization': `Token ${ml.api_key}`\r\n    },\r\n    query_params: {},\r\n    retries: ml.settings.throttling_max_retries,\r\n    parse_response: true,\r\n  })\r\n\r\n  if (requestOptions.body) {\r\n    defaultsDeep(requestOptions.headers, {\r\n      'content-type': 'application/json'\r\n    })\r\n  }\r\n\r\n  // https://fetch.spec.whatwg.org/#methods\r\n  requestOptions.method = requestOptions.method.toUpperCase();\r\n\r\n  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {\r\n    requestOptions.body = JSON.stringify(requestOptions.body);\r\n  }\r\n\r\n  let url = `${requestOptions.url}?${objectToQueryString(requestOptions.query_params)}`\r\n\r\n  let headers = {};\r\n  let status;\r\n\r\n  return fetch(url, pick(requestOptions, 'method', 'body', 'headers'))\r\n    .then(response => {\r\n      status = response.status;\r\n      for (const keyAndValue of response.headers.entries()) {\r\n        headers[keyAndValue[0]] = keyAndValue[1]\r\n      }\r\n\r\n      if (status === 429 && ml.settings.retry_if_throttled) {\r\n        // logic for retry if throttled\r\n        return response.json()\r\n          .then(body => {\r\n            let seconds_to_wait;\r\n            if (body.error_code === 'PLAN_RATE_LIMIT') {\r\n              seconds_to_wait = body.seconds_to_wait + 1\r\n            } else if (body.error_code === 'CONCURRENCY_RATE_LIMIT') {\r\n              seconds_to_wait = default_seconds_to_retry\r\n            } else {\r\n              throw new MonkeyLearnError(body.error_code, {body, status, headers}, body.detail);\r\n            }\r\n            // based on https://stackoverflow.com/questions/39538473/using-settimeout-on-promise-chain\r\n            return new Promise((resolve, reject) => setTimeout(resolve, seconds_to_wait * 1000, body))\r\n          })\r\n\r\n          .then((body) => {\r\n            requestOptions.retries -= 1;\r\n            if (requestOptions.retries === 0) {\r\n              throw new MonkeyLearnError(body.error_code, {body, status, headers}, `${body.detail} [SDK reached limit of throttling retries]`);\r\n            }\r\n            return request(ml, requestOptions);\r\n          })\r\n\r\n      } else if (status >= 400) {\r\n        return response.json()\r\n          .then(body => {\r\n            throw new MonkeyLearnError(body.error_code, {body, status, headers}, body.detail);\r\n          })\r\n      }\r\n\r\n      const contentType = response.headers.get('content-type')\r\n      if (/application\\/json/.test(contentType)) {\r\n        return response.json()\r\n          // create a raw_response\r\n          .then(body => {return {body, status, headers}})\r\n      }\r\n\r\n      // default case\r\n      return response.buffer()\r\n        // create a raw_response\r\n        .then(body => {return {body, status, headers}})\r\n    })\r\n\r\n    .then(response => {\r\n      // The response that reaches this step may or may not be a raw_response.\r\n      // (depends on auto retry)\r\n      // If it is a parsed response, just let it through unchanged\r\n      if (requestOptions.parse_response && !response.hasOwnProperty('raw_responses')) {\r\n        return new MonkeyLearnResponse(response);\r\n      }\r\n      return response\r\n    })\r\n\r\n    .catch(error => {\r\n      // Transform the response inside the error (if present) into a MonkeyLearnResponse\r\n      // if it isn't one already.\r\n      if (requestOptions.parse_response\r\n          && error.hasOwnProperty('response')\r\n          && !error.response.hasOwnProperty('raw_responses')) {\r\n        error.response = new MonkeyLearnResponse(error.response);\r\n      }\r\n      throw error;\r\n    })\r\n\r\n\r\n}\r\n\r\n\r\n// returns a function that takes an array of batches and generates a request for each\r\n// the requests are done sequentially\r\nfunction chain_requests(ml, url) {\r\n  return (batches) => {\r\n    let promise = new Promise((resolve, reject) => resolve(new MonkeyLearnResponse()));\r\n\r\n    // attach requests for all the batches sequentially to the original promise and return _that_\r\n    return batches.reduce((promise, batch) =>\r\n      promise.then((response) =>\r\n\r\n        request(ml, {\r\n          url: url,\r\n          method: 'POST',\r\n          body: batch,\r\n          parse_response: false\r\n        })\r\n\r\n        .then(raw_response => {\r\n          response._add_raw_response(raw_response);\r\n          return response;\r\n        })\r\n\r\n        .catch(error => {\r\n          if (error.hasOwnProperty('response')) {\r\n            response._add_raw_response(error.response);\r\n            error.response = response;\r\n          } else {\r\n            // if it's not a MonkeyLearn Error (so, some other js runtime error),\r\n            // return as-is but add the response\r\n            // not the cleanest solution but I don't want the error to lose the context\r\n            error.response = response;\r\n            error.error_code = '';\r\n          }\r\n          throw error;\r\n        })\r\n      )\r\n    , promise)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}