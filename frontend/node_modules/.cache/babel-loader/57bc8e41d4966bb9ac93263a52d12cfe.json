{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Reference_1 = require(\"../api/Reference\");\n\nvar DataSnapshot_1 = require(\"../api/DataSnapshot\");\n\nvar Path_1 = require(\"./util/Path\");\n\nvar Tree_1 = require(\"./util/Tree\");\n\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\n\nvar util_2 = require(\"./util/util\");\n\nvar ServerValues_1 = require(\"./util/ServerValues\");\n\nvar validation_1 = require(\"./util/validation\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar nodeFromJSON_1 = require(\"./snap/nodeFromJSON\");\n\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\n\nvar Repo_1 = require(\"./Repo\"); // TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\n// For now it's part of Repo, but in its own file.\n\n/**\n * @enum {number}\n */\n\n\nvar TransactionStatus;\n\n(function (TransactionStatus) {\n  // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\n  // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\n  // mismatched hash.\n  TransactionStatus[TransactionStatus[\"RUN\"] = 0] = \"RUN\"; // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\n  // or rejected yet).\n\n  TransactionStatus[TransactionStatus[\"SENT\"] = 1] = \"SENT\"; // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\n  // removed when we get a chance to prune completed ones.\n\n  TransactionStatus[TransactionStatus[\"COMPLETED\"] = 2] = \"COMPLETED\"; // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\n  // If it comes back as unsuccessful, we'll abort it.\n\n  TransactionStatus[TransactionStatus[\"SENT_NEEDS_ABORT\"] = 3] = \"SENT_NEEDS_ABORT\"; // Temporary state used to mark transactions that need to be aborted.\n\n  TransactionStatus[TransactionStatus[\"NEEDS_ABORT\"] = 4] = \"NEEDS_ABORT\";\n})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));\n/**\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\n * @type {number}\n * @const\n * @private\n */\n\n\nRepo_1.Repo.MAX_TRANSACTION_RETRIES_ = 25;\n/**\n * Setup the transaction data structures\n * @private\n */\n\nRepo_1.Repo.prototype.transactions_init_ = function () {\n  /**\n   * Stores queues of outstanding transactions for Firebase locations.\n   *\n   * @type {!Tree.<Array.<!Transaction>>}\n   * @private\n   */\n  this.transactionQueueTree_ = new Tree_1.Tree();\n};\n/**\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\n *\n * @param {!Path} path Path at which to do transaction.\n * @param {function(*):*} transactionUpdate Update callback.\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\n */\n\n\nRepo_1.Repo.prototype.startTransaction = function (path, transactionUpdate, onComplete, applyLocally) {\n  this.log_('transaction on ' + path); // Add a watch to make sure we get server updates.\n\n  var valueCallback = function () {};\n\n  var watchRef = new Reference_1.Reference(this, path);\n  watchRef.on('value', valueCallback);\n\n  var unwatcher = function () {\n    watchRef.off('value', valueCallback);\n  }; // Initialize transaction.\n\n\n  var transaction = {\n    path: path,\n    update: transactionUpdate,\n    onComplete: onComplete,\n    // One of TransactionStatus enums.\n    status: null,\n    // Used when combining transactions at different locations to figure out which one goes first.\n    order: util_2.LUIDGenerator(),\n    // Whether to raise local events for this transaction.\n    applyLocally: applyLocally,\n    // Count of how many times we've retried the transaction.\n    retryCount: 0,\n    // Function to call to clean up our .on() listener.\n    unwatcher: unwatcher,\n    // Stores why a transaction was aborted.\n    abortReason: null,\n    currentWriteId: null,\n    currentInputSnapshot: null,\n    currentOutputSnapshotRaw: null,\n    currentOutputSnapshotResolved: null\n  }; // Run transaction initially.\n\n  var currentState = this.getLatestState_(path);\n  transaction.currentInputSnapshot = currentState;\n  var newVal = transaction.update(currentState.val());\n\n  if (newVal === undefined) {\n    // Abort transaction.\n    transaction.unwatcher();\n    transaction.currentOutputSnapshotRaw = null;\n    transaction.currentOutputSnapshotResolved = null;\n\n    if (transaction.onComplete) {\n      // We just set the input snapshot, so this cast should be safe\n      var snapshot = new DataSnapshot_1.DataSnapshot(transaction.currentInputSnapshot, new Reference_1.Reference(this, transaction.path), PriorityIndex_1.PRIORITY_INDEX);\n      transaction.onComplete(null, false, snapshot);\n    }\n  } else {\n    validation_1.validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path); // Mark as run and add to our queue.\n\n    transaction.status = TransactionStatus.RUN;\n    var queueNode = this.transactionQueueTree_.subTree(path);\n    var nodeQueue = queueNode.getValue() || [];\n    nodeQueue.push(transaction);\n    queueNode.setValue(nodeQueue); // Update visibleData and raise events\n    // Note: We intentionally raise events after updating all of our transaction state, since the user could\n    // start new transactions from the event callbacks.\n\n    var priorityForNode = void 0;\n\n    if (typeof newVal === 'object' && newVal !== null && util_3.contains(newVal, '.priority')) {\n      priorityForNode = util_3.safeGet(newVal, '.priority');\n      util_1.assert(validation_1.isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' + 'Priority must be a valid string, finite number, server value, or null.');\n    } else {\n      var currentNode = this.serverSyncTree_.calcCompleteEventCache(path) || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n      priorityForNode = currentNode.getPriority().val();\n    }\n\n    priorityForNode\n    /** @type {null|number|string} */\n    = priorityForNode;\n    var serverValues = this.generateServerValues();\n    var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, priorityForNode);\n    var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n    transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n    transaction.currentOutputSnapshotResolved = newNode;\n    transaction.currentWriteId = this.getNextWriteId_();\n    var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, transaction.currentWriteId, transaction.applyLocally);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    this.sendReadyTransactions_();\n  }\n};\n/**\n * @param {!Path} path\n * @param {Array.<number>=} excludeSets A specific set to exclude\n * @return {Node}\n * @private\n */\n\n\nRepo_1.Repo.prototype.getLatestState_ = function (path, excludeSets) {\n  return this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n};\n/**\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\n * complete.\n *\n * Externally it's called with no arguments, but it calls itself recursively with a particular\n * transactionQueueTree node to recurse through the tree.\n *\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\n * @private\n */\n\n\nRepo_1.Repo.prototype.sendReadyTransactions_ = function (node) {\n  var _this = this;\n\n  if (node === void 0) {\n    node = this.transactionQueueTree_;\n  } // Before recursing, make sure any completed transactions are removed.\n\n\n  if (!node) {\n    this.pruneCompletedTransactionsBelowNode_(node);\n  }\n\n  if (node.getValue() !== null) {\n    var queue = this.buildTransactionQueue_(node);\n    util_1.assert(queue.length > 0, 'Sending zero length transaction queue');\n    var allRun = queue.every(function (transaction) {\n      return transaction.status === TransactionStatus.RUN;\n    }); // If they're all run (and not sent), we can send them.  Else, we must wait.\n\n    if (allRun) {\n      this.sendTransactionQueue_(node.path(), queue);\n    }\n  } else if (node.hasChildren()) {\n    node.forEachChild(function (childNode) {\n      _this.sendReadyTransactions_(childNode);\n    });\n  }\n};\n/**\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\n *\n * @param {!Path} path The location of the queue.\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\n * @private\n */\n\n\nRepo_1.Repo.prototype.sendTransactionQueue_ = function (path, queue) {\n  var _this = this; // Mark transactions as sent and increment retry count!\n\n\n  var setsToIgnore = queue.map(function (txn) {\n    return txn.currentWriteId;\n  });\n  var latestState = this.getLatestState_(path, setsToIgnore);\n  var snapToSend = latestState;\n  var latestHash = latestState.hash();\n\n  for (var i = 0; i < queue.length; i++) {\n    var txn = queue[i];\n    util_1.assert(txn.status === TransactionStatus.RUN, 'tryToSendTransactionQueue_: items in queue should all be run.');\n    txn.status = TransactionStatus.SENT;\n    txn.retryCount++;\n    var relativePath = Path_1.Path.relativePath(path, txn.path); // If we've gotten to this point, the output snapshot must be defined.\n\n    snapToSend = snapToSend.updateChild(relativePath\n    /**@type {!Node} */\n    , txn.currentOutputSnapshotRaw);\n  }\n\n  var dataToSend = snapToSend.val(true);\n  var pathToSend = path; // Send the put.\n\n  this.server_.put(pathToSend.toString(), dataToSend, function (status) {\n    _this.log_('transaction put response', {\n      path: pathToSend.toString(),\n      status: status\n    });\n\n    var events = [];\n\n    if (status === 'ok') {\n      // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n      // the callback could trigger more transactions or sets.\n      var callbacks = [];\n\n      for (var i = 0; i < queue.length; i++) {\n        queue[i].status = TransactionStatus.COMPLETED;\n        events = events.concat(_this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId));\n\n        if (queue[i].onComplete) {\n          // We never unset the output snapshot, and given that this transaction is complete, it should be set\n          var node = queue[i].currentOutputSnapshotResolved;\n          var ref = new Reference_1.Reference(_this, queue[i].path);\n          var snapshot = new DataSnapshot_1.DataSnapshot(node, ref, PriorityIndex_1.PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, true, snapshot));\n        }\n\n        queue[i].unwatcher();\n      } // Now remove the completed transactions.\n\n\n      _this.pruneCompletedTransactionsBelowNode_(_this.transactionQueueTree_.subTree(path)); // There may be pending transactions that we can now send.\n\n\n      _this.sendReadyTransactions_();\n\n      _this.eventQueue_.raiseEventsForChangedPath(path, events); // Finally, trigger onComplete callbacks.\n\n\n      for (var i = 0; i < callbacks.length; i++) {\n        util_2.exceptionGuard(callbacks[i]);\n      }\n    } else {\n      // transactions are no longer sent.  Update their status appropriately.\n      if (status === 'datastale') {\n        for (var i = 0; i < queue.length; i++) {\n          if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) queue[i].status = TransactionStatus.NEEDS_ABORT;else queue[i].status = TransactionStatus.RUN;\n        }\n      } else {\n        util_2.warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);\n\n        for (var i = 0; i < queue.length; i++) {\n          queue[i].status = TransactionStatus.NEEDS_ABORT;\n          queue[i].abortReason = status;\n        }\n      }\n\n      _this.rerunTransactions_(path);\n    }\n  }, latestHash);\n};\n/**\n * Finds all transactions dependent on the data at changedPath and reruns them.\n *\n * Should be called any time cached data changes.\n *\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\n * be raised for.\n *\n * @param {!Path} changedPath The path in mergedData that changed.\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\n * @private\n */\n\n\nRepo_1.Repo.prototype.rerunTransactions_ = function (changedPath) {\n  var rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\n  var path = rootMostTransactionNode.path();\n  var queue = this.buildTransactionQueue_(rootMostTransactionNode);\n  this.rerunTransactionQueue_(queue, path);\n  return path;\n};\n/**\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\n *\n * @param {Array.<Transaction>} queue The queue of transactions to run.\n * @param {!Path} path The path the queue is for.\n * @private\n */\n\n\nRepo_1.Repo.prototype.rerunTransactionQueue_ = function (queue, path) {\n  if (queue.length === 0) {\n    return; // Nothing to do!\n  } // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n  // the callback could trigger more transactions or sets.\n\n\n  var callbacks = [];\n  var events = []; // Ignore all of the sets we're going to re-run.\n\n  var txnsToRerun = queue.filter(function (q) {\n    return q.status === TransactionStatus.RUN;\n  });\n  var setsToIgnore = txnsToRerun.map(function (q) {\n    return q.currentWriteId;\n  });\n\n  for (var i = 0; i < queue.length; i++) {\n    var transaction = queue[i];\n    var relativePath = Path_1.Path.relativePath(path, transaction.path);\n    var abortTransaction = false,\n        abortReason = void 0;\n    util_1.assert(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');\n\n    if (transaction.status === TransactionStatus.NEEDS_ABORT) {\n      abortTransaction = true;\n      abortReason = transaction.abortReason;\n      events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n    } else if (transaction.status === TransactionStatus.RUN) {\n      if (transaction.retryCount >= Repo_1.Repo.MAX_TRANSACTION_RETRIES_) {\n        abortTransaction = true;\n        abortReason = 'maxretry';\n        events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n      } else {\n        // This code reruns a transaction\n        var currentNode = this.getLatestState_(transaction.path, setsToIgnore);\n        transaction.currentInputSnapshot = currentNode;\n        var newData = queue[i].update(currentNode.val());\n\n        if (newData !== undefined) {\n          validation_1.validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);\n          var newDataNode = nodeFromJSON_1.nodeFromJSON(newData);\n          var hasExplicitPriority = typeof newData === 'object' && newData != null && util_3.contains(newData, '.priority');\n\n          if (!hasExplicitPriority) {\n            // Keep the old priority if there wasn't a priority explicitly specified.\n            newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n          }\n\n          var oldWriteId = transaction.currentWriteId;\n          var serverValues = this.generateServerValues();\n          var newNodeResolved = ServerValues_1.resolveDeferredValueSnapshot(newDataNode, serverValues);\n          transaction.currentOutputSnapshotRaw = newDataNode;\n          transaction.currentOutputSnapshotResolved = newNodeResolved;\n          transaction.currentWriteId = this.getNextWriteId_(); // Mutates setsToIgnore in place\n\n          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n          events = events.concat(this.serverSyncTree_.applyUserOverwrite(transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));\n          events = events.concat(this.serverSyncTree_.ackUserWrite(oldWriteId, true));\n        } else {\n          abortTransaction = true;\n          abortReason = 'nodata';\n          events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n        }\n      }\n    }\n\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    events = [];\n\n    if (abortTransaction) {\n      // Abort.\n      queue[i].status = TransactionStatus.COMPLETED; // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\n      // So defer the unwatcher until we're done.\n\n      (function (unwatcher) {\n        setTimeout(unwatcher, Math.floor(0));\n      })(queue[i].unwatcher);\n\n      if (queue[i].onComplete) {\n        if (abortReason === 'nodata') {\n          var ref = new Reference_1.Reference(this, queue[i].path); // We set this field immediately, so it's safe to cast to an actual snapshot\n\n          var lastInput\n          /** @type {!Node} */\n          = queue[i].currentInputSnapshot;\n          var snapshot = new DataSnapshot_1.DataSnapshot(lastInput, ref, PriorityIndex_1.PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\n        } else {\n          callbacks.push(queue[i].onComplete.bind(null, new Error(abortReason), false, null));\n        }\n      }\n    }\n  } // Clean up completed transactions.\n\n\n  this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_); // Now fire callbacks, now that we're in a good, known state.\n\n  for (var i = 0; i < callbacks.length; i++) {\n    util_2.exceptionGuard(callbacks[i]);\n  } // Try to send the transaction result to the server.\n\n\n  this.sendReadyTransactions_();\n};\n/**\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\n * the node for the given path if there are no pending transactions on any ancestor.\n *\n * @param {!Path} path The location to start at.\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\n * @private\n */\n\n\nRepo_1.Repo.prototype.getAncestorTransactionNode_ = function (path) {\n  var front; // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\n\n  var transactionNode = this.transactionQueueTree_;\n\n  while ((front = path.getFront()) !== null && transactionNode.getValue() === null) {\n    transactionNode = transactionNode.subTree(front);\n    path = path.popFront();\n  }\n\n  return transactionNode;\n};\n/**\n * Builds the queue of all transactions at or below the specified transactionNode.\n *\n * @param {!Tree.<Array.<Transaction>>} transactionNode\n * @return {Array.<Transaction>} The generated queue.\n * @private\n */\n\n\nRepo_1.Repo.prototype.buildTransactionQueue_ = function (transactionNode) {\n  // Walk any child transaction queues and aggregate them into a single queue.\n  var transactionQueue = [];\n  this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue); // Sort them by the order the transactions were created.\n\n  transactionQueue.sort(function (a, b) {\n    return a.order - b.order;\n  });\n  return transactionQueue;\n};\n/**\n * @param {!Tree.<Array.<Transaction>>} node\n * @param {Array.<Transaction>} queue\n * @private\n */\n\n\nRepo_1.Repo.prototype.aggregateTransactionQueuesForNode_ = function (node, queue) {\n  var _this = this;\n\n  var nodeQueue = node.getValue();\n\n  if (nodeQueue !== null) {\n    for (var i = 0; i < nodeQueue.length; i++) {\n      queue.push(nodeQueue[i]);\n    }\n  }\n\n  node.forEachChild(function (child) {\n    _this.aggregateTransactionQueuesForNode_(child, queue);\n  });\n};\n/**\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\n *\n * @param {!Tree.<Array.<!Transaction>>} node\n * @private\n */\n\n\nRepo_1.Repo.prototype.pruneCompletedTransactionsBelowNode_ = function (node) {\n  var _this = this;\n\n  var queue = node.getValue();\n\n  if (queue) {\n    var to = 0;\n\n    for (var from = 0; from < queue.length; from++) {\n      if (queue[from].status !== TransactionStatus.COMPLETED) {\n        queue[to] = queue[from];\n        to++;\n      }\n    }\n\n    queue.length = to;\n    node.setValue(queue.length > 0 ? queue : null);\n  }\n\n  node.forEachChild(function (childNode) {\n    _this.pruneCompletedTransactionsBelowNode_(childNode);\n  });\n};\n/**\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\n * since we consider them incompatible with transactions.\n *\n * @param {!Path} path Path for which we want to abort related transactions.\n * @return {!Path}\n * @private\n */\n\n\nRepo_1.Repo.prototype.abortTransactions_ = function (path) {\n  var _this = this;\n\n  var affectedPath = this.getAncestorTransactionNode_(path).path();\n  var transactionNode = this.transactionQueueTree_.subTree(path);\n  transactionNode.forEachAncestor(function (node) {\n    _this.abortTransactionsOnNode_(node);\n  });\n  this.abortTransactionsOnNode_(transactionNode);\n  transactionNode.forEachDescendant(function (node) {\n    _this.abortTransactionsOnNode_(node);\n  });\n  return affectedPath;\n};\n/**\n * Abort transactions stored in this transaction queue node.\n *\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\n * @private\n */\n\n\nRepo_1.Repo.prototype.abortTransactionsOnNode_ = function (node) {\n  var queue = node.getValue();\n\n  if (queue !== null) {\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n    // the callback could trigger more transactions or sets.\n    var callbacks = []; // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\n    // can be immediately aborted and removed.\n\n    var events = [];\n    var lastSent = -1;\n\n    for (var i = 0; i < queue.length; i++) {\n      if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {// Already marked.  No action needed.\n      } else if (queue[i].status === TransactionStatus.SENT) {\n        util_1.assert(lastSent === i - 1, 'All SENT items should be at beginning of queue.');\n        lastSent = i; // Mark transaction for abort when it comes back.\n\n        queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\n        queue[i].abortReason = 'set';\n      } else {\n        util_1.assert(queue[i].status === TransactionStatus.RUN, 'Unexpected transaction status in abort'); // We can abort it immediately.\n\n        queue[i].unwatcher();\n        events = events.concat(this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true));\n\n        if (queue[i].onComplete) {\n          var snapshot = null;\n          callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, snapshot));\n        }\n      }\n    }\n\n    if (lastSent === -1) {\n      // We're not waiting for any sent transactions.  We can clear the queue.\n      node.setValue(null);\n    } else {\n      // Remove the transactions we aborted.\n      queue.length = lastSent + 1;\n    } // Now fire the callbacks.\n\n\n    this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\n\n    for (var i = 0; i < callbacks.length; i++) {\n      util_2.exceptionGuard(callbacks[i]);\n    }\n  }\n};","map":{"version":3,"mappings":"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","names":["TransactionStatus","exports","Repo_1","MAX_TRANSACTION_RETRIES_","prototype","transactions_init_","transactionQueueTree_","Tree_1","startTransaction","path","transactionUpdate","onComplete","applyLocally","log_","valueCallback","watchRef","Reference_1","on","unwatcher","off","transaction","update","status","order","util_2","retryCount","abortReason","currentWriteId","currentInputSnapshot","currentOutputSnapshotRaw","currentOutputSnapshotResolved","currentState","getLatestState_","newVal","val","undefined","snapshot","DataSnapshot_1","PriorityIndex_1","validation_1","RUN","queueNode","subTree","nodeQueue","getValue","push","setValue","priorityForNode","util_3","util_1","currentNode","serverSyncTree_","calcCompleteEventCache","ChildrenNode_1","EMPTY_NODE","getPriority","serverValues","generateServerValues","newNodeUnresolved","nodeFromJSON_1","newNode","ServerValues_1","getNextWriteId_","events","applyUserOverwrite","eventQueue_","raiseEventsForChangedPath","sendReadyTransactions_","excludeSets","node","pruneCompletedTransactionsBelowNode_","queue","buildTransactionQueue_","length","allRun","every","sendTransactionQueue_","hasChildren","forEachChild","_this","childNode","setsToIgnore","map","txn","latestState","snapToSend","latestHash","hash","i","SENT","relativePath","Path_1","updateChild","dataToSend","pathToSend","server_","put","toString","callbacks","COMPLETED","concat","ackUserWrite","ref","bind","SENT_NEEDS_ABORT","NEEDS_ABORT","rerunTransactions_","changedPath","rootMostTransactionNode","getAncestorTransactionNode_","rerunTransactionQueue_","txnsToRerun","filter","q","abortTransaction","newData","newDataNode","hasExplicitPriority","updatePriority","oldWriteId","newNodeResolved","splice","indexOf","setTimeout","Math","floor","lastInput","Error","front","transactionNode","getFront","popFront","transactionQueue","aggregateTransactionQueuesForNode_","sort","a","b","child","to","from","abortTransactions_","affectedPath","forEachAncestor","abortTransactionsOnNode_","forEachDescendant","lastSent"],"sources":["../src/core/Repo_transaction.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Reference } from '../api/Reference';\nimport { DataSnapshot } from '../api/DataSnapshot';\nimport { Path } from './util/Path';\nimport { Tree } from './util/Tree';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { Node } from './snap/Node';\nimport { LUIDGenerator, warn, exceptionGuard } from './util/util';\nimport { resolveDeferredValueSnapshot } from './util/ServerValues';\nimport { isValidPriority, validateFirebaseData } from './util/validation';\nimport { contains, safeGet } from '@firebase/util';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { Repo } from './Repo';\nimport { Event } from './view/Event';\n\n// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\n// For now it's part of Repo, but in its own file.\n\n/**\n * @enum {number}\n */\nexport enum TransactionStatus {\n  // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\n  // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\n  // mismatched hash.\n  RUN,\n\n  // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\n  // or rejected yet).\n  SENT,\n\n  // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\n  // removed when we get a chance to prune completed ones.\n  COMPLETED,\n\n  // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\n  // If it comes back as unsuccessful, we'll abort it.\n  SENT_NEEDS_ABORT,\n\n  // Temporary state used to mark transactions that need to be aborted.\n  NEEDS_ABORT\n}\n\n/**\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\n * @type {number}\n * @const\n * @private\n */\n(Repo as any).MAX_TRANSACTION_RETRIES_ = 25;\n\n/**\n * @typedef {{\n *   path: !Path,\n *   update: function(*):*,\n *   onComplete: ?function(?Error, boolean, ?DataSnapshot),\n *   status: ?TransactionStatus,\n *   order: !number,\n *   applyLocally: boolean,\n *   retryCount: !number,\n *   unwatcher: function(),\n *   abortReason: ?string,\n *   currentWriteId: !number,\n *   currentInputSnapshot: ?Node,\n *   currentOutputSnapshotRaw: ?Node,\n *   currentOutputSnapshotResolved: ?Node\n * }}\n */\ntype Transaction = {\n  path: Path;\n  update: (a: any) => any;\n  onComplete: (a: Error | null, b: boolean, c: DataSnapshot | null) => void;\n  status: TransactionStatus;\n  order: number;\n  applyLocally: boolean;\n  retryCount: number;\n  unwatcher: () => void;\n  abortReason: string | null;\n  currentWriteId: number;\n  currentInputSnapshot: Node | null;\n  currentOutputSnapshotRaw: Node | null;\n  currentOutputSnapshotResolved: Node | null;\n};\n\n/**\n * Setup the transaction data structures\n * @private\n */\n(Repo.prototype as any).transactions_init_ = function() {\n  /**\n   * Stores queues of outstanding transactions for Firebase locations.\n   *\n   * @type {!Tree.<Array.<!Transaction>>}\n   * @private\n   */\n  this.transactionQueueTree_ = new Tree<Transaction[]>();\n};\n\ndeclare module './Repo' {\n  interface Repo {\n    startTransaction(\n      path: Path,\n      transactionUpdate: (a: any) => void,\n      onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n      applyLocally: boolean\n    ): void;\n  }\n}\n\n/**\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\n *\n * @param {!Path} path Path at which to do transaction.\n * @param {function(*):*} transactionUpdate Update callback.\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\n */\nRepo.prototype.startTransaction = function(\n  path: Path,\n  transactionUpdate: (a: any) => any,\n  onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n  applyLocally: boolean\n) {\n  this.log_('transaction on ' + path);\n\n  // Add a watch to make sure we get server updates.\n  const valueCallback = function() {};\n  const watchRef = new Reference(this, path);\n  watchRef.on('value', valueCallback);\n  const unwatcher = function() {\n    watchRef.off('value', valueCallback);\n  };\n\n  // Initialize transaction.\n  const transaction: Transaction = {\n    path,\n    update: transactionUpdate,\n    onComplete,\n\n    // One of TransactionStatus enums.\n    status: null,\n\n    // Used when combining transactions at different locations to figure out which one goes first.\n    order: LUIDGenerator(),\n\n    // Whether to raise local events for this transaction.\n    applyLocally: applyLocally,\n\n    // Count of how many times we've retried the transaction.\n    retryCount: 0,\n\n    // Function to call to clean up our .on() listener.\n    unwatcher,\n\n    // Stores why a transaction was aborted.\n    abortReason: null,\n\n    currentWriteId: null,\n\n    currentInputSnapshot: null,\n\n    currentOutputSnapshotRaw: null,\n\n    currentOutputSnapshotResolved: null\n  };\n\n  // Run transaction initially.\n  const currentState = this.getLatestState_(path);\n  transaction.currentInputSnapshot = currentState;\n  const newVal = transaction.update(currentState.val());\n  if (newVal === undefined) {\n    // Abort transaction.\n    transaction.unwatcher();\n    transaction.currentOutputSnapshotRaw = null;\n    transaction.currentOutputSnapshotResolved = null;\n    if (transaction.onComplete) {\n      // We just set the input snapshot, so this cast should be safe\n      const snapshot = new DataSnapshot(\n        transaction.currentInputSnapshot,\n        new Reference(this, transaction.path),\n        PRIORITY_INDEX\n      );\n      transaction.onComplete(null, false, snapshot);\n    }\n  } else {\n    validateFirebaseData(\n      'transaction failed: Data returned ',\n      newVal,\n      transaction.path\n    );\n\n    // Mark as run and add to our queue.\n    transaction.status = TransactionStatus.RUN;\n    const queueNode = this.transactionQueueTree_.subTree(path);\n    const nodeQueue = queueNode.getValue() || [];\n    nodeQueue.push(transaction);\n\n    queueNode.setValue(nodeQueue);\n\n    // Update visibleData and raise events\n    // Note: We intentionally raise events after updating all of our transaction state, since the user could\n    // start new transactions from the event callbacks.\n    let priorityForNode;\n    if (\n      typeof newVal === 'object' &&\n      newVal !== null &&\n      contains(newVal, '.priority')\n    ) {\n      priorityForNode = safeGet(newVal, '.priority');\n      assert(\n        isValidPriority(priorityForNode),\n        'Invalid priority returned by transaction. ' +\n          'Priority must be a valid string, finite number, server value, or null.'\n      );\n    } else {\n      const currentNode =\n        this.serverSyncTree_.calcCompleteEventCache(path) ||\n        ChildrenNode.EMPTY_NODE;\n      priorityForNode = currentNode.getPriority().val();\n    }\n    priorityForNode /** @type {null|number|string} */ = priorityForNode;\n\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n    transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n    transaction.currentOutputSnapshotResolved = newNode;\n    transaction.currentWriteId = this.getNextWriteId_();\n\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      transaction.currentWriteId,\n      transaction.applyLocally\n    );\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n    this.sendReadyTransactions_();\n  }\n};\n\n/**\n * @param {!Path} path\n * @param {Array.<number>=} excludeSets A specific set to exclude\n * @return {Node}\n * @private\n */\n(Repo.prototype as any).getLatestState_ = function(\n  path: Path,\n  excludeSets?: number[]\n): Node {\n  return (\n    this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||\n    ChildrenNode.EMPTY_NODE\n  );\n};\n\n/**\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\n * complete.\n *\n * Externally it's called with no arguments, but it calls itself recursively with a particular\n * transactionQueueTree node to recurse through the tree.\n *\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\n * @private\n */\n(Repo.prototype as any).sendReadyTransactions_ = function(\n  node: Tree<Transaction[]> = this.transactionQueueTree_\n) {\n  // Before recursing, make sure any completed transactions are removed.\n  if (!node) {\n    this.pruneCompletedTransactionsBelowNode_(node);\n  }\n\n  if (node.getValue() !== null) {\n    const queue = this.buildTransactionQueue_(node);\n    assert(queue.length > 0, 'Sending zero length transaction queue');\n\n    const allRun = queue.every(\n      (transaction: Transaction) => transaction.status === TransactionStatus.RUN\n    );\n\n    // If they're all run (and not sent), we can send them.  Else, we must wait.\n    if (allRun) {\n      this.sendTransactionQueue_(node.path(), queue);\n    }\n  } else if (node.hasChildren()) {\n    node.forEachChild(childNode => {\n      this.sendReadyTransactions_(childNode);\n    });\n  }\n};\n\n/**\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\n *\n * @param {!Path} path The location of the queue.\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\n * @private\n */\n(Repo.prototype as any).sendTransactionQueue_ = function(\n  path: Path,\n  queue: Array<Transaction>\n) {\n  // Mark transactions as sent and increment retry count!\n  const setsToIgnore = queue.map(function(txn) {\n    return txn.currentWriteId;\n  });\n  const latestState = this.getLatestState_(path, setsToIgnore);\n  let snapToSend = latestState;\n  const latestHash = latestState.hash();\n  for (let i = 0; i < queue.length; i++) {\n    const txn = queue[i];\n    assert(\n      txn.status === TransactionStatus.RUN,\n      'tryToSendTransactionQueue_: items in queue should all be run.'\n    );\n    txn.status = TransactionStatus.SENT;\n    txn.retryCount++;\n    const relativePath = Path.relativePath(path, txn.path);\n    // If we've gotten to this point, the output snapshot must be defined.\n    snapToSend = snapToSend.updateChild(\n      relativePath /**@type {!Node} */,\n      txn.currentOutputSnapshotRaw\n    );\n  }\n\n  const dataToSend = snapToSend.val(true);\n  const pathToSend = path;\n\n  // Send the put.\n  this.server_.put(\n    pathToSend.toString(),\n    dataToSend,\n    (status: string) => {\n      this.log_('transaction put response', {\n        path: pathToSend.toString(),\n        status\n      });\n\n      let events: Event[] = [];\n      if (status === 'ok') {\n        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n        // the callback could trigger more transactions or sets.\n        const callbacks = [];\n        for (let i = 0; i < queue.length; i++) {\n          queue[i].status = TransactionStatus.COMPLETED;\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId)\n          );\n          if (queue[i].onComplete) {\n            // We never unset the output snapshot, and given that this transaction is complete, it should be set\n            const node = queue[i].currentOutputSnapshotResolved as Node;\n            const ref = new Reference(this, queue[i].path);\n            const snapshot = new DataSnapshot(node, ref, PRIORITY_INDEX);\n            callbacks.push(\n              queue[i].onComplete.bind(null, null, true, snapshot)\n            );\n          }\n          queue[i].unwatcher();\n        }\n\n        // Now remove the completed transactions.\n        this.pruneCompletedTransactionsBelowNode_(\n          this.transactionQueueTree_.subTree(path)\n        );\n        // There may be pending transactions that we can now send.\n        this.sendReadyTransactions_();\n\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n        // Finally, trigger onComplete callbacks.\n        for (let i = 0; i < callbacks.length; i++) {\n          exceptionGuard(callbacks[i]);\n        }\n      } else {\n        // transactions are no longer sent.  Update their status appropriately.\n        if (status === 'datastale') {\n          for (let i = 0; i < queue.length; i++) {\n            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT)\n              queue[i].status = TransactionStatus.NEEDS_ABORT;\n            else queue[i].status = TransactionStatus.RUN;\n          }\n        } else {\n          warn(\n            'transaction at ' + pathToSend.toString() + ' failed: ' + status\n          );\n          for (let i = 0; i < queue.length; i++) {\n            queue[i].status = TransactionStatus.NEEDS_ABORT;\n            queue[i].abortReason = status;\n          }\n        }\n\n        this.rerunTransactions_(path);\n      }\n    },\n    latestHash\n  );\n};\n\n/**\n * Finds all transactions dependent on the data at changedPath and reruns them.\n *\n * Should be called any time cached data changes.\n *\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\n * be raised for.\n *\n * @param {!Path} changedPath The path in mergedData that changed.\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\n * @private\n */\n(Repo.prototype as any).rerunTransactions_ = function(changedPath: Path): Path {\n  const rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\n  const path = rootMostTransactionNode.path();\n\n  const queue = this.buildTransactionQueue_(rootMostTransactionNode);\n  this.rerunTransactionQueue_(queue, path);\n\n  return path;\n};\n\n/**\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\n *\n * @param {Array.<Transaction>} queue The queue of transactions to run.\n * @param {!Path} path The path the queue is for.\n * @private\n */\n(Repo.prototype as any).rerunTransactionQueue_ = function(\n  queue: Array<Transaction>,\n  path: Path\n) {\n  if (queue.length === 0) {\n    return; // Nothing to do!\n  }\n\n  // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n  // the callback could trigger more transactions or sets.\n  const callbacks = [];\n  let events: Event[] = [];\n  // Ignore all of the sets we're going to re-run.\n  const txnsToRerun = queue.filter(function(q) {\n    return q.status === TransactionStatus.RUN;\n  });\n  const setsToIgnore = txnsToRerun.map(function(q) {\n    return q.currentWriteId;\n  });\n  for (let i = 0; i < queue.length; i++) {\n    const transaction = queue[i];\n    const relativePath = Path.relativePath(path, transaction.path);\n    let abortTransaction = false,\n      abortReason;\n    assert(\n      relativePath !== null,\n      'rerunTransactionsUnderNode_: relativePath should not be null.'\n    );\n\n    if (transaction.status === TransactionStatus.NEEDS_ABORT) {\n      abortTransaction = true;\n      abortReason = transaction.abortReason;\n      events = events.concat(\n        this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n      );\n    } else if (transaction.status === TransactionStatus.RUN) {\n      if (transaction.retryCount >= (Repo as any).MAX_TRANSACTION_RETRIES_) {\n        abortTransaction = true;\n        abortReason = 'maxretry';\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n        );\n      } else {\n        // This code reruns a transaction\n        const currentNode = this.getLatestState_(\n          transaction.path,\n          setsToIgnore\n        );\n        transaction.currentInputSnapshot = currentNode;\n        const newData = queue[i].update(currentNode.val());\n        if (newData !== undefined) {\n          validateFirebaseData(\n            'transaction failed: Data returned ',\n            newData,\n            transaction.path\n          );\n          let newDataNode = nodeFromJSON(newData);\n          const hasExplicitPriority =\n            typeof newData === 'object' &&\n            newData != null &&\n            contains(newData, '.priority');\n          if (!hasExplicitPriority) {\n            // Keep the old priority if there wasn't a priority explicitly specified.\n            newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n          }\n\n          const oldWriteId = transaction.currentWriteId;\n          const serverValues = this.generateServerValues();\n          const newNodeResolved = resolveDeferredValueSnapshot(\n            newDataNode,\n            serverValues\n          );\n\n          transaction.currentOutputSnapshotRaw = newDataNode;\n          transaction.currentOutputSnapshotResolved = newNodeResolved;\n          transaction.currentWriteId = this.getNextWriteId_();\n          // Mutates setsToIgnore in place\n          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n          events = events.concat(\n            this.serverSyncTree_.applyUserOverwrite(\n              transaction.path,\n              newNodeResolved,\n              transaction.currentWriteId,\n              transaction.applyLocally\n            )\n          );\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(oldWriteId, true)\n          );\n        } else {\n          abortTransaction = true;\n          abortReason = 'nodata';\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n          );\n        }\n      }\n    }\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    events = [];\n    if (abortTransaction) {\n      // Abort.\n      queue[i].status = TransactionStatus.COMPLETED;\n\n      // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\n      // So defer the unwatcher until we're done.\n      (function(unwatcher) {\n        setTimeout(unwatcher, Math.floor(0));\n      })(queue[i].unwatcher);\n\n      if (queue[i].onComplete) {\n        if (abortReason === 'nodata') {\n          const ref = new Reference(this, queue[i].path);\n          // We set this field immediately, so it's safe to cast to an actual snapshot\n          const lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;\n          const snapshot = new DataSnapshot(lastInput, ref, PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\n        } else {\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error(abortReason), false, null)\n          );\n        }\n      }\n    }\n  }\n\n  // Clean up completed transactions.\n  this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);\n\n  // Now fire callbacks, now that we're in a good, known state.\n  for (let i = 0; i < callbacks.length; i++) {\n    exceptionGuard(callbacks[i]);\n  }\n\n  // Try to send the transaction result to the server.\n  this.sendReadyTransactions_();\n};\n\n/**\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\n * the node for the given path if there are no pending transactions on any ancestor.\n *\n * @param {!Path} path The location to start at.\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\n * @private\n */\n(Repo.prototype as any).getAncestorTransactionNode_ = function(\n  path: Path\n): Tree<Transaction[]> {\n  let front;\n\n  // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\n  let transactionNode = this.transactionQueueTree_;\n  while (\n    (front = path.getFront()) !== null &&\n    transactionNode.getValue() === null\n  ) {\n    transactionNode = transactionNode.subTree(front);\n    path = path.popFront();\n  }\n\n  return transactionNode;\n};\n\n/**\n * Builds the queue of all transactions at or below the specified transactionNode.\n *\n * @param {!Tree.<Array.<Transaction>>} transactionNode\n * @return {Array.<Transaction>} The generated queue.\n * @private\n */\n(Repo.prototype as any).buildTransactionQueue_ = function(\n  transactionNode: Tree<Transaction[]>\n): Array<Transaction> {\n  // Walk any child transaction queues and aggregate them into a single queue.\n  const transactionQueue: Transaction[] = [];\n  this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);\n\n  // Sort them by the order the transactions were created.\n  transactionQueue.sort(function(a, b) {\n    return a.order - b.order;\n  });\n\n  return transactionQueue;\n};\n\n/**\n * @param {!Tree.<Array.<Transaction>>} node\n * @param {Array.<Transaction>} queue\n * @private\n */\n(Repo.prototype as any).aggregateTransactionQueuesForNode_ = function(\n  node: Tree<Transaction[]>,\n  queue: Array<Transaction>\n) {\n  const nodeQueue = node.getValue();\n  if (nodeQueue !== null) {\n    for (let i = 0; i < nodeQueue.length; i++) {\n      queue.push(nodeQueue[i]);\n    }\n  }\n\n  node.forEachChild(child => {\n    this.aggregateTransactionQueuesForNode_(child, queue);\n  });\n};\n\n/**\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\n *\n * @param {!Tree.<Array.<!Transaction>>} node\n * @private\n */\n(Repo.prototype as any).pruneCompletedTransactionsBelowNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue) {\n    let to = 0;\n    for (let from = 0; from < queue.length; from++) {\n      if (queue[from].status !== TransactionStatus.COMPLETED) {\n        queue[to] = queue[from];\n        to++;\n      }\n    }\n    queue.length = to;\n    node.setValue(queue.length > 0 ? queue : null);\n  }\n\n  node.forEachChild(childNode => {\n    this.pruneCompletedTransactionsBelowNode_(childNode);\n  });\n};\n\n/**\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\n * since we consider them incompatible with transactions.\n *\n * @param {!Path} path Path for which we want to abort related transactions.\n * @return {!Path}\n * @private\n */\n(Repo.prototype as any).abortTransactions_ = function(path: Path): Path {\n  const affectedPath = this.getAncestorTransactionNode_(path).path();\n\n  const transactionNode = this.transactionQueueTree_.subTree(path);\n\n  transactionNode.forEachAncestor((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  this.abortTransactionsOnNode_(transactionNode);\n\n  transactionNode.forEachDescendant((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  return affectedPath;\n};\n\n/**\n * Abort transactions stored in this transaction queue node.\n *\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\n * @private\n */\n(Repo.prototype as any).abortTransactionsOnNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue !== null) {\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n    // the callback could trigger more transactions or sets.\n    const callbacks = [];\n\n    // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\n    // can be immediately aborted and removed.\n    let events: Event[] = [];\n    let lastSent = -1;\n    for (let i = 0; i < queue.length; i++) {\n      if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {\n        // Already marked.  No action needed.\n      } else if (queue[i].status === TransactionStatus.SENT) {\n        assert(\n          lastSent === i - 1,\n          'All SENT items should be at beginning of queue.'\n        );\n        lastSent = i;\n        // Mark transaction for abort when it comes back.\n        queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\n        queue[i].abortReason = 'set';\n      } else {\n        assert(\n          queue[i].status === TransactionStatus.RUN,\n          'Unexpected transaction status in abort'\n        );\n        // We can abort it immediately.\n        queue[i].unwatcher();\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true)\n        );\n        if (queue[i].onComplete) {\n          const snapshot: DataSnapshot | null = null;\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error('set'), false, snapshot)\n          );\n        }\n      }\n    }\n    if (lastSent === -1) {\n      // We're not waiting for any sent transactions.  We can clear the queue.\n      node.setValue(null);\n    } else {\n      // Remove the transactions we aborted.\n      queue.length = lastSent + 1;\n    }\n\n    // Now fire the callbacks.\n    this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\n    for (let i = 0; i < callbacks.length; i++) {\n      exceptionGuard(callbacks[i]);\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}