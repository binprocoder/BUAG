{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"../core/util/util\");\n\nvar CountedSet_1 = require(\"../core/util/CountedSet\");\n\nvar StatsManager_1 = require(\"../core/stats/StatsManager\");\n\nvar PacketReceiver_1 = require(\"./polling/PacketReceiver\");\n\nvar Constants_1 = require(\"./Constants\");\n\nvar util_2 = require(\"@firebase/util\");\n\nvar util_3 = require(\"@firebase/util\"); // URL query parameters associated with longpolling\n\n\nexports.FIREBASE_LONGPOLL_START_PARAM = 'start';\nexports.FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\nexports.FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\nexports.FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\nexports.FIREBASE_LONGPOLL_ID_PARAM = 'id';\nexports.FIREBASE_LONGPOLL_PW_PARAM = 'pw';\nexports.FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\nexports.FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\nexports.FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\nexports.FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\nexports.FIREBASE_LONGPOLL_DATA_PARAM = 'd';\nexports.FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';\nexports.FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe'; //Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\n\nvar MAX_URL_DATA_SIZE = 1870;\nvar SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\n\nvar MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\n/**\r\n * Keepalive period\r\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\r\n * length of 30 seconds that we can't exceed.\r\n * @const\r\n * @type {number}\r\n */\n\nvar KEEPALIVE_REQUEST_INTERVAL = 25000;\n/**\r\n * How long to wait before aborting a long-polling connection attempt.\r\n * @const\r\n * @type {number}\r\n */\n\nvar LP_CONNECT_TIMEOUT = 30000;\n/**\r\n * This class manages a single long-polling connection.\r\n *\r\n * @constructor\r\n * @implements {Transport}\r\n */\n\nvar BrowserPollConnection =\n/** @class */\nfunction () {\n  /**\r\n   * @param {string} connId An identifier for this connection, used for logging\r\n   * @param {RepoInfo} repoInfo The info for the endpoint to send data to.\r\n   * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing\r\n   *                                         transport session\r\n   * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a\r\n   *                                     connection previously\r\n   */\n  function BrowserPollConnection(connId, repoInfo, transportSessionId, lastSessionId) {\n    this.connId = connId;\n    this.repoInfo = repoInfo;\n    this.transportSessionId = transportSessionId;\n    this.lastSessionId = lastSessionId;\n    this.bytesSent = 0;\n    this.bytesReceived = 0;\n    this.everConnected_ = false;\n    this.log_ = util_1.logWrapper(connId);\n    this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo);\n\n    this.urlFn = function (params) {\n      return repoInfo.connectionURL(Constants_1.LONG_POLLING, params);\n    };\n  }\n  /**\r\n   *\r\n   * @param {function(Object)} onMessage Callback when messages arrive\r\n   * @param {function()} onDisconnect Callback with connection lost.\r\n   */\n\n\n  BrowserPollConnection.prototype.open = function (onMessage, onDisconnect) {\n    var _this = this;\n\n    this.curSegmentNum = 0;\n    this.onDisconnect_ = onDisconnect;\n    this.myPacketOrderer = new PacketReceiver_1.PacketReceiver(onMessage);\n    this.isClosed_ = false;\n    this.connectTimeoutTimer_ = setTimeout(function () {\n      _this.log_('Timed out trying to connect.'); // Make sure we clear the host cache\n\n\n      _this.onClosed_();\n\n      _this.connectTimeoutTimer_ = null;\n    }, Math.floor(LP_CONNECT_TIMEOUT)); // Ensure we delay the creation of the iframe until the DOM is loaded.\n\n    util_1.executeWhenDOMReady(function () {\n      if (_this.isClosed_) return; //Set up a callback that gets triggered once a connection is set up.\n\n      _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var command = args[0],\n            arg1 = args[1],\n            arg2 = args[2],\n            arg3 = args[3],\n            arg4 = args[4];\n\n        _this.incrementIncomingBytes_(args);\n\n        if (!_this.scriptTagHolder) return; // we closed the connection.\n\n        if (_this.connectTimeoutTimer_) {\n          clearTimeout(_this.connectTimeoutTimer_);\n          _this.connectTimeoutTimer_ = null;\n        }\n\n        _this.everConnected_ = true;\n\n        if (command == exports.FIREBASE_LONGPOLL_START_PARAM) {\n          _this.id = arg1;\n          _this.password = arg2;\n        } else if (command === exports.FIREBASE_LONGPOLL_CLOSE_COMMAND) {\n          // Don't clear the host cache. We got a response from the server, so we know it's reachable\n          if (arg1) {\n            // We aren't expecting any more data (other than what the server's already in the process of sending us\n            // through our already open polls), so don't send any more.\n            _this.scriptTagHolder.sendNewPolls = false; // arg1 in this case is the last response number sent by the server. We should try to receive\n            // all of the responses up to this one before closing\n\n            _this.myPacketOrderer.closeAfter(arg1, function () {\n              _this.onClosed_();\n            });\n          } else {\n            _this.onClosed_();\n          }\n        } else {\n          throw new Error('Unrecognized command received: ' + command);\n        }\n      }, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var pN = args[0],\n            data = args[1];\n\n        _this.incrementIncomingBytes_(args);\n\n        _this.myPacketOrderer.handleResponse(pN, data);\n      }, function () {\n        _this.onClosed_();\n      }, _this.urlFn); //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n      //from cache.\n\n      var urlParams = {};\n      urlParams[exports.FIREBASE_LONGPOLL_START_PARAM] = 't';\n      urlParams[exports.FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);\n      if (_this.scriptTagHolder.uniqueCallbackIdentifier) urlParams[exports.FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier;\n      urlParams[Constants_1.VERSION_PARAM] = Constants_1.PROTOCOL_VERSION;\n\n      if (_this.transportSessionId) {\n        urlParams[Constants_1.TRANSPORT_SESSION_PARAM] = _this.transportSessionId;\n      }\n\n      if (_this.lastSessionId) {\n        urlParams[Constants_1.LAST_SESSION_PARAM] = _this.lastSessionId;\n      }\n\n      if (!util_3.isNodeSdk() && typeof location !== 'undefined' && location.href && location.href.indexOf(Constants_1.FORGE_DOMAIN) !== -1) {\n        urlParams[Constants_1.REFERER_PARAM] = Constants_1.FORGE_REF;\n      }\n\n      var connectURL = _this.urlFn(urlParams);\n\n      _this.log_('Connecting via long-poll to ' + connectURL);\n\n      _this.scriptTagHolder.addTag(connectURL, function () {\n        /* do nothing */\n      });\n    });\n  };\n  /**\r\n   * Call this when a handshake has completed successfully and we want to consider the connection established\r\n   */\n\n\n  BrowserPollConnection.prototype.start = function () {\n    this.scriptTagHolder.startLongPoll(this.id, this.password);\n    this.addDisconnectPingFrame(this.id, this.password);\n  };\n  /**\r\n   * Forces long polling to be considered as a potential transport\r\n   */\n\n\n  BrowserPollConnection.forceAllow = function () {\n    BrowserPollConnection.forceAllow_ = true;\n  };\n  /**\r\n   * Forces longpolling to not be considered as a potential transport\r\n   */\n\n\n  BrowserPollConnection.forceDisallow = function () {\n    BrowserPollConnection.forceDisallow_ = true;\n  }; // Static method, use string literal so it can be accessed in a generic way\n\n\n  BrowserPollConnection.isAvailable = function () {\n    // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n    // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\n    return BrowserPollConnection.forceAllow_ || !BrowserPollConnection.forceDisallow_ && typeof document !== 'undefined' && document.createElement != null && !util_1.isChromeExtensionContentScript() && !util_1.isWindowsStoreApp() && !util_3.isNodeSdk();\n  };\n  /**\r\n   * No-op for polling\r\n   */\n\n\n  BrowserPollConnection.prototype.markConnectionHealthy = function () {};\n  /**\r\n   * Stops polling and cleans up the iframe\r\n   * @private\r\n   */\n\n\n  BrowserPollConnection.prototype.shutdown_ = function () {\n    this.isClosed_ = true;\n\n    if (this.scriptTagHolder) {\n      this.scriptTagHolder.close();\n      this.scriptTagHolder = null;\n    } //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\n\n\n    if (this.myDisconnFrame) {\n      document.body.removeChild(this.myDisconnFrame);\n      this.myDisconnFrame = null;\n    }\n\n    if (this.connectTimeoutTimer_) {\n      clearTimeout(this.connectTimeoutTimer_);\n      this.connectTimeoutTimer_ = null;\n    }\n  };\n  /**\r\n   * Triggered when this transport is closed\r\n   * @private\r\n   */\n\n\n  BrowserPollConnection.prototype.onClosed_ = function () {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is closing itself');\n      this.shutdown_();\n\n      if (this.onDisconnect_) {\n        this.onDisconnect_(this.everConnected_);\n        this.onDisconnect_ = null;\n      }\n    }\n  };\n  /**\r\n   * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\r\n   * that we've left.\r\n   */\n\n\n  BrowserPollConnection.prototype.close = function () {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is being closed.');\n      this.shutdown_();\n    }\n  };\n  /**\r\n   * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\r\n   * broken into chunks (since URLs have a small maximum length).\r\n   * @param {!Object} data The JSON data to transmit.\r\n   */\n\n\n  BrowserPollConnection.prototype.send = function (data) {\n    var dataStr = util_2.stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length); //first, lets get the base64-encoded data\n\n    var base64data = util_2.base64Encode(dataStr); //We can only fit a certain amount in each URL, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n\n    var dataSegs = util_1.splitStringBySize(base64data, MAX_PAYLOAD_SIZE); //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n    //of segments so that we can reassemble the packet on the server.\n\n    for (var i = 0; i < dataSegs.length; i++) {\n      this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);\n      this.curSegmentNum++;\n    }\n  };\n  /**\r\n   * This is how we notify the server that we're leaving.\r\n   * We aren't able to send requests with DHTML on a window close event, but we can\r\n   * trigger XHR requests in some browsers (everything but Opera basically).\r\n   * @param {!string} id\r\n   * @param {!string} pw\r\n   */\n\n\n  BrowserPollConnection.prototype.addDisconnectPingFrame = function (id, pw) {\n    if (util_3.isNodeSdk()) return;\n    this.myDisconnFrame = document.createElement('iframe');\n    var urlParams = {};\n    urlParams[exports.FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\n    urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = id;\n    urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = pw;\n    this.myDisconnFrame.src = this.urlFn(urlParams);\n    this.myDisconnFrame.style.display = 'none';\n    document.body.appendChild(this.myDisconnFrame);\n  };\n  /**\r\n   * Used to track the bytes received by this client\r\n   * @param {*} args\r\n   * @private\r\n   */\n\n\n  BrowserPollConnection.prototype.incrementIncomingBytes_ = function (args) {\n    // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\n    var bytesReceived = util_2.stringify(args).length;\n    this.bytesReceived += bytesReceived;\n    this.stats_.incrementCounter('bytes_received', bytesReceived);\n  };\n\n  return BrowserPollConnection;\n}();\n\nexports.BrowserPollConnection = BrowserPollConnection;\n/*********************************************************************************************\r\n * A wrapper around an iframe that is used as a long-polling script holder.\r\n * @constructor\r\n *********************************************************************************************/\n\nvar FirebaseIFrameScriptHolder =\n/** @class */\nfunction () {\n  /**\r\n   * @param commandCB - The callback to be called when control commands are recevied from the server.\r\n   * @param onMessageCB - The callback to be triggered when responses arrive from the server.\r\n   * @param onDisconnect - The callback to be triggered when this tag holder is closed\r\n   * @param urlFn - A function that provides the URL of the endpoint to send data to.\r\n   */\n  function FirebaseIFrameScriptHolder(commandCB, onMessageCB, onDisconnect, urlFn) {\n    this.onDisconnect = onDisconnect;\n    this.urlFn = urlFn; //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n    //problems in some browsers.\n\n    /**\r\n     * @type {CountedSet.<number, number>}\r\n     */\n\n    this.outstandingRequests = new CountedSet_1.CountedSet(); //A queue of the pending segments waiting for transmission to the server.\n\n    this.pendingSegs = []; //A serial number. We use this for two things:\n    // 1) A way to ensure the browser doesn't cache responses to polls\n    // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n    //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n    //    JSONP code in the order it was added to the iframe.\n\n    this.currentSerial = Math.floor(Math.random() * 100000000); // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n    // incoming data from the server that we're waiting for).\n\n    this.sendNewPolls = true;\n\n    if (!util_3.isNodeSdk()) {\n      //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n      //iframes where we put the long-polling script tags. We have two callbacks:\n      //   1) Command Callback - Triggered for control issues, like starting a connection.\n      //   2) Message Callback - Triggered when new data arrives.\n      this.uniqueCallbackIdentifier = util_1.LUIDGenerator();\n      window[exports.FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;\n      window[exports.FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB; //Create an iframe for us to add script tags to.\n\n      this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_(); // Set the iframe's contents.\n\n      var script = ''; // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n      // for ie9, but ie8 needs to do it again in the document itself.\n\n      if (this.myIFrame.src && this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {\n        var currentDomain = document.domain;\n        script = '<script>document.domain=\"' + currentDomain + '\";</script>';\n      }\n\n      var iframeContents = '<html><body>' + script + '</body></html>';\n\n      try {\n        this.myIFrame.doc.open();\n        this.myIFrame.doc.write(iframeContents);\n        this.myIFrame.doc.close();\n      } catch (e) {\n        util_1.log('frame writing exception');\n\n        if (e.stack) {\n          util_1.log(e.stack);\n        }\n\n        util_1.log(e);\n      }\n    } else {\n      this.commandCB = commandCB;\n      this.onMessageCB = onMessageCB;\n    }\n  }\n  /**\r\n   * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\r\n   * actually use.\r\n   * @private\r\n   * @return {Element}\r\n   */\n\n\n  FirebaseIFrameScriptHolder.createIFrame_ = function () {\n    var iframe = document.createElement('iframe');\n    iframe.style.display = 'none'; // This is necessary in order to initialize the document inside the iframe\n\n    if (document.body) {\n      document.body.appendChild(iframe);\n\n      try {\n        // If document.domain has been modified in IE, this will throw an error, and we need to set the\n        // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n        // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\n        var a = iframe.contentWindow.document;\n\n        if (!a) {\n          // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\n          util_1.log('No IE domain setting required');\n        }\n      } catch (e) {\n        var domain = document.domain;\n        iframe.src = \"javascript:void((function(){document.open();document.domain='\" + domain + \"';document.close();})())\";\n      }\n    } else {\n      // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n      // never gets hit.\n      throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\n    } // Get the document of the iframe in a browser-specific way.\n\n\n    if (iframe.contentDocument) {\n      iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari\n    } else if (iframe.contentWindow) {\n      iframe.doc = iframe.contentWindow.document; // Internet Explorer\n    } else if (iframe.document) {\n      iframe.doc = iframe.document; //others?\n    }\n\n    return iframe;\n  };\n  /**\r\n   * Cancel all outstanding queries and remove the frame.\r\n   */\n\n\n  FirebaseIFrameScriptHolder.prototype.close = function () {\n    var _this = this; //Mark this iframe as dead, so no new requests are sent.\n\n\n    this.alive = false;\n\n    if (this.myIFrame) {\n      //We have to actually remove all of the html inside this iframe before removing it from the\n      //window, or IE will continue loading and executing the script tags we've already added, which\n      //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.\n      this.myIFrame.doc.body.innerHTML = '';\n      setTimeout(function () {\n        if (_this.myIFrame !== null) {\n          document.body.removeChild(_this.myIFrame);\n          _this.myIFrame = null;\n        }\n      }, Math.floor(0));\n    }\n\n    if (util_3.isNodeSdk() && this.myID) {\n      var urlParams = {};\n      urlParams[exports.FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM] = 't';\n      urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      var theURL = this.urlFn(urlParams);\n      FirebaseIFrameScriptHolder.nodeRestRequest(theURL);\n    } // Protect from being called recursively.\n\n\n    var onDisconnect = this.onDisconnect;\n\n    if (onDisconnect) {\n      this.onDisconnect = null;\n      onDisconnect();\n    }\n  };\n  /**\r\n   * Actually start the long-polling session by adding the first script tag(s) to the iframe.\r\n   * @param {!string} id - The ID of this connection\r\n   * @param {!string} pw - The password for this connection\r\n   */\n\n\n  FirebaseIFrameScriptHolder.prototype.startLongPoll = function (id, pw) {\n    this.myID = id;\n    this.myPW = pw;\n    this.alive = true; //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\n\n    while (this.newRequest_()) {}\n  };\n  /**\r\n   * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\r\n   * too many outstanding requests and we are still alive.\r\n   *\r\n   * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\r\n   * needed.\r\n   */\n\n\n  FirebaseIFrameScriptHolder.prototype.newRequest_ = function () {\n    // We keep one outstanding request open all the time to receive data, but if we need to send data\n    // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n    // close the old request.\n    if (this.alive && this.sendNewPolls && this.outstandingRequests.count() < (this.pendingSegs.length > 0 ? 2 : 1)) {\n      //construct our url\n      this.currentSerial++;\n      var urlParams = {};\n      urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      urlParams[exports.FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\n      var theURL = this.urlFn(urlParams); //Now add as much data as we can.\n\n      var curDataString = '';\n      var i = 0;\n\n      while (this.pendingSegs.length > 0) {\n        //first, lets see if the next segment will fit.\n        var nextSeg = this.pendingSegs[0];\n\n        if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {\n          //great, the segment will fit. Lets append it.\n          var theSeg = this.pendingSegs.shift();\n          curDataString = curDataString + '&' + exports.FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + '=' + theSeg.seg + '&' + exports.FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + '=' + theSeg.ts + '&' + exports.FIREBASE_LONGPOLL_DATA_PARAM + i + '=' + theSeg.d;\n          i++;\n        } else {\n          break;\n        }\n      }\n\n      theURL = theURL + curDataString;\n      this.addLongPollTag_(theURL, this.currentSerial);\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Queue a packet for transmission to the server.\r\n   * @param segnum - A sequential id for this packet segment used for reassembly\r\n   * @param totalsegs - The total number of segments in this packet\r\n   * @param data - The data for this segment.\r\n   */\n\n\n  FirebaseIFrameScriptHolder.prototype.enqueueSegment = function (segnum, totalsegs, data) {\n    //add this to the queue of segments to send.\n    this.pendingSegs.push({\n      seg: segnum,\n      ts: totalsegs,\n      d: data\n    }); //send the data immediately if there isn't already data being transmitted, unless\n    //startLongPoll hasn't been called yet.\n\n    if (this.alive) {\n      this.newRequest_();\n    }\n  };\n  /**\r\n   * Add a script tag for a regular long-poll request.\r\n   * @param {!string} url - The URL of the script tag.\r\n   * @param {!number} serial - The serial number of the request.\r\n   * @private\r\n   */\n\n\n  FirebaseIFrameScriptHolder.prototype.addLongPollTag_ = function (url, serial) {\n    var _this = this; //remember that we sent this request.\n\n\n    this.outstandingRequests.add(serial, 1);\n\n    var doNewRequest = function () {\n      _this.outstandingRequests.remove(serial);\n\n      _this.newRequest_();\n    }; // If this request doesn't return on its own accord (by the server sending us some data), we'll\n    // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\n\n\n    var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));\n\n    var readyStateCB = function () {\n      // Request completed.  Cancel the keepalive.\n      clearTimeout(keepaliveTimeout); // Trigger a new request so we can continue receiving data.\n\n      doNewRequest();\n    };\n\n    this.addTag(url, readyStateCB);\n  };\n  /**\r\n   * Add an arbitrary script tag to the iframe.\r\n   * @param {!string} url - The URL for the script tag source.\r\n   * @param {!function()} loadCB - A callback to be triggered once the script has loaded.\r\n   */\n\n\n  FirebaseIFrameScriptHolder.prototype.addTag = function (url, loadCB) {\n    var _this = this;\n\n    if (util_3.isNodeSdk()) {\n      this.doNodeLongPoll(url, loadCB);\n    } else {\n      setTimeout(function () {\n        try {\n          // if we're already closed, don't add this poll\n          if (!_this.sendNewPolls) return;\n\n          var newScript_1 = _this.myIFrame.doc.createElement('script');\n\n          newScript_1.type = 'text/javascript';\n          newScript_1.async = true;\n          newScript_1.src = url;\n\n          newScript_1.onload = newScript_1.onreadystatechange = function () {\n            var rstate = newScript_1.readyState;\n\n            if (!rstate || rstate === 'loaded' || rstate === 'complete') {\n              newScript_1.onload = newScript_1.onreadystatechange = null;\n\n              if (newScript_1.parentNode) {\n                newScript_1.parentNode.removeChild(newScript_1);\n              }\n\n              loadCB();\n            }\n          };\n\n          newScript_1.onerror = function () {\n            util_1.log('Long-poll script failed to load: ' + url);\n            _this.sendNewPolls = false;\n\n            _this.close();\n          };\n\n          _this.myIFrame.doc.body.appendChild(newScript_1);\n        } catch (e) {// TODO: we should make this error visible somehow\n        }\n      }, Math.floor(1));\n    }\n  };\n\n  return FirebaseIFrameScriptHolder;\n}();\n\nexports.FirebaseIFrameScriptHolder = FirebaseIFrameScriptHolder;","map":{"version":3,"mappings":"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","names":["exports","MAX_URL_DATA_SIZE","SEG_HEADER_SIZE","MAX_PAYLOAD_SIZE","KEEPALIVE_REQUEST_INTERVAL","LP_CONNECT_TIMEOUT","connId","repoInfo","transportSessionId","lastSessionId","log_","util_1","stats_","StatsManager_1","getCollection","urlFn","params","connectionURL","Constants_1","BrowserPollConnection","onMessage","onDisconnect","curSegmentNum","onDisconnect_","myPacketOrderer","PacketReceiver_1","isClosed_","connectTimeoutTimer_","setTimeout","_this","onClosed_","Math","floor","scriptTagHolder","FirebaseIFrameScriptHolder","args","arg1","arg2","arg3","arg4","incrementIncomingBytes_","clearTimeout","everConnected_","command","id","password","sendNewPolls","closeAfter","Error","data","handleResponse","pN","urlParams","random","uniqueCallbackIdentifier","util_3","location","href","indexOf","connectURL","addTag","startLongPoll","addDisconnectPingFrame","forceAllow_","forceDisallow_","document","createElement","close","myDisconnFrame","body","removeChild","shutdown_","dataStr","util_2","bytesSent","length","incrementCounter","base64data","dataSegs","i","enqueueSegment","pw","src","style","display","appendChild","bytesReceived","commandCB","onMessageCB","CountedSet_1","window","myIFrame","createIFrame_","script","substr","currentDomain","domain","iframeContents","doc","open","write","e","stack","iframe","a","contentWindow","contentDocument","alive","innerHTML","myID","myPW","theURL","nodeRestRequest","newRequest_","outstandingRequests","count","pendingSegs","currentSerial","curDataString","nextSeg","d","theSeg","shift","seg","ts","addLongPollTag_","segnum","totalsegs","push","url","serial","add","doNewRequest","remove","keepaliveTimeout","readyStateCB","loadCB","doNodeLongPoll","newScript_1","type","async","onload","onreadystatechange","rstate","readyState","parentNode","onerror"],"sources":["../src/realtime/BrowserPollConnection.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  executeWhenDOMReady,\n  isChromeExtensionContentScript,\n  isWindowsStoreApp,\n  log,\n  logWrapper,\n  LUIDGenerator,\n  splitStringBySize\n} from '../core/util/util';\nimport { CountedSet } from '../core/util/CountedSet';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport { PacketReceiver } from './polling/PacketReceiver';\nimport {\n  FORGE_DOMAIN,\n  FORGE_REF,\n  LAST_SESSION_PARAM,\n  LONG_POLLING,\n  PROTOCOL_VERSION,\n  REFERER_PARAM,\n  TRANSPORT_SESSION_PARAM,\n  VERSION_PARAM\n} from './Constants';\nimport { base64Encode, stringify } from '@firebase/util';\nimport { isNodeSdk } from '@firebase/util';\nimport { Transport } from './Transport';\nimport { RepoInfo } from '../core/RepoInfo';\nimport { StatsCollection } from '../core/stats/StatsCollection';\n\n// URL query parameters associated with longpolling\nexport const FIREBASE_LONGPOLL_START_PARAM = 'start';\nexport const FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\nexport const FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\nexport const FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\nexport const FIREBASE_LONGPOLL_ID_PARAM = 'id';\nexport const FIREBASE_LONGPOLL_PW_PARAM = 'pw';\nexport const FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\nexport const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\nexport const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\nexport const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\nexport const FIREBASE_LONGPOLL_DATA_PARAM = 'd';\nexport const FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';\nexport const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';\n\n//Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\nconst MAX_URL_DATA_SIZE = 1870;\nconst SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\nconst MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\n\n/**\n * Keepalive period\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\n * length of 30 seconds that we can't exceed.\n * @const\n * @type {number}\n */\nconst KEEPALIVE_REQUEST_INTERVAL = 25000;\n\n/**\n * How long to wait before aborting a long-polling connection attempt.\n * @const\n * @type {number}\n */\nconst LP_CONNECT_TIMEOUT = 30000;\n\n/**\n * This class manages a single long-polling connection.\n *\n * @constructor\n * @implements {Transport}\n */\nexport class BrowserPollConnection implements Transport {\n  bytesSent = 0;\n  bytesReceived = 0;\n  urlFn: (params: object) => string;\n  scriptTagHolder: FirebaseIFrameScriptHolder;\n  myDisconnFrame: HTMLIFrameElement;\n  curSegmentNum: number;\n  myPacketOrderer: PacketReceiver;\n  id: string;\n  password: string;\n  private log_: (...a: any[]) => void;\n  private stats_: StatsCollection;\n  private everConnected_ = false;\n  private isClosed_: boolean;\n  private connectTimeoutTimer_: number | null;\n  private onDisconnect_: ((a?: boolean) => void) | null;\n\n  /**\n   * @param {string} connId An identifier for this connection, used for logging\n   * @param {RepoInfo} repoInfo The info for the endpoint to send data to.\n   * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing\n   *                                         transport session\n   * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a\n   *                                     connection previously\n   */\n  constructor(\n    public connId: string,\n    public repoInfo: RepoInfo,\n    public transportSessionId?: string,\n    public lastSessionId?: string\n  ) {\n    this.log_ = logWrapper(connId);\n    this.stats_ = StatsManager.getCollection(repoInfo);\n    this.urlFn = (params: { [k: string]: string }) =>\n      repoInfo.connectionURL(LONG_POLLING, params);\n  }\n\n  /**\n   *\n   * @param {function(Object)} onMessage Callback when messages arrive\n   * @param {function()} onDisconnect Callback with connection lost.\n   */\n  open(onMessage: (msg: Object) => void, onDisconnect: (a?: boolean) => void) {\n    this.curSegmentNum = 0;\n    this.onDisconnect_ = onDisconnect;\n    this.myPacketOrderer = new PacketReceiver(onMessage);\n    this.isClosed_ = false;\n\n    this.connectTimeoutTimer_ = setTimeout(() => {\n      this.log_('Timed out trying to connect.');\n      // Make sure we clear the host cache\n      this.onClosed_();\n      this.connectTimeoutTimer_ = null;\n    }, Math.floor(LP_CONNECT_TIMEOUT)) as any;\n\n    // Ensure we delay the creation of the iframe until the DOM is loaded.\n    executeWhenDOMReady(() => {\n      if (this.isClosed_) return;\n\n      //Set up a callback that gets triggered once a connection is set up.\n      this.scriptTagHolder = new FirebaseIFrameScriptHolder(\n        (...args) => {\n          const [command, arg1, arg2, arg3, arg4] = args;\n          this.incrementIncomingBytes_(args);\n          if (!this.scriptTagHolder) return; // we closed the connection.\n\n          if (this.connectTimeoutTimer_) {\n            clearTimeout(this.connectTimeoutTimer_);\n            this.connectTimeoutTimer_ = null;\n          }\n          this.everConnected_ = true;\n          if (command == FIREBASE_LONGPOLL_START_PARAM) {\n            this.id = arg1;\n            this.password = arg2;\n          } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\n            // Don't clear the host cache. We got a response from the server, so we know it's reachable\n            if (arg1) {\n              // We aren't expecting any more data (other than what the server's already in the process of sending us\n              // through our already open polls), so don't send any more.\n              this.scriptTagHolder.sendNewPolls = false;\n\n              // arg1 in this case is the last response number sent by the server. We should try to receive\n              // all of the responses up to this one before closing\n              this.myPacketOrderer.closeAfter(arg1, () => {\n                this.onClosed_();\n              });\n            } else {\n              this.onClosed_();\n            }\n          } else {\n            throw new Error('Unrecognized command received: ' + command);\n          }\n        },\n        (...args) => {\n          const [pN, data] = args;\n          this.incrementIncomingBytes_(args);\n          this.myPacketOrderer.handleResponse(pN, data);\n        },\n        () => {\n          this.onClosed_();\n        },\n        this.urlFn\n      );\n\n      //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n      //from cache.\n      const urlParams: { [k: string]: string | number } = {};\n      urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';\n      urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(\n        Math.random() * 100000000\n      );\n      if (this.scriptTagHolder.uniqueCallbackIdentifier)\n        urlParams[\n          FIREBASE_LONGPOLL_CALLBACK_ID_PARAM\n        ] = this.scriptTagHolder.uniqueCallbackIdentifier;\n      urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n      if (this.transportSessionId) {\n        urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;\n      }\n      if (this.lastSessionId) {\n        urlParams[LAST_SESSION_PARAM] = this.lastSessionId;\n      }\n      if (\n        !isNodeSdk() &&\n        typeof location !== 'undefined' &&\n        location.href &&\n        location.href.indexOf(FORGE_DOMAIN) !== -1\n      ) {\n        urlParams[REFERER_PARAM] = FORGE_REF;\n      }\n      const connectURL = this.urlFn(urlParams);\n      this.log_('Connecting via long-poll to ' + connectURL);\n      this.scriptTagHolder.addTag(connectURL, () => {\n        /* do nothing */\n      });\n    });\n  }\n\n  /**\n   * Call this when a handshake has completed successfully and we want to consider the connection established\n   */\n  start() {\n    this.scriptTagHolder.startLongPoll(this.id, this.password);\n    this.addDisconnectPingFrame(this.id, this.password);\n  }\n\n  private static forceAllow_: boolean;\n\n  /**\n   * Forces long polling to be considered as a potential transport\n   */\n  static forceAllow() {\n    BrowserPollConnection.forceAllow_ = true;\n  }\n\n  private static forceDisallow_: boolean;\n\n  /**\n   * Forces longpolling to not be considered as a potential transport\n   */\n  static forceDisallow() {\n    BrowserPollConnection.forceDisallow_ = true;\n  }\n\n  // Static method, use string literal so it can be accessed in a generic way\n  static isAvailable() {\n    // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n    // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\n    return (\n      BrowserPollConnection.forceAllow_ ||\n      (!BrowserPollConnection.forceDisallow_ &&\n        typeof document !== 'undefined' &&\n        document.createElement != null &&\n        !isChromeExtensionContentScript() &&\n        !isWindowsStoreApp() &&\n        !isNodeSdk())\n    );\n  }\n\n  /**\n   * No-op for polling\n   */\n  markConnectionHealthy() {}\n\n  /**\n   * Stops polling and cleans up the iframe\n   * @private\n   */\n  private shutdown_() {\n    this.isClosed_ = true;\n\n    if (this.scriptTagHolder) {\n      this.scriptTagHolder.close();\n      this.scriptTagHolder = null;\n    }\n\n    //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\n    if (this.myDisconnFrame) {\n      document.body.removeChild(this.myDisconnFrame);\n      this.myDisconnFrame = null;\n    }\n\n    if (this.connectTimeoutTimer_) {\n      clearTimeout(this.connectTimeoutTimer_);\n      this.connectTimeoutTimer_ = null;\n    }\n  }\n\n  /**\n   * Triggered when this transport is closed\n   * @private\n   */\n  private onClosed_() {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is closing itself');\n      this.shutdown_();\n\n      if (this.onDisconnect_) {\n        this.onDisconnect_(this.everConnected_);\n        this.onDisconnect_ = null;\n      }\n    }\n  }\n\n  /**\n   * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\n   * that we've left.\n   */\n  close() {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is being closed.');\n      this.shutdown_();\n    }\n  }\n\n  /**\n   * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\n   * broken into chunks (since URLs have a small maximum length).\n   * @param {!Object} data The JSON data to transmit.\n   */\n  send(data: Object) {\n    const dataStr = stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n\n    //first, lets get the base64-encoded data\n    const base64data = base64Encode(dataStr);\n\n    //We can only fit a certain amount in each URL, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n    const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\n\n    //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n    //of segments so that we can reassemble the packet on the server.\n    for (let i = 0; i < dataSegs.length; i++) {\n      this.scriptTagHolder.enqueueSegment(\n        this.curSegmentNum,\n        dataSegs.length,\n        dataSegs[i]\n      );\n      this.curSegmentNum++;\n    }\n  }\n\n  /**\n   * This is how we notify the server that we're leaving.\n   * We aren't able to send requests with DHTML on a window close event, but we can\n   * trigger XHR requests in some browsers (everything but Opera basically).\n   * @param {!string} id\n   * @param {!string} pw\n   */\n  addDisconnectPingFrame(id: string, pw: string) {\n    if (isNodeSdk()) return;\n    this.myDisconnFrame = document.createElement('iframe');\n    const urlParams: { [k: string]: string } = {};\n    urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\n    urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\n    urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\n    this.myDisconnFrame.src = this.urlFn(urlParams);\n    this.myDisconnFrame.style.display = 'none';\n\n    document.body.appendChild(this.myDisconnFrame);\n  }\n\n  /**\n   * Used to track the bytes received by this client\n   * @param {*} args\n   * @private\n   */\n  private incrementIncomingBytes_(args: any) {\n    // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\n    const bytesReceived = stringify(args).length;\n    this.bytesReceived += bytesReceived;\n    this.stats_.incrementCounter('bytes_received', bytesReceived);\n  }\n}\n\nexport interface IFrameElement extends HTMLIFrameElement {\n  doc: Document;\n}\n\n/*********************************************************************************************\n * A wrapper around an iframe that is used as a long-polling script holder.\n * @constructor\n *********************************************************************************************/\nexport class FirebaseIFrameScriptHolder {\n  //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n  //problems in some browsers.\n  /**\n   * @type {CountedSet.<number, number>}\n   */\n  outstandingRequests = new CountedSet<number, number>();\n\n  //A queue of the pending segments waiting for transmission to the server.\n  pendingSegs: { seg: number; ts: number; d: any }[] = [];\n\n  //A serial number. We use this for two things:\n  // 1) A way to ensure the browser doesn't cache responses to polls\n  // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n  //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n  //    JSONP code in the order it was added to the iframe.\n  currentSerial = Math.floor(Math.random() * 100000000);\n\n  // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n  // incoming data from the server that we're waiting for).\n  sendNewPolls = true;\n\n  uniqueCallbackIdentifier: number;\n  myIFrame: IFrameElement;\n  alive: boolean;\n  myID: string;\n  myPW: string;\n  commandCB: (command: string, ...args: any[]) => void;\n  onMessageCB: (...args: any[]) => void;\n\n  /**\n   * @param commandCB - The callback to be called when control commands are recevied from the server.\n   * @param onMessageCB - The callback to be triggered when responses arrive from the server.\n   * @param onDisconnect - The callback to be triggered when this tag holder is closed\n   * @param urlFn - A function that provides the URL of the endpoint to send data to.\n   */\n  constructor(\n    commandCB: (command: string, ...args: any[]) => void,\n    onMessageCB: (...args: any[]) => void,\n    public onDisconnect: () => void,\n    public urlFn: (a: object) => string\n  ) {\n    if (!isNodeSdk()) {\n      //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n      //iframes where we put the long-polling script tags. We have two callbacks:\n      //   1) Command Callback - Triggered for control issues, like starting a connection.\n      //   2) Message Callback - Triggered when new data arrives.\n      this.uniqueCallbackIdentifier = LUIDGenerator();\n      (window as any)[\n        FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier\n      ] = commandCB;\n      (window as any)[\n        FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier\n      ] = onMessageCB;\n\n      //Create an iframe for us to add script tags to.\n      this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\n\n      // Set the iframe's contents.\n      let script = '';\n      // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n      // for ie9, but ie8 needs to do it again in the document itself.\n      if (\n        this.myIFrame.src &&\n        this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:'\n      ) {\n        const currentDomain = document.domain;\n        script = '<script>document.domain=\"' + currentDomain + '\";</script>';\n      }\n      const iframeContents = '<html><body>' + script + '</body></html>';\n      try {\n        this.myIFrame.doc.open();\n        this.myIFrame.doc.write(iframeContents);\n        this.myIFrame.doc.close();\n      } catch (e) {\n        log('frame writing exception');\n        if (e.stack) {\n          log(e.stack);\n        }\n        log(e);\n      }\n    } else {\n      this.commandCB = commandCB;\n      this.onMessageCB = onMessageCB;\n    }\n  }\n\n  /**\n   * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\n   * actually use.\n   * @private\n   * @return {Element}\n   */\n  private static createIFrame_(): IFrameElement {\n    const iframe = document.createElement('iframe') as IFrameElement;\n    iframe.style.display = 'none';\n\n    // This is necessary in order to initialize the document inside the iframe\n    if (document.body) {\n      document.body.appendChild(iframe);\n      try {\n        // If document.domain has been modified in IE, this will throw an error, and we need to set the\n        // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n        // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\n        const a = iframe.contentWindow.document;\n        if (!a) {\n          // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\n          log('No IE domain setting required');\n        }\n      } catch (e) {\n        const domain = document.domain;\n        iframe.src =\n          \"javascript:void((function(){document.open();document.domain='\" +\n          domain +\n          \"';document.close();})())\";\n      }\n    } else {\n      // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n      // never gets hit.\n      throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\n    }\n\n    // Get the document of the iframe in a browser-specific way.\n    if (iframe.contentDocument) {\n      (iframe as any).doc = iframe.contentDocument; // Firefox, Opera, Safari\n    } else if (iframe.contentWindow) {\n      (iframe as any).doc = iframe.contentWindow.document; // Internet Explorer\n    } else if ((iframe as any).document) {\n      (iframe as any).doc = (iframe as any).document; //others?\n    }\n\n    return iframe;\n  }\n\n  /**\n   * Cancel all outstanding queries and remove the frame.\n   */\n  close() {\n    //Mark this iframe as dead, so no new requests are sent.\n    this.alive = false;\n\n    if (this.myIFrame) {\n      //We have to actually remove all of the html inside this iframe before removing it from the\n      //window, or IE will continue loading and executing the script tags we've already added, which\n      //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.\n      this.myIFrame.doc.body.innerHTML = '';\n      setTimeout(() => {\n        if (this.myIFrame !== null) {\n          document.body.removeChild(this.myIFrame);\n          this.myIFrame = null;\n        }\n      }, Math.floor(0));\n    }\n\n    if (isNodeSdk() && this.myID) {\n      const urlParams: { [k: string]: string } = {};\n      urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM] = 't';\n      urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      const theURL = this.urlFn(urlParams);\n      (FirebaseIFrameScriptHolder as any).nodeRestRequest(theURL);\n    }\n\n    // Protect from being called recursively.\n    const onDisconnect = this.onDisconnect;\n    if (onDisconnect) {\n      this.onDisconnect = null;\n      onDisconnect();\n    }\n  }\n\n  /**\n   * Actually start the long-polling session by adding the first script tag(s) to the iframe.\n   * @param {!string} id - The ID of this connection\n   * @param {!string} pw - The password for this connection\n   */\n  startLongPoll(id: string, pw: string) {\n    this.myID = id;\n    this.myPW = pw;\n    this.alive = true;\n\n    //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\n    while (this.newRequest_()) {}\n  }\n\n  /**\n   * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\n   * too many outstanding requests and we are still alive.\n   *\n   * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\n   * needed.\n   */\n  private newRequest_() {\n    // We keep one outstanding request open all the time to receive data, but if we need to send data\n    // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n    // close the old request.\n    if (\n      this.alive &&\n      this.sendNewPolls &&\n      this.outstandingRequests.count() < (this.pendingSegs.length > 0 ? 2 : 1)\n    ) {\n      //construct our url\n      this.currentSerial++;\n      const urlParams: { [k: string]: string | number } = {};\n      urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\n      let theURL = this.urlFn(urlParams);\n      //Now add as much data as we can.\n      let curDataString = '';\n      let i = 0;\n\n      while (this.pendingSegs.length > 0) {\n        //first, lets see if the next segment will fit.\n        const nextSeg = this.pendingSegs[0];\n        if (\n          nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <=\n          MAX_URL_DATA_SIZE\n        ) {\n          //great, the segment will fit. Lets append it.\n          const theSeg = this.pendingSegs.shift();\n          curDataString =\n            curDataString +\n            '&' +\n            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +\n            i +\n            '=' +\n            theSeg.seg +\n            '&' +\n            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +\n            i +\n            '=' +\n            theSeg.ts +\n            '&' +\n            FIREBASE_LONGPOLL_DATA_PARAM +\n            i +\n            '=' +\n            theSeg.d;\n          i++;\n        } else {\n          break;\n        }\n      }\n\n      theURL = theURL + curDataString;\n      this.addLongPollTag_(theURL, this.currentSerial);\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Queue a packet for transmission to the server.\n   * @param segnum - A sequential id for this packet segment used for reassembly\n   * @param totalsegs - The total number of segments in this packet\n   * @param data - The data for this segment.\n   */\n  enqueueSegment(segnum: number, totalsegs: number, data: any) {\n    //add this to the queue of segments to send.\n    this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });\n\n    //send the data immediately if there isn't already data being transmitted, unless\n    //startLongPoll hasn't been called yet.\n    if (this.alive) {\n      this.newRequest_();\n    }\n  }\n\n  /**\n   * Add a script tag for a regular long-poll request.\n   * @param {!string} url - The URL of the script tag.\n   * @param {!number} serial - The serial number of the request.\n   * @private\n   */\n  private addLongPollTag_(url: string, serial: number) {\n    //remember that we sent this request.\n    this.outstandingRequests.add(serial, 1);\n\n    const doNewRequest = () => {\n      this.outstandingRequests.remove(serial);\n      this.newRequest_();\n    };\n\n    // If this request doesn't return on its own accord (by the server sending us some data), we'll\n    // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\n    const keepaliveTimeout = setTimeout(\n      doNewRequest,\n      Math.floor(KEEPALIVE_REQUEST_INTERVAL)\n    );\n\n    const readyStateCB = () => {\n      // Request completed.  Cancel the keepalive.\n      clearTimeout(keepaliveTimeout);\n\n      // Trigger a new request so we can continue receiving data.\n      doNewRequest();\n    };\n\n    this.addTag(url, readyStateCB);\n  }\n\n  /**\n   * Add an arbitrary script tag to the iframe.\n   * @param {!string} url - The URL for the script tag source.\n   * @param {!function()} loadCB - A callback to be triggered once the script has loaded.\n   */\n  addTag(url: string, loadCB: () => void) {\n    if (isNodeSdk()) {\n      (this as any).doNodeLongPoll(url, loadCB);\n    } else {\n      setTimeout(() => {\n        try {\n          // if we're already closed, don't add this poll\n          if (!this.sendNewPolls) return;\n          const newScript = this.myIFrame.doc.createElement('script');\n          newScript.type = 'text/javascript';\n          newScript.async = true;\n          newScript.src = url;\n          newScript.onload = (newScript as any).onreadystatechange = function() {\n            const rstate = (newScript as any).readyState;\n            if (!rstate || rstate === 'loaded' || rstate === 'complete') {\n              newScript.onload = (newScript as any).onreadystatechange = null;\n              if (newScript.parentNode) {\n                newScript.parentNode.removeChild(newScript);\n              }\n              loadCB();\n            }\n          };\n          newScript.onerror = () => {\n            log('Long-poll script failed to load: ' + url);\n            this.sendNewPolls = false;\n            this.close();\n          };\n          this.myIFrame.doc.body.appendChild(newScript);\n        } catch (e) {\n          // TODO: we should make this error visible somehow\n        }\n      }, Math.floor(1));\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}