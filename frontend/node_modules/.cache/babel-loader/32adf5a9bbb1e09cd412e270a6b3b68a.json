{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar stringToByteArray = function (str) {\n  var output = [],\n      p = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n\n    while (c > 255) {\n      output[p++] = c & 255;\n      c >>= 8;\n    }\n\n    output[p++] = c;\n  }\n\n  return output;\n};\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param {Array<number>} bytes Array of numbers representing characters.\r\n * @return {string} Stringification of the array.\r\n */\n\n\nvar byteArrayToString = function (bytes) {\n  var CHUNK_SIZE = 8192; // Special-case the simple case for speed's sake.\n\n  if (bytes.length < CHUNK_SIZE) {\n    return String.fromCharCode.apply(null, bytes);\n  } // The remaining logic splits conversion by chunks since\n  // Function#apply() has a maximum parameter count.\n  // See discussion: http://goo.gl/LrWmZ9\n\n\n  var str = '';\n\n  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    var chunk = bytes.slice(i, i + CHUNK_SIZE);\n    str += String.fromCharCode.apply(null, chunk);\n  }\n\n  return str;\n}; // Static lookup maps, lazily populated by init_()\n\n\nexports.base64 = {\n  /**\r\n   * Maps bytes to characters.\r\n   * @type {Object}\r\n   * @private\r\n   */\n  byteToCharMap_: null,\n\n  /**\r\n   * Maps characters to bytes.\r\n   * @type {Object}\r\n   * @private\r\n   */\n  charToByteMap_: null,\n\n  /**\r\n   * Maps bytes to websafe characters.\r\n   * @type {Object}\r\n   * @private\r\n   */\n  byteToCharMapWebSafe_: null,\n\n  /**\r\n   * Maps websafe characters to bytes.\r\n   * @type {Object}\r\n   * @private\r\n   */\n  charToByteMapWebSafe_: null,\n\n  /**\r\n   * Our default alphabet, shared between\r\n   * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n   * @type {string}\r\n   */\n  ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n\n  /**\r\n   * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n   * @type {string}\r\n   */\n  get ENCODED_VALS() {\n    return this.ENCODED_VALS_BASE + '+/=';\n  },\n\n  /**\r\n   * Our websafe alphabet.\r\n   * @type {string}\r\n   */\n  get ENCODED_VALS_WEBSAFE() {\n    return this.ENCODED_VALS_BASE + '-_.';\n  },\n\n  /**\r\n   * Whether this browser supports the atob and btoa functions. This extension\r\n   * started at Mozilla but is now implemented by many browsers. We use the\r\n   * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n   * but still allowing the standard per-browser compilations.\r\n   *\r\n   * @type {boolean}\r\n   */\n  HAS_NATIVE_SUPPORT: typeof atob === 'function',\n\n  /**\r\n   * Base64-encode an array of bytes.\r\n   *\r\n   * @param {Array<number>|Uint8Array} input An array of bytes (numbers with\r\n   *     value in [0, 255]) to encode.\r\n   * @param {boolean=} opt_webSafe Boolean indicating we should use the\r\n   *     alternative alphabet.\r\n   * @return {string} The base64 encoded string.\r\n   */\n  encodeByteArray: function (input, opt_webSafe) {\n    if (!Array.isArray(input)) {\n      throw Error('encodeByteArray takes an array as a parameter');\n    }\n\n    this.init_();\n    var byteToCharMap = opt_webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n    var output = [];\n\n    for (var i = 0; i < input.length; i += 3) {\n      var byte1 = input[i];\n      var haveByte2 = i + 1 < input.length;\n      var byte2 = haveByte2 ? input[i + 1] : 0;\n      var haveByte3 = i + 2 < input.length;\n      var byte3 = haveByte3 ? input[i + 2] : 0;\n      var outByte1 = byte1 >> 2;\n      var outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n      var outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;\n      var outByte4 = byte3 & 0x3f;\n\n      if (!haveByte3) {\n        outByte4 = 64;\n\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n\n      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n    }\n\n    return output.join('');\n  },\n\n  /**\r\n   * Base64-encode a string.\r\n   *\r\n   * @param {string} input A string to encode.\r\n   * @param {boolean=} opt_webSafe If true, we should use the\r\n   *     alternative alphabet.\r\n   * @return {string} The base64 encoded string.\r\n   */\n  encodeString: function (input, opt_webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {\n      return btoa(input);\n    }\n\n    return this.encodeByteArray(stringToByteArray(input), opt_webSafe);\n  },\n\n  /**\r\n   * Base64-decode a string.\r\n   *\r\n   * @param {string} input to decode.\r\n   * @param {boolean=} opt_webSafe True if we should use the\r\n   *     alternative alphabet.\r\n   * @return {string} string representing the decoded value.\r\n   */\n  decodeString: function (input, opt_webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {\n      return atob(input);\n    }\n\n    return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));\n  },\n\n  /**\r\n   * Base64-decode a string.\r\n   *\r\n   * In base-64 decoding, groups of four characters are converted into three\r\n   * bytes.  If the encoder did not apply padding, the input length may not\r\n   * be a multiple of 4.\r\n   *\r\n   * In this case, the last group will have fewer than 4 characters, and\r\n   * padding will be inferred.  If the group has one or two characters, it decodes\r\n   * to one byte.  If the group has three characters, it decodes to two bytes.\r\n   *\r\n   * @param {string} input Input to decode.\r\n   * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.\r\n   * @return {!Array<number>} bytes representing the decoded value.\r\n   */\n  decodeStringToByteArray: function (input, opt_webSafe) {\n    this.init_();\n    var charToByteMap = opt_webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n    var output = [];\n\n    for (var i = 0; i < input.length;) {\n      var byte1 = charToByteMap[input.charAt(i++)];\n      var haveByte2 = i < input.length;\n      var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n      ++i;\n      var haveByte3 = i < input.length;\n      var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n      var haveByte4 = i < input.length;\n      var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n\n      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n        throw Error();\n      }\n\n      var outByte1 = byte1 << 2 | byte2 >> 4;\n      output.push(outByte1);\n\n      if (byte3 != 64) {\n        var outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;\n        output.push(outByte2);\n\n        if (byte4 != 64) {\n          var outByte3 = byte3 << 6 & 0xc0 | byte4;\n          output.push(outByte3);\n        }\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Lazy static initialization function. Called before\r\n   * accessing any of the static map variables.\r\n   * @private\r\n   */\n  init_: function () {\n    if (!this.byteToCharMap_) {\n      this.byteToCharMap_ = {};\n      this.charToByteMap_ = {};\n      this.byteToCharMapWebSafe_ = {};\n      this.charToByteMapWebSafe_ = {}; // We want quick mappings back and forth, so we precompute two maps.\n\n      for (var i = 0; i < this.ENCODED_VALS.length; i++) {\n        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n        this.charToByteMap_[this.byteToCharMap_[i]] = i;\n        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i; // Be forgiving when decoding and correctly decode both encodings.\n\n        if (i >= this.ENCODED_VALS_BASE.length) {\n          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n        }\n      }\n    }\n  }\n};\n/**\r\n * URL-safe base64 encoding\r\n * @param {!string} str\r\n * @return {!string}\r\n */\n\nexports.base64Encode = function (str) {\n  var utf8Bytes = stringToByteArray(str);\n  return exports.base64.encodeByteArray(utf8Bytes, true);\n};\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param {string} str To be decoded\r\n * @return {?string} Decoded result, if possible\r\n */\n\n\nexports.base64Decode = function (str) {\n  try {\n    return exports.base64.decodeString(str, true);\n  } catch (e) {\n    console.error('base64Decode failed: ', e);\n  }\n\n  return null;\n};","map":{"version":3,"mappings":"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","names":["stringToByteArray","str","output","p","i","length","c","charCodeAt","byteArrayToString","bytes","CHUNK_SIZE","String","fromCharCode","apply","chunk","slice","exports","byteToCharMap_","charToByteMap_","byteToCharMapWebSafe_","charToByteMapWebSafe_","ENCODED_VALS_BASE","ENCODED_VALS","ENCODED_VALS_WEBSAFE","HAS_NATIVE_SUPPORT","atob","encodeByteArray","input","opt_webSafe","Array","isArray","Error","init_","byteToCharMap","byte1","haveByte2","byte2","haveByte3","byte3","outByte1","outByte2","outByte3","outByte4","push","join","encodeString","btoa","decodeString","decodeStringToByteArray","charToByteMap","charAt","haveByte4","byte4","utf8Bytes","e","console","error"],"sources":["../src/crypt.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst stringToByteArray = function(str) {\n  var output = [],\n    p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    while (c > 255) {\n      output[p++] = c & 255;\n      c >>= 8;\n    }\n    output[p++] = c;\n  }\n  return output;\n};\n\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param {Array<number>} bytes Array of numbers representing characters.\n * @return {string} Stringification of the array.\n */\nconst byteArrayToString = function(bytes) {\n  var CHUNK_SIZE = 8192;\n\n  // Special-case the simple case for speed's sake.\n  if (bytes.length < CHUNK_SIZE) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  // The remaining logic splits conversion by chunks since\n  // Function#apply() has a maximum parameter count.\n  // See discussion: http://goo.gl/LrWmZ9\n\n  var str = '';\n  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    var chunk = bytes.slice(i, i + CHUNK_SIZE);\n    str += String.fromCharCode.apply(null, chunk);\n  }\n  return str;\n};\n\n// Static lookup maps, lazily populated by init_()\nexport const base64 = {\n  /**\n   * Maps bytes to characters.\n   * @type {Object}\n   * @private\n   */\n  byteToCharMap_: null,\n\n  /**\n   * Maps characters to bytes.\n   * @type {Object}\n   * @private\n   */\n  charToByteMap_: null,\n\n  /**\n   * Maps bytes to websafe characters.\n   * @type {Object}\n   * @private\n   */\n  byteToCharMapWebSafe_: null,\n\n  /**\n   * Maps websafe characters to bytes.\n   * @type {Object}\n   * @private\n   */\n  charToByteMapWebSafe_: null,\n\n  /**\n   * Our default alphabet, shared between\n   * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n   * @type {string}\n   */\n  ENCODED_VALS_BASE:\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n\n  /**\n   * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n   * @type {string}\n   */\n  get ENCODED_VALS() {\n    return this.ENCODED_VALS_BASE + '+/=';\n  },\n\n  /**\n   * Our websafe alphabet.\n   * @type {string}\n   */\n  get ENCODED_VALS_WEBSAFE() {\n    return this.ENCODED_VALS_BASE + '-_.';\n  },\n\n  /**\n   * Whether this browser supports the atob and btoa functions. This extension\n   * started at Mozilla but is now implemented by many browsers. We use the\n   * ASSUME_* variables to avoid pulling in the full useragent detection library\n   * but still allowing the standard per-browser compilations.\n   *\n   * @type {boolean}\n   */\n  HAS_NATIVE_SUPPORT: typeof atob === 'function',\n\n  /**\n   * Base64-encode an array of bytes.\n   *\n   * @param {Array<number>|Uint8Array} input An array of bytes (numbers with\n   *     value in [0, 255]) to encode.\n   * @param {boolean=} opt_webSafe Boolean indicating we should use the\n   *     alternative alphabet.\n   * @return {string} The base64 encoded string.\n   */\n  encodeByteArray(input, opt_webSafe?) {\n    if (!Array.isArray(input)) {\n      throw Error('encodeByteArray takes an array as a parameter');\n    }\n\n    this.init_();\n\n    var byteToCharMap = opt_webSafe\n      ? this.byteToCharMapWebSafe_\n      : this.byteToCharMap_;\n\n    var output = [];\n\n    for (var i = 0; i < input.length; i += 3) {\n      var byte1 = input[i];\n      var haveByte2 = i + 1 < input.length;\n      var byte2 = haveByte2 ? input[i + 1] : 0;\n      var haveByte3 = i + 2 < input.length;\n      var byte3 = haveByte3 ? input[i + 2] : 0;\n\n      var outByte1 = byte1 >> 2;\n      var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n      var outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n      var outByte4 = byte3 & 0x3f;\n\n      if (!haveByte3) {\n        outByte4 = 64;\n\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n\n      output.push(\n        byteToCharMap[outByte1],\n        byteToCharMap[outByte2],\n        byteToCharMap[outByte3],\n        byteToCharMap[outByte4]\n      );\n    }\n\n    return output.join('');\n  },\n\n  /**\n   * Base64-encode a string.\n   *\n   * @param {string} input A string to encode.\n   * @param {boolean=} opt_webSafe If true, we should use the\n   *     alternative alphabet.\n   * @return {string} The base64 encoded string.\n   */\n  encodeString(input, opt_webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {\n      return btoa(input);\n    }\n    return this.encodeByteArray(stringToByteArray(input), opt_webSafe);\n  },\n\n  /**\n   * Base64-decode a string.\n   *\n   * @param {string} input to decode.\n   * @param {boolean=} opt_webSafe True if we should use the\n   *     alternative alphabet.\n   * @return {string} string representing the decoded value.\n   */\n  decodeString(input, opt_webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {\n      return atob(input);\n    }\n    return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));\n  },\n\n  /**\n   * Base64-decode a string.\n   *\n   * In base-64 decoding, groups of four characters are converted into three\n   * bytes.  If the encoder did not apply padding, the input length may not\n   * be a multiple of 4.\n   *\n   * In this case, the last group will have fewer than 4 characters, and\n   * padding will be inferred.  If the group has one or two characters, it decodes\n   * to one byte.  If the group has three characters, it decodes to two bytes.\n   *\n   * @param {string} input Input to decode.\n   * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.\n   * @return {!Array<number>} bytes representing the decoded value.\n   */\n  decodeStringToByteArray(input, opt_webSafe) {\n    this.init_();\n\n    var charToByteMap = opt_webSafe\n      ? this.charToByteMapWebSafe_\n      : this.charToByteMap_;\n\n    var output = [];\n\n    for (var i = 0; i < input.length; ) {\n      var byte1 = charToByteMap[input.charAt(i++)];\n\n      var haveByte2 = i < input.length;\n      var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n      ++i;\n\n      var haveByte3 = i < input.length;\n      var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n\n      var haveByte4 = i < input.length;\n      var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n\n      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n        throw Error();\n      }\n\n      var outByte1 = (byte1 << 2) | (byte2 >> 4);\n      output.push(outByte1);\n\n      if (byte3 != 64) {\n        var outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\n        output.push(outByte2);\n\n        if (byte4 != 64) {\n          var outByte3 = ((byte3 << 6) & 0xc0) | byte4;\n          output.push(outByte3);\n        }\n      }\n    }\n\n    return output;\n  },\n\n  /**\n   * Lazy static initialization function. Called before\n   * accessing any of the static map variables.\n   * @private\n   */\n  init_() {\n    if (!this.byteToCharMap_) {\n      this.byteToCharMap_ = {};\n      this.charToByteMap_ = {};\n      this.byteToCharMapWebSafe_ = {};\n      this.charToByteMapWebSafe_ = {};\n\n      // We want quick mappings back and forth, so we precompute two maps.\n      for (var i = 0; i < this.ENCODED_VALS.length; i++) {\n        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n        this.charToByteMap_[this.byteToCharMap_[i]] = i;\n        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n\n        // Be forgiving when decoding and correctly decode both encodings.\n        if (i >= this.ENCODED_VALS_BASE.length) {\n          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n        }\n      }\n    }\n  }\n};\n\n/**\n * URL-safe base64 encoding\n * @param {!string} str\n * @return {!string}\n */\nexport const base64Encode = function(str: string): string {\n  const utf8Bytes = stringToByteArray(str);\n  return base64.encodeByteArray(utf8Bytes, true);\n};\n\n/**\n * URL-safe base64 decoding\n *\n * NOTE: DO NOT use the global atob() function - it does NOT support the\n * base64Url variant encoding.\n *\n * @param {string} str To be decoded\n * @return {?string} Decoded result, if possible\n */\nexport const base64Decode = function(str: string): string | null {\n  try {\n    return base64.decodeString(str, true);\n  } catch (e) {\n    console.error('base64Decode failed: ', e);\n  }\n  return null;\n};\n"]},"metadata":{},"sourceType":"script"}