{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ERROR_NAME = 'FirebaseError';\nvar captureStackTrace = Error.captureStackTrace; // Export for faking in tests\n\nfunction patchCapture(captureFake) {\n  var result = captureStackTrace;\n  captureStackTrace = captureFake;\n  return result;\n}\n\nexports.patchCapture = patchCapture;\n\nvar FirebaseError =\n/** @class */\nfunction () {\n  function FirebaseError(code, message) {\n    this.code = code;\n    this.message = message;\n    var stack; // We want the stack value, if implemented by Error\n\n    if (captureStackTrace) {\n      // Patches this.stack, omitted calls above ErrorFactory#create\n      captureStackTrace(this, ErrorFactory.prototype.create);\n    } else {\n      var err_1 = Error.apply(this, arguments);\n      this.name = ERROR_NAME; // Make non-enumerable getter for the property.\n\n      Object.defineProperty(this, 'stack', {\n        get: function () {\n          return err_1.stack;\n        }\n      });\n    }\n  }\n\n  return FirebaseError;\n}();\n\nexports.FirebaseError = FirebaseError; // Back-door inheritance\n\nFirebaseError.prototype = Object.create(Error.prototype);\nFirebaseError.prototype.constructor = FirebaseError;\nFirebaseError.prototype.name = ERROR_NAME;\n\nvar ErrorFactory =\n/** @class */\nfunction () {\n  function ErrorFactory(service, serviceName, errors) {\n    this.service = service;\n    this.serviceName = serviceName;\n    this.errors = errors; // Matches {$name}, by default.\n\n    this.pattern = /\\{\\$([^}]+)}/g; // empty\n  }\n\n  ErrorFactory.prototype.create = function (code, data) {\n    if (data === undefined) {\n      data = {};\n    }\n\n    var template = this.errors[code];\n    var fullCode = this.service + '/' + code;\n    var message;\n\n    if (template === undefined) {\n      message = 'Error';\n    } else {\n      message = template.replace(this.pattern, function (match, key) {\n        var value = data[key];\n        return value !== undefined ? value.toString() : '<' + key + '?>';\n      });\n    } // Service: Error message (service/code).\n\n\n    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n    var err = new FirebaseError(fullCode, message); // Populate the Error object with message parts for programmatic\n    // accesses (e.g., e.file).\n\n    for (var prop in data) {\n      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n        continue;\n      }\n\n      err[prop] = data[prop];\n    }\n\n    return err;\n  };\n\n  return ErrorFactory;\n}();\n\nexports.ErrorFactory = ErrorFactory;","map":{"version":3,"mappings":";;;;;AAyDA,IAAMA,UAAU,GAAG,eAAnB;AAMA,IAAIC,iBAAiB,GAA0CC,KAAa,CACzED,iBADH,C,CAGA;;AACA,sBAA6BE,WAA7B,EAA8C;AAC5C,MAAIC,MAAM,GAAQH,iBAAlB;AACAA,mBAAiB,GAAGE,WAApB;AACA,SAAOC,MAAP;AACD;;AAJDC;;AAoBA;AAAA;AAAA;AAIE,yBAAmBC,IAAnB,EAAwCC,OAAxC,EAAuD;AAApC;AAAqB;AACtC,QAAIC,KAAJ,CADqD,CAErD;;AACA,QAAIP,iBAAJ,EAAuB;AACrB;AACAA,uBAAiB,CAAC,IAAD,EAAOQ,YAAY,CAACC,SAAb,CAAuBC,MAA9B,CAAjB;AACD,KAHD,MAGO;AACL,UAAIC,KAAG,GAAGV,KAAK,CAACW,KAAN,CAAY,IAAZ,EAAkBC,SAAlB,CAAV;AACA,WAAKC,IAAL,GAAYf,UAAZ,CAFK,CAGL;;AACAgB,YAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,OAA5B,EAAqC;AACnCC,WAAG,EAAE;AACH,iBAAON,KAAG,CAACJ,KAAX;AACD;AAHkC,OAArC;AAKD;AACF;;AACH;AArBA;;AAAaH,sC,CAuBb;;AACAc,aAAa,CAACT,SAAd,GAA0BM,MAAM,CAACL,MAAP,CAAcT,KAAK,CAACQ,SAApB,CAA1B;AACAS,aAAa,CAACT,SAAd,CAAwBU,WAAxB,GAAsCD,aAAtC;AACCA,aAAa,CAACT,SAAd,CAAgCK,IAAhC,GAAuCf,UAAvC;;AAED;AAAA;AAAA;AAIE,wBACUqB,OADV,EAEUC,WAFV,EAGUC,MAHV,EAG8B;AAFpB;AACA;AACA,yBAAoB,CAN9B;;AACO,mBAAU,eAAV,CAKuB,CAE5B;AACD;;AAEDd,4CAAOH,IAAP,EAAgBkB,IAAhB,EAAqD;AACnD,QAAIA,IAAI,KAAKC,SAAb,EAAwB;AACtBD,UAAI,GAAG,EAAP;AACD;;AAED,QAAIE,QAAQ,GAAG,KAAKH,MAAL,CAAYjB,IAAZ,CAAf;AAEA,QAAIqB,QAAQ,GAAG,KAAKN,OAAL,GAAe,GAAf,GAAqBf,IAApC;AACA,QAAIC,OAAJ;;AAEA,QAAImB,QAAQ,KAAKD,SAAjB,EAA4B;AAC1BlB,aAAO,GAAG,OAAV;AACD,KAFD,MAEO;AACLA,aAAO,GAAGmB,QAAQ,CAACE,OAAT,CAAiB,KAAKC,OAAtB,EAA+B,UAACC,KAAD,EAAQC,GAAR,EAAW;AAClD,YAAIC,KAAK,GAAGR,IAAK,CAACO,GAAD,CAAjB;AACA,eAAOC,KAAK,KAAKP,SAAV,GAAsBO,KAAK,CAACC,QAAN,EAAtB,GAAyC,MAAMF,GAAN,GAAY,IAA5D;AACD,OAHS,CAAV;AAID,KAjBkD,CAmBnD;;;AACAxB,WAAO,GAAG,KAAKe,WAAL,GAAmB,IAAnB,GAA0Bf,OAA1B,GAAoC,IAApC,GAA2CoB,QAA3C,GAAsD,IAAhE;AACA,QAAIO,GAAG,GAAG,IAAIf,aAAJ,CAAkBQ,QAAlB,EAA4BpB,OAA5B,CAAV,CArBmD,CAuBnD;AACA;;AACA,SAAK,IAAI4B,IAAT,IAAiBX,IAAjB,EAAuB;AACrB,UAAI,CAACA,IAAI,CAACY,cAAL,CAAoBD,IAApB,CAAD,IAA8BA,IAAI,CAACE,KAAL,CAAW,CAAC,CAAZ,MAAmB,GAArD,EAA0D;AACxD;AACD;;AACAH,SAAW,CAACC,IAAD,CAAX,GAAoBX,IAAI,CAACW,IAAD,CAAxB;AACF;;AAED,WAAOD,GAAP;AACD,GAjCD;;AAkCF;AA9CA;;AAAa7B","names":["ERROR_NAME","captureStackTrace","Error","captureFake","result","exports","code","message","stack","ErrorFactory","prototype","create","err_1","apply","arguments","name","Object","defineProperty","get","FirebaseError","constructor","service","serviceName","errors","data","undefined","template","fullCode","replace","pattern","match","key","value","toString","err","prop","hasOwnProperty","slice"],"sources":["../src/errors.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // Typescript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if (e.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nexport type ErrorList<T> = { [code: string]: string };\n\nconst ERROR_NAME = 'FirebaseError';\n\nexport interface StringLike {\n  toString: () => string;\n}\n\nlet captureStackTrace: (obj: Object, fn?: Function) => void = (Error as any)\n  .captureStackTrace;\n\n// Export for faking in tests\nexport function patchCapture(captureFake?: any): any {\n  let result: any = captureStackTrace;\n  captureStackTrace = captureFake;\n  return result;\n}\n\nexport interface FirebaseError {\n  // Unique code for error - format is service/error-code-string\n  code: string;\n\n  // Developer-friendly error message.\n  message: string;\n\n  // Always 'FirebaseError'\n  name: string;\n\n  // Where available - stack backtrace in a string\n  stack: string;\n}\n\nexport class FirebaseError implements FirebaseError {\n  public stack: string;\n  public name: string;\n\n  constructor(public code: string, public message: string) {\n    let stack: string;\n    // We want the stack value, if implemented by Error\n    if (captureStackTrace) {\n      // Patches this.stack, omitted calls above ErrorFactory#create\n      captureStackTrace(this, ErrorFactory.prototype.create);\n    } else {\n      let err = Error.apply(this, arguments);\n      this.name = ERROR_NAME;\n      // Make non-enumerable getter for the property.\n      Object.defineProperty(this, 'stack', {\n        get: function() {\n          return err.stack;\n        }\n      });\n    }\n  }\n}\n\n// Back-door inheritance\nFirebaseError.prototype = Object.create(Error.prototype) as FirebaseError;\nFirebaseError.prototype.constructor = FirebaseError;\n(FirebaseError.prototype as any).name = ERROR_NAME;\n\nexport class ErrorFactory<T extends string> {\n  // Matches {$name}, by default.\n  public pattern = /\\{\\$([^}]+)}/g;\n\n  constructor(\n    private service: string,\n    private serviceName: string,\n    private errors: ErrorList<T>\n  ) {\n    // empty\n  }\n\n  create(code: T, data?: { [prop: string]: StringLike }): FirebaseError {\n    if (data === undefined) {\n      data = {};\n    }\n\n    let template = this.errors[code as string];\n\n    let fullCode = this.service + '/' + code;\n    let message: string;\n\n    if (template === undefined) {\n      message = 'Error';\n    } else {\n      message = template.replace(this.pattern, (match, key) => {\n        let value = data![key];\n        return value !== undefined ? value.toString() : '<' + key + '?>';\n      });\n    }\n\n    // Service: Error message (service/code).\n    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n    let err = new FirebaseError(fullCode, message);\n\n    // Populate the Error object with message parts for programmatic\n    // accesses (e.g., e.file).\n    for (let prop in data) {\n      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n        continue;\n      }\n      (err as any)[prop] = data[prop];\n    }\n\n    return err;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}