{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Path_1 = require(\"../Path\");\n\nvar RepoInfo_1 = require(\"../../RepoInfo\");\n\nvar util_1 = require(\"../util\");\n/**\n * @param {!string} pathString\n * @return {string}\n */\n\n\nfunction decodePath(pathString) {\n  var pathStringDecoded = '';\n  var pieces = pathString.split('/');\n\n  for (var i = 0; i < pieces.length; i++) {\n    if (pieces[i].length > 0) {\n      var piece = pieces[i];\n\n      try {\n        piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\n      } catch (e) {}\n\n      pathStringDecoded += '/' + piece;\n    }\n  }\n\n  return pathStringDecoded;\n}\n/**\n *\n * @param {!string} dataURL\n * @return {{repoInfo: !RepoInfo, path: !Path}}\n */\n\n\nexports.parseRepoInfo = function (dataURL) {\n  var parsedUrl = exports.parseURL(dataURL),\n      namespace = parsedUrl.subdomain;\n\n  if (parsedUrl.domain === 'firebase') {\n    util_1.fatal(parsedUrl.host + ' is no longer supported. ' + 'Please use <YOUR FIREBASE>.firebaseio.com instead');\n  } // Catch common error of uninitialized namespace value.\n\n\n  if (!namespace || namespace == 'undefined') {\n    util_1.fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');\n  }\n\n  if (!parsedUrl.secure) {\n    util_1.warnIfPageIsSecure();\n  }\n\n  var webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\n  return {\n    repoInfo: new RepoInfo_1.RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly),\n    path: new Path_1.Path(parsedUrl.pathString)\n  };\n};\n/**\n *\n * @param {!string} dataURL\n * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}\n */\n\n\nexports.parseURL = function (dataURL) {\n  // Default to empty strings in the event of a malformed string.\n  var host = '',\n      domain = '',\n      subdomain = '',\n      pathString = ''; // Always default to SSL, unless otherwise specified.\n\n  var secure = true,\n      scheme = 'https',\n      port = 443; // Don't do any validation here. The caller is responsible for validating the result of parsing.\n\n  if (typeof dataURL === 'string') {\n    // Parse scheme.\n    var colonInd = dataURL.indexOf('//');\n\n    if (colonInd >= 0) {\n      scheme = dataURL.substring(0, colonInd - 1);\n      dataURL = dataURL.substring(colonInd + 2);\n    } // Parse host and path.\n\n\n    var slashInd = dataURL.indexOf('/');\n\n    if (slashInd === -1) {\n      slashInd = dataURL.length;\n    }\n\n    host = dataURL.substring(0, slashInd);\n    pathString = decodePath(dataURL.substring(slashInd));\n    var parts = host.split('.');\n\n    if (parts.length === 3) {\n      // Normalize namespaces to lowercase to share storage / connection.\n      domain = parts[1];\n      subdomain = parts[0].toLowerCase();\n    } else if (parts.length === 2) {\n      domain = parts[0];\n    } // If we have a port, use scheme for determining if it's secure.\n\n\n    colonInd = host.indexOf(':');\n\n    if (colonInd >= 0) {\n      secure = scheme === 'https' || scheme === 'wss';\n      port = parseInt(host.substring(colonInd + 1), 10);\n    }\n  }\n\n  return {\n    host: host,\n    port: port,\n    domain: domain,\n    subdomain: subdomain,\n    secure: secure,\n    scheme: scheme,\n    pathString: pathString\n  };\n};","map":{"version":3,"mappings":"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","names":["pathString","pathStringDecoded","pieces","split","i","length","piece","decodeURIComponent","replace","e","exports","dataURL","parsedUrl","namespace","subdomain","domain","util_1","host","secure","webSocketOnly","scheme","repoInfo","RepoInfo_1","path","Path_1","port","colonInd","indexOf","substring","slashInd","decodePath","parts","toLowerCase","parseInt"],"sources":["../src/core/util/libs/parser.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from '../Path';\nimport { RepoInfo } from '../../RepoInfo';\nimport { warnIfPageIsSecure, fatal } from '../util';\n\n/**\n * @param {!string} pathString\n * @return {string}\n */\nfunction decodePath(pathString: string): string {\n  let pathStringDecoded = '';\n  const pieces = pathString.split('/');\n  for (let i = 0; i < pieces.length; i++) {\n    if (pieces[i].length > 0) {\n      let piece = pieces[i];\n      try {\n        piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\n      } catch (e) {}\n      pathStringDecoded += '/' + piece;\n    }\n  }\n  return pathStringDecoded;\n}\n\n/**\n *\n * @param {!string} dataURL\n * @return {{repoInfo: !RepoInfo, path: !Path}}\n */\nexport const parseRepoInfo = function(\n  dataURL: string\n): { repoInfo: RepoInfo; path: Path } {\n  const parsedUrl = parseURL(dataURL),\n    namespace = parsedUrl.subdomain;\n\n  if (parsedUrl.domain === 'firebase') {\n    fatal(\n      parsedUrl.host +\n        ' is no longer supported. ' +\n        'Please use <YOUR FIREBASE>.firebaseio.com instead'\n    );\n  }\n\n  // Catch common error of uninitialized namespace value.\n  if (!namespace || namespace == 'undefined') {\n    fatal(\n      'Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com'\n    );\n  }\n\n  if (!parsedUrl.secure) {\n    warnIfPageIsSecure();\n  }\n\n  const webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\n\n  return {\n    repoInfo: new RepoInfo(\n      parsedUrl.host,\n      parsedUrl.secure,\n      namespace,\n      webSocketOnly\n    ),\n    path: new Path(parsedUrl.pathString)\n  };\n};\n\n/**\n *\n * @param {!string} dataURL\n * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}\n */\nexport const parseURL = function(\n  dataURL: string\n): {\n  host: string;\n  port: number;\n  domain: string;\n  subdomain: string;\n  secure: boolean;\n  scheme: string;\n  pathString: string;\n} {\n  // Default to empty strings in the event of a malformed string.\n  let host = '',\n    domain = '',\n    subdomain = '',\n    pathString = '';\n\n  // Always default to SSL, unless otherwise specified.\n  let secure = true,\n    scheme = 'https',\n    port = 443;\n\n  // Don't do any validation here. The caller is responsible for validating the result of parsing.\n  if (typeof dataURL === 'string') {\n    // Parse scheme.\n    let colonInd = dataURL.indexOf('//');\n    if (colonInd >= 0) {\n      scheme = dataURL.substring(0, colonInd - 1);\n      dataURL = dataURL.substring(colonInd + 2);\n    }\n\n    // Parse host and path.\n    let slashInd = dataURL.indexOf('/');\n    if (slashInd === -1) {\n      slashInd = dataURL.length;\n    }\n    host = dataURL.substring(0, slashInd);\n    pathString = decodePath(dataURL.substring(slashInd));\n\n    const parts = host.split('.');\n    if (parts.length === 3) {\n      // Normalize namespaces to lowercase to share storage / connection.\n      domain = parts[1];\n      subdomain = parts[0].toLowerCase();\n    } else if (parts.length === 2) {\n      domain = parts[0];\n    }\n\n    // If we have a port, use scheme for determining if it's secure.\n    colonInd = host.indexOf(':');\n    if (colonInd >= 0) {\n      secure = scheme === 'https' || scheme === 'wss';\n      port = parseInt(host.substring(colonInd + 1), 10);\n    }\n  }\n\n  return {\n    host,\n    port,\n    domain,\n    subdomain,\n    secure,\n    scheme,\n    pathString\n  };\n};\n"]},"metadata":{},"sourceType":"script"}