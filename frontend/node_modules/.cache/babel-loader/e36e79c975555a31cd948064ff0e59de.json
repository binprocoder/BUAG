{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"./util\");\n\nvar util_2 = require(\"@firebase/util\");\n/**\r\n * An immutable object representing a parsed path.  It's immutable so that you\r\n * can pass them around to other functions without worrying about them changing\r\n * it.\r\n */\n\n\nvar Path =\n/** @class */\nfunction () {\n  /**\r\n   * @param {string|Array.<string>} pathOrString Path string to parse,\r\n   *      or another path, or the raw tokens array\r\n   * @param {number=} pieceNum\r\n   */\n  function Path(pathOrString, pieceNum) {\n    if (pieceNum === void 0) {\n      this.pieces_ = pathOrString.split('/'); // Remove empty pieces.\n\n      var copyTo = 0;\n\n      for (var i = 0; i < this.pieces_.length; i++) {\n        if (this.pieces_[i].length > 0) {\n          this.pieces_[copyTo] = this.pieces_[i];\n          copyTo++;\n        }\n      }\n\n      this.pieces_.length = copyTo;\n      this.pieceNum_ = 0;\n    } else {\n      this.pieces_ = pathOrString;\n      this.pieceNum_ = pieceNum;\n    }\n  }\n\n  Object.defineProperty(Path, \"Empty\", {\n    /**\r\n     * Singleton to represent an empty path\r\n     *\r\n     * @const\r\n     */\n    get: function () {\n      return new Path('');\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Path.prototype.getFront = function () {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n    return this.pieces_[this.pieceNum_];\n  };\n  /**\r\n   * @return {number} The number of segments in this path\r\n   */\n\n\n  Path.prototype.getLength = function () {\n    return this.pieces_.length - this.pieceNum_;\n  };\n  /**\r\n   * @return {!Path}\r\n   */\n\n\n  Path.prototype.popFront = function () {\n    var pieceNum = this.pieceNum_;\n\n    if (pieceNum < this.pieces_.length) {\n      pieceNum++;\n    }\n\n    return new Path(this.pieces_, pieceNum);\n  };\n  /**\r\n   * @return {?string}\r\n   */\n\n\n  Path.prototype.getBack = function () {\n    if (this.pieceNum_ < this.pieces_.length) return this.pieces_[this.pieces_.length - 1];\n    return null;\n  };\n\n  Path.prototype.toString = function () {\n    var pathString = '';\n\n    for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + this.pieces_[i];\n    }\n\n    return pathString || '/';\n  };\n\n  Path.prototype.toUrlEncodedString = function () {\n    var pathString = '';\n\n    for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + encodeURIComponent(String(this.pieces_[i]));\n    }\n\n    return pathString || '/';\n  };\n  /**\r\n   * Shallow copy of the parts of the path.\r\n   *\r\n   * @param {number=} begin\r\n   * @return {!Array<string>}\r\n   */\n\n\n  Path.prototype.slice = function (begin) {\n    if (begin === void 0) {\n      begin = 0;\n    }\n\n    return this.pieces_.slice(this.pieceNum_ + begin);\n  };\n  /**\r\n   * @return {?Path}\r\n   */\n\n\n  Path.prototype.parent = function () {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n    var pieces = [];\n\n    for (var i = this.pieceNum_; i < this.pieces_.length - 1; i++) pieces.push(this.pieces_[i]);\n\n    return new Path(pieces, 0);\n  };\n  /**\r\n   * @param {string|!Path} childPathObj\r\n   * @return {!Path}\r\n   */\n\n\n  Path.prototype.child = function (childPathObj) {\n    var pieces = [];\n\n    for (var i = this.pieceNum_; i < this.pieces_.length; i++) pieces.push(this.pieces_[i]);\n\n    if (childPathObj instanceof Path) {\n      for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {\n        pieces.push(childPathObj.pieces_[i]);\n      }\n    } else {\n      var childPieces = childPathObj.split('/');\n\n      for (var i = 0; i < childPieces.length; i++) {\n        if (childPieces[i].length > 0) pieces.push(childPieces[i]);\n      }\n    }\n\n    return new Path(pieces, 0);\n  };\n  /**\r\n   * @return {boolean} True if there are no segments in this path\r\n   */\n\n\n  Path.prototype.isEmpty = function () {\n    return this.pieceNum_ >= this.pieces_.length;\n  };\n  /**\r\n   * @param {!Path} outerPath\r\n   * @param {!Path} innerPath\r\n   * @return {!Path} The path from outerPath to innerPath\r\n   */\n\n\n  Path.relativePath = function (outerPath, innerPath) {\n    var outer = outerPath.getFront(),\n        inner = innerPath.getFront();\n\n    if (outer === null) {\n      return innerPath;\n    } else if (outer === inner) {\n      return Path.relativePath(outerPath.popFront(), innerPath.popFront());\n    } else {\n      throw new Error('INTERNAL ERROR: innerPath (' + innerPath + ') is not within ' + 'outerPath (' + outerPath + ')');\n    }\n  };\n  /**\r\n   * @param {!Path} left\r\n   * @param {!Path} right\r\n   * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.\r\n   */\n\n\n  Path.comparePaths = function (left, right) {\n    var leftKeys = left.slice();\n    var rightKeys = right.slice();\n\n    for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n      var cmp = util_1.nameCompare(leftKeys[i], rightKeys[i]);\n      if (cmp !== 0) return cmp;\n    }\n\n    if (leftKeys.length === rightKeys.length) return 0;\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n  };\n  /**\r\n   *\r\n   * @param {Path} other\r\n   * @return {boolean} true if paths are the same.\r\n   */\n\n\n  Path.prototype.equals = function (other) {\n    if (this.getLength() !== other.getLength()) {\n      return false;\n    }\n\n    for (var i = this.pieceNum_, j = other.pieceNum_; i <= this.pieces_.length; i++, j++) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   *\r\n   * @param {!Path} other\r\n   * @return {boolean} True if this path is a parent (or the same as) other\r\n   */\n\n\n  Path.prototype.contains = function (other) {\n    var i = this.pieceNum_;\n    var j = other.pieceNum_;\n\n    if (this.getLength() > other.getLength()) {\n      return false;\n    }\n\n    while (i < this.pieces_.length) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n\n      ++i;\n      ++j;\n    }\n\n    return true;\n  };\n\n  return Path;\n}(); // end Path\n\n\nexports.Path = Path;\n/**\r\n * Dynamic (mutable) path used to count path lengths.\r\n *\r\n * This class is used to efficiently check paths for valid\r\n * length (in UTF8 bytes) and depth (used in path validation).\r\n *\r\n * Throws Error exception if path is ever invalid.\r\n *\r\n * The definition of a path always begins with '/'.\r\n */\n\nvar ValidationPath =\n/** @class */\nfunction () {\n  /**\r\n   * @param {!Path} path Initial Path.\r\n   * @param {string} errorPrefix_ Prefix for any error messages.\r\n   */\n  function ValidationPath(path, errorPrefix_) {\n    this.errorPrefix_ = errorPrefix_;\n    /** @type {!Array<string>} */\n\n    this.parts_ = path.slice();\n    /** @type {number} Initialize to number of '/' chars needed in path. */\n\n    this.byteLength_ = Math.max(1, this.parts_.length);\n\n    for (var i = 0; i < this.parts_.length; i++) {\n      this.byteLength_ += util_2.stringLength(this.parts_[i]);\n    }\n\n    this.checkValid_();\n  }\n\n  Object.defineProperty(ValidationPath, \"MAX_PATH_DEPTH\", {\n    /** @const {number} Maximum key depth. */\n    get: function () {\n      return 32;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValidationPath, \"MAX_PATH_LENGTH_BYTES\", {\n    /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */\n    get: function () {\n      return 768;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @param {string} child */\n\n  ValidationPath.prototype.push = function (child) {\n    // Count the needed '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ += 1;\n    }\n\n    this.parts_.push(child);\n    this.byteLength_ += util_2.stringLength(child);\n    this.checkValid_();\n  };\n\n  ValidationPath.prototype.pop = function () {\n    var last = this.parts_.pop();\n    this.byteLength_ -= util_2.stringLength(last); // Un-count the previous '/'\n\n    if (this.parts_.length > 0) {\n      this.byteLength_ -= 1;\n    }\n  };\n\n  ValidationPath.prototype.checkValid_ = function () {\n    if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {\n      throw new Error(this.errorPrefix_ + 'has a key path longer than ' + ValidationPath.MAX_PATH_LENGTH_BYTES + ' bytes (' + this.byteLength_ + ').');\n    }\n\n    if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {\n      throw new Error(this.errorPrefix_ + 'path specified exceeds the maximum depth that can be written (' + ValidationPath.MAX_PATH_DEPTH + ') or object contains a cycle ' + this.toErrorString());\n    }\n  };\n  /**\r\n   * String for use in error messages - uses '.' notation for path.\r\n   *\r\n   * @return {string}\r\n   */\n\n\n  ValidationPath.prototype.toErrorString = function () {\n    if (this.parts_.length == 0) {\n      return '';\n    }\n\n    return \"in property '\" + this.parts_.join('.') + \"'\";\n  };\n\n  return ValidationPath;\n}();\n\nexports.ValidationPath = ValidationPath;","map":{"version":3,"mappings":"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","names":["pathOrString","pieceNum","pieces_","split","copyTo","i","length","pieceNum_","Object","Path","pathString","encodeURIComponent","String","begin","slice","pieces","push","childPathObj","childPieces","outerPath","innerPath","outer","getFront","inner","relativePath","popFront","Error","left","right","leftKeys","rightKeys","cmp","util_1","other","getLength","j","exports","path","errorPrefix_","parts_","byteLength_","Math","max","util_2","checkValid_","ValidationPath","child","last","pop","MAX_PATH_LENGTH_BYTES","MAX_PATH_DEPTH","toErrorString","join"],"sources":["../src/core/util/Path.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { nameCompare } from './util';\nimport { stringLength } from '@firebase/util';\n/**\n * An immutable object representing a parsed path.  It's immutable so that you\n * can pass them around to other functions without worrying about them changing\n * it.\n */\n\nexport class Path {\n  private pieces_: string[];\n  private pieceNum_: number;\n\n  /**\n   * Singleton to represent an empty path\n   *\n   * @const\n   */\n  static get Empty() {\n    return new Path('');\n  }\n\n  /**\n   * @param {string|Array.<string>} pathOrString Path string to parse,\n   *      or another path, or the raw tokens array\n   * @param {number=} pieceNum\n   */\n  constructor(pathOrString: string | string[], pieceNum?: number) {\n    if (pieceNum === void 0) {\n      this.pieces_ = (pathOrString as string).split('/');\n\n      // Remove empty pieces.\n      let copyTo = 0;\n      for (let i = 0; i < this.pieces_.length; i++) {\n        if (this.pieces_[i].length > 0) {\n          this.pieces_[copyTo] = this.pieces_[i];\n          copyTo++;\n        }\n      }\n      this.pieces_.length = copyTo;\n\n      this.pieceNum_ = 0;\n    } else {\n      this.pieces_ = pathOrString as string[];\n      this.pieceNum_ = pieceNum;\n    }\n  }\n\n  getFront(): string | null {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n\n    return this.pieces_[this.pieceNum_];\n  }\n\n  /**\n   * @return {number} The number of segments in this path\n   */\n  getLength(): number {\n    return this.pieces_.length - this.pieceNum_;\n  }\n\n  /**\n   * @return {!Path}\n   */\n  popFront(): Path {\n    let pieceNum = this.pieceNum_;\n    if (pieceNum < this.pieces_.length) {\n      pieceNum++;\n    }\n    return new Path(this.pieces_, pieceNum);\n  }\n\n  /**\n   * @return {?string}\n   */\n  getBack(): string | null {\n    if (this.pieceNum_ < this.pieces_.length)\n      return this.pieces_[this.pieces_.length - 1];\n\n    return null;\n  }\n\n  toString(): string {\n    let pathString = '';\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + this.pieces_[i];\n    }\n\n    return pathString || '/';\n  }\n\n  toUrlEncodedString(): string {\n    let pathString = '';\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '')\n        pathString += '/' + encodeURIComponent(String(this.pieces_[i]));\n    }\n\n    return pathString || '/';\n  }\n\n  /**\n   * Shallow copy of the parts of the path.\n   *\n   * @param {number=} begin\n   * @return {!Array<string>}\n   */\n  slice(begin: number = 0): string[] {\n    return this.pieces_.slice(this.pieceNum_ + begin);\n  }\n\n  /**\n   * @return {?Path}\n   */\n  parent(): Path | null {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n\n    const pieces = [];\n    for (let i = this.pieceNum_; i < this.pieces_.length - 1; i++)\n      pieces.push(this.pieces_[i]);\n\n    return new Path(pieces, 0);\n  }\n\n  /**\n   * @param {string|!Path} childPathObj\n   * @return {!Path}\n   */\n  child(childPathObj: string | Path): Path {\n    const pieces = [];\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++)\n      pieces.push(this.pieces_[i]);\n\n    if (childPathObj instanceof Path) {\n      for (\n        let i = childPathObj.pieceNum_;\n        i < childPathObj.pieces_.length;\n        i++\n      ) {\n        pieces.push(childPathObj.pieces_[i]);\n      }\n    } else {\n      const childPieces = childPathObj.split('/');\n      for (let i = 0; i < childPieces.length; i++) {\n        if (childPieces[i].length > 0) pieces.push(childPieces[i]);\n      }\n    }\n\n    return new Path(pieces, 0);\n  }\n\n  /**\n   * @return {boolean} True if there are no segments in this path\n   */\n  isEmpty(): boolean {\n    return this.pieceNum_ >= this.pieces_.length;\n  }\n\n  /**\n   * @param {!Path} outerPath\n   * @param {!Path} innerPath\n   * @return {!Path} The path from outerPath to innerPath\n   */\n  static relativePath(outerPath: Path, innerPath: Path): Path {\n    const outer = outerPath.getFront(),\n      inner = innerPath.getFront();\n    if (outer === null) {\n      return innerPath;\n    } else if (outer === inner) {\n      return Path.relativePath(outerPath.popFront(), innerPath.popFront());\n    } else {\n      throw new Error(\n        'INTERNAL ERROR: innerPath (' +\n          innerPath +\n          ') is not within ' +\n          'outerPath (' +\n          outerPath +\n          ')'\n      );\n    }\n  }\n\n  /**\n   * @param {!Path} left\n   * @param {!Path} right\n   * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.\n   */\n  static comparePaths(left: Path, right: Path): number {\n    const leftKeys = left.slice();\n    const rightKeys = right.slice();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n      const cmp = nameCompare(leftKeys[i], rightKeys[i]);\n      if (cmp !== 0) return cmp;\n    }\n    if (leftKeys.length === rightKeys.length) return 0;\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n  }\n\n  /**\n   *\n   * @param {Path} other\n   * @return {boolean} true if paths are the same.\n   */\n  equals(other: Path): boolean {\n    if (this.getLength() !== other.getLength()) {\n      return false;\n    }\n\n    for (\n      let i = this.pieceNum_, j = other.pieceNum_;\n      i <= this.pieces_.length;\n      i++, j++\n    ) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {!Path} other\n   * @return {boolean} True if this path is a parent (or the same as) other\n   */\n  contains(other: Path): boolean {\n    let i = this.pieceNum_;\n    let j = other.pieceNum_;\n    if (this.getLength() > other.getLength()) {\n      return false;\n    }\n    while (i < this.pieces_.length) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n      ++i;\n      ++j;\n    }\n    return true;\n  }\n} // end Path\n\n/**\n * Dynamic (mutable) path used to count path lengths.\n *\n * This class is used to efficiently check paths for valid\n * length (in UTF8 bytes) and depth (used in path validation).\n *\n * Throws Error exception if path is ever invalid.\n *\n * The definition of a path always begins with '/'.\n */\nexport class ValidationPath {\n  /** @type {!Array<string>} */\n  private parts_: string[];\n  /** @type {number} Initialize to number of '/' chars needed in path. */\n  private byteLength_: number;\n\n  /**\n   * @param {!Path} path Initial Path.\n   * @param {string} errorPrefix_ Prefix for any error messages.\n   */\n  constructor(path: Path, private errorPrefix_: string) {\n    /** @type {!Array<string>} */\n    this.parts_ = path.slice();\n    /** @type {number} Initialize to number of '/' chars needed in path. */\n    this.byteLength_ = Math.max(1, this.parts_.length);\n\n    for (let i = 0; i < this.parts_.length; i++) {\n      this.byteLength_ += stringLength(this.parts_[i]);\n    }\n    this.checkValid_();\n  }\n\n  /** @const {number} Maximum key depth. */\n  static get MAX_PATH_DEPTH() {\n    return 32;\n  }\n\n  /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */\n  static get MAX_PATH_LENGTH_BYTES() {\n    return 768;\n  }\n\n  /** @param {string} child */\n  push(child: string) {\n    // Count the needed '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ += 1;\n    }\n    this.parts_.push(child);\n    this.byteLength_ += stringLength(child);\n    this.checkValid_();\n  }\n\n  pop() {\n    const last = this.parts_.pop();\n    this.byteLength_ -= stringLength(last);\n    // Un-count the previous '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ -= 1;\n    }\n  }\n\n  private checkValid_() {\n    if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {\n      throw new Error(\n        this.errorPrefix_ +\n          'has a key path longer than ' +\n          ValidationPath.MAX_PATH_LENGTH_BYTES +\n          ' bytes (' +\n          this.byteLength_ +\n          ').'\n      );\n    }\n    if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {\n      throw new Error(\n        this.errorPrefix_ +\n          'path specified exceeds the maximum depth that can be written (' +\n          ValidationPath.MAX_PATH_DEPTH +\n          ') or object contains a cycle ' +\n          this.toErrorString()\n      );\n    }\n  }\n\n  /**\n   * String for use in error messages - uses '.' notation for path.\n   *\n   * @return {string}\n   */\n  toErrorString(): string {\n    if (this.parts_.length == 0) {\n      return '';\n    }\n    return \"in property '\" + this.parts_.join('.') + \"'\";\n  }\n}\n"]},"metadata":{},"sourceType":"script"}