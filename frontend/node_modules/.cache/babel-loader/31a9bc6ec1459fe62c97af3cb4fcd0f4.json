{"ast":null,"code":"'use strict';\n/**\n * This callback will be called to resolve a module if it couldn't be found.\n *\n * @callback resolveCallback\n * @param {string} moduleName - Name of the module used to resolve.\n * @param {string} dirname - Name of the current directory.\n * @return {(string|undefined)} The file or directory to use to load the requested module.\n */\n\n/**\n * This callback will be called to require a module instead of node's require.\n *\n * @callback customRequire\n * @param {string} moduleName - Name of the module requested.\n * @return {*} The required module object.\n */\n\nconst fs = require('fs');\n\nconst pa = require('path');\n\nconst {\n  Script\n} = require('vm');\n\nconst {\n  VMError\n} = require('./bridge');\n\nconst {\n  VMScript,\n  MODULE_PREFIX,\n  STRICT_MODULE_PREFIX,\n  MODULE_SUFFIX\n} = require('./script');\n\nconst {\n  transformer\n} = require('./transformer');\n\nconst {\n  VM\n} = require('./vm');\n\nconst {\n  resolverFromOptions\n} = require('./resolver-compat');\n\nconst objectDefineProperty = Object.defineProperty;\nconst objectDefineProperties = Object.defineProperties;\n/**\n * Host objects\n *\n * @private\n */\n\nconst HOST = Object.freeze({\n  __proto__: null,\n  version: parseInt(process.versions.node.split('.')[0]),\n  process,\n  console,\n  setTimeout,\n  setInterval,\n  setImmediate,\n  clearTimeout,\n  clearInterval,\n  clearImmediate\n});\n/**\n * Compile a script.\n *\n * @private\n * @param {string} filename - Filename of the script.\n * @param {string} script - Script.\n * @return {vm.Script} The compiled script.\n */\n\nfunction compileScript(filename, script) {\n  return new Script(script, {\n    __proto__: null,\n    filename,\n    displayErrors: false\n  });\n}\n\nlet cacheSandboxScript = null;\nlet cacheMakeNestingScript = null;\nconst NESTING_OVERRIDE = Object.freeze({\n  __proto__: null,\n  vm2: vm2NestingLoader\n});\n/**\n * Event caused by a <code>console.debug</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.debug\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.log</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.log\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.info</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.info\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.warn</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.warn\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.error</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.error\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.dir</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.dir\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.trace</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.trace\"\n * @type {...*}\n */\n\n/**\n * Class NodeVM.\n *\n * @public\n * @extends {VM}\n * @extends {EventEmitter}\n */\n\nclass NodeVM extends VM {\n  /**\n   * Create a new NodeVM instance.<br>\n   *\n   * Unlike VM, NodeVM lets you use require same way like in regular node.<br>\n   *\n   * However, it does not use the timeout.\n   *\n   * @public\n   * @param {Object} [options] - VM options.\n   * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.\n   * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n   * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>\n   * Only available for node v10+.\n   * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>\n   * Only available for node v10+.\n   * @param {(\"inherit\"|\"redirect\"|\"off\")} [options.console=\"inherit\"] - Sets the behavior of the console in the sandbox.\n   * <code>inherit</code> to enable console, <code>redirect</code> to redirect to events, <code>off</code> to disable console.\n   * @param {Object|boolean} [options.require=false] - Allow require inside the sandbox.\n   * @param {(boolean|string[]|Object)} [options.require.external=false] - <b>WARNING: When allowing require the option <code>options.require.root</code>\n   * should be set to restrict the script from requiring any module. Values can be true, an array of allowed external modules or an object.\n   * @param {(string[])} [options.require.external.modules] - Array of allowed external modules. Also supports wildcards, so specifying ['@scope/*-ver-??],\n   * for instance, will allow using all modules having a name of the form @scope/something-ver-aa, @scope/other-ver-11, etc.\n   * @param {boolean} [options.require.external.transitive=false] - Boolean which indicates if transitive dependencies of external modules are allowed.\n   * @param {string[]} [options.require.builtin=[]] - Array of allowed built-in modules, accepts [\"*\"] for all.\n   * @param {(string|string[])} [options.require.root] - Restricted path(s) where local modules can be required. If omitted every path is allowed.\n   * @param {Object} [options.require.mock] - Collection of mock modules (both external or built-in).\n   * @param {(\"host\"|\"sandbox\")} [options.require.context=\"host\"] - <code>host</code> to require modules in host and proxy them to sandbox.\n   * <code>sandbox</code> to load, compile and require modules in sandbox.\n   * Builtin modules except <code>events</code> always required in host and proxied to sandbox.\n   * @param {string[]} [options.require.import] - Array of modules to be loaded into NodeVM on start.\n   * @param {resolveCallback} [options.require.resolve] - An additional lookup function in case a module wasn't\n   * found in one of the traditional node lookup paths.\n   * @param {customRequire} [options.require.customRequire=require] - Custom require to require host and built-in modules.\n   * @param {boolean} [options.nesting=false] -\n   * <b>WARNING: Allowing this is a security risk as scripts can create a NodeVM which can require any host module.</b>\n   * Allow nesting of VMs.\n   * @param {(\"commonjs\"|\"none\")} [options.wrapper=\"commonjs\"] - <code>commonjs</code> to wrap script into CommonJS wrapper,\n   * <code>none</code> to retrieve value returned by the script.\n   * @param {string[]} [options.sourceExtensions=[\"js\"]] - Array of file extensions to treat as source code.\n   * @param {string[]} [options.argv=[]] - Array of arguments passed to <code>process.argv</code>.\n   * This object will not be copied and the script can change this object.\n   * @param {Object} [options.env={}] - Environment map passed to <code>process.env</code>.\n   * This object will not be copied and the script can change this object.\n   * @param {boolean} [options.strict=false] - If modules should be loaded in strict mode.\n   * @throws {VMError} If the compiler is unknown.\n   */\n  constructor(options = {}) {\n    const {\n      compiler,\n      eval: allowEval,\n      wasm,\n      console: consoleType = 'inherit',\n      require: requireOpts = false,\n      nesting = false,\n      wrapper = 'commonjs',\n      sourceExtensions = ['js'],\n      argv,\n      env,\n      strict = false,\n      sandbox\n    } = options; // Throw this early\n\n    if (sandbox && 'object' !== typeof sandbox) {\n      throw new VMError('Sandbox must be an object.');\n    }\n\n    super({\n      __proto__: null,\n      compiler: compiler,\n      eval: allowEval,\n      wasm\n    }); // This is only here for backwards compatibility.\n\n    objectDefineProperty(this, 'options', {\n      __proto__: null,\n      value: {\n        console: consoleType,\n        require: requireOpts,\n        nesting,\n        wrapper,\n        sourceExtensions,\n        strict\n      }\n    });\n    const resolver = resolverFromOptions(this, requireOpts, nesting && NESTING_OVERRIDE, this._compiler);\n    objectDefineProperty(this, '_resolver', {\n      __proto__: null,\n      value: resolver\n    });\n\n    if (!cacheSandboxScript) {\n      cacheSandboxScript = compileScript(`${__dirname}/setup-node-sandbox.js`, `(function (host, data) { ${fs.readFileSync(`${__dirname}/setup-node-sandbox.js`, 'utf8')}\\n})`);\n    }\n\n    const closure = this._runScript(cacheSandboxScript);\n\n    const extensions = {\n      __proto__: null\n    };\n\n    const loadJS = (mod, filename) => resolver.loadJS(this, mod, filename);\n\n    for (let i = 0; i < sourceExtensions.length; i++) {\n      extensions['.' + sourceExtensions[i]] = loadJS;\n    }\n\n    if (!extensions['.json']) extensions['.json'] = (mod, filename) => resolver.loadJSON(this, mod, filename);\n    if (!extensions['.node']) extensions['.node'] = (mod, filename) => resolver.loadNode(this, mod, filename);\n    this.readonly(HOST);\n    this.readonly(resolver);\n    this.readonly(this);\n    const {\n      Module,\n      jsonParse,\n      createRequireForModule,\n      requireImpl\n    } = closure(HOST, {\n      __proto__: null,\n      argv,\n      env,\n      console: consoleType,\n      vm: this,\n      resolver,\n      extensions\n    });\n    objectDefineProperties(this, {\n      __proto__: null,\n      _Module: {\n        __proto__: null,\n        value: Module\n      },\n      _jsonParse: {\n        __proto__: null,\n        value: jsonParse\n      },\n      _createRequireForModule: {\n        __proto__: null,\n        value: createRequireForModule\n      },\n      _requireImpl: {\n        __proto__: null,\n        value: requireImpl\n      },\n      _cacheRequireModule: {\n        __proto__: null,\n        value: null,\n        writable: true\n      }\n    });\n    resolver.init(this); // prepare global sandbox\n\n    if (sandbox) {\n      this.setGlobals(sandbox);\n    }\n\n    if (requireOpts && requireOpts.import) {\n      if (Array.isArray(requireOpts.import)) {\n        for (let i = 0, l = requireOpts.import.length; i < l; i++) {\n          this.require(requireOpts.import[i]);\n        }\n      } else {\n        this.require(requireOpts.import);\n      }\n    }\n  }\n  /**\n   * @ignore\n   * @deprecated Just call the method yourself like <code>method(args);</code>\n   * @param {function} method - Function to invoke.\n   * @param {...*} args - Arguments to pass to the function.\n   * @return {*} Return value of the function.\n   * @todo Can we remove this function? It even had a bug that would use args as this parameter.\n   * @throws {*} Rethrows anything the method throws.\n   * @throws {VMError} If method is not a function.\n   * @throws {Error} If method is a class.\n   */\n\n\n  call(method, ...args) {\n    if ('function' === typeof method) {\n      return method(...args);\n    } else {\n      throw new VMError('Unrecognized method type.');\n    }\n  }\n  /**\n   * Require a module in VM and return it's exports.\n   *\n   * @public\n   * @param {string} module - Module name.\n   * @return {*} Exported module.\n   * @throws {*} If the module couldn't be found or loading it threw an error.\n   */\n\n\n  require(module) {\n    const path = this._resolver.pathResolve('.');\n\n    let mod = this._cacheRequireModule;\n\n    if (!mod || mod.path !== path) {\n      const filename = this._resolver.pathConcat(path, '/vm.js');\n\n      mod = new this._Module(filename, path);\n\n      this._resolver.registerModule(mod, filename, path, null, false);\n\n      this._cacheRequireModule = mod;\n    }\n\n    return this._requireImpl(mod, module, true);\n  }\n  /**\n   * Run the code in NodeVM.\n   *\n   * First time you run this method, code is executed same way like in node's regular `require` - it's executed with\n   * `module`, `require`, `exports`, `__dirname`, `__filename` variables and expect result in `module.exports'.\n   *\n   * @param {(string|VMScript)} code - Code to run.\n   * @param {(string|Object)} [options] - Options map or filename.\n   * @param {string} [options.filename=\"vm.js\"] - Filename that shows up in any stack traces produced from this script.<br>\n   * This is only used if code is a String.\n   * @param {boolean} [options.strict] - If modules should be loaded in strict mode. Defaults to NodeVM options.\n   * @param {(\"commonjs\"|\"none\")} [options.wrapper] - <code>commonjs</code> to wrap script into CommonJS wrapper,\n   * <code>none</code> to retrieve value returned by the script. Defaults to NodeVM options.\n   * @return {*} Result of executed code.\n   * @throws {SyntaxError} If there is a syntax error in the script.\n   * @throws {*} If the script execution terminated with an exception it is propagated.\n   * @fires NodeVM.\"console.debug\"\n   * @fires NodeVM.\"console.log\"\n   * @fires NodeVM.\"console.info\"\n   * @fires NodeVM.\"console.warn\"\n   * @fires NodeVM.\"console.error\"\n   * @fires NodeVM.\"console.dir\"\n   * @fires NodeVM.\"console.trace\"\n   */\n\n\n  run(code, options) {\n    let script;\n    let filename;\n\n    if (typeof options === 'object') {\n      filename = options.filename;\n    } else {\n      filename = options;\n      options = {\n        __proto__: null\n      };\n    }\n\n    const {\n      strict = this.options.strict,\n      wrapper = this.options.wrapper,\n      module: customModule,\n      require: customRequire,\n      dirname: customDirname = null\n    } = options;\n    let sandboxModule = customModule;\n    let dirname = customDirname;\n\n    if (code instanceof VMScript) {\n      script = strict ? code._compileNodeVMStrict() : code._compileNodeVM();\n\n      if (!sandboxModule) {\n        const resolvedFilename = this._resolver.pathResolve(code.filename);\n\n        dirname = this._resolver.pathDirname(resolvedFilename);\n        sandboxModule = new this._Module(resolvedFilename, dirname);\n\n        this._resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);\n      }\n    } else {\n      const unresolvedFilename = filename || 'vm.js';\n\n      if (!sandboxModule) {\n        if (filename) {\n          const resolvedFilename = this._resolver.pathResolve(filename);\n\n          dirname = this._resolver.pathDirname(resolvedFilename);\n          sandboxModule = new this._Module(resolvedFilename, dirname);\n\n          this._resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);\n        } else {\n          sandboxModule = new this._Module(null, null);\n          sandboxModule.id = unresolvedFilename;\n        }\n      }\n\n      const prefix = strict ? STRICT_MODULE_PREFIX : MODULE_PREFIX;\n\n      let scriptCode = this._compiler(code, unresolvedFilename);\n\n      scriptCode = transformer(null, scriptCode, false, false, unresolvedFilename).code;\n      script = new Script(prefix + scriptCode + MODULE_SUFFIX, {\n        __proto__: null,\n        filename: unresolvedFilename,\n        displayErrors: false\n      });\n    }\n\n    const closure = this._runScript(script);\n\n    const usedRequire = customRequire || this._createRequireForModule(sandboxModule);\n\n    const ret = Reflect.apply(closure, this.sandbox, [sandboxModule.exports, usedRequire, sandboxModule, filename, dirname]);\n    return wrapper === 'commonjs' ? sandboxModule.exports : ret;\n  }\n  /**\n   * Create NodeVM and run code inside it.\n   *\n   * @public\n   * @static\n   * @param {string} script - Code to execute.\n   * @param {string} [filename] - File name (used in stack traces only).\n   * @param {Object} [options] - VM options.\n   * @param {string} [options.filename] - File name (used in stack traces only). Used if <code>filename</code> is omitted.\n   * @return {*} Result of executed code.\n   * @see {@link NodeVM} for the options.\n   * @throws {SyntaxError} If there is a syntax error in the script.\n   * @throws {*} If the script execution terminated with an exception it is propagated.\n   */\n\n\n  static code(script, filename, options) {\n    let unresolvedFilename;\n\n    if (filename != null) {\n      if ('object' === typeof filename) {\n        options = filename;\n        unresolvedFilename = options.filename;\n      } else if ('string' === typeof filename) {\n        unresolvedFilename = filename;\n      } else {\n        throw new VMError('Invalid arguments.');\n      }\n    } else if ('object' === typeof options) {\n      unresolvedFilename = options.filename;\n    }\n\n    if (arguments.length > 3) {\n      throw new VMError('Invalid number of arguments.');\n    }\n\n    const resolvedFilename = typeof unresolvedFilename === 'string' ? pa.resolve(unresolvedFilename) : undefined;\n    return new NodeVM(options).run(script, resolvedFilename);\n  }\n  /**\n   * Create NodeVM and run script from file inside it.\n   *\n   * @public\n   * @static\n   * @param {string} filename - Filename of file to load and execute in a NodeVM.\n   * @param {Object} [options] - NodeVM options.\n   * @return {*} Result of executed code.\n   * @see {@link NodeVM} for the options.\n   * @throws {Error} If filename is not a valid filename.\n   * @throws {SyntaxError} If there is a syntax error in the script.\n   * @throws {*} If the script execution terminated with an exception it is propagated.\n   */\n\n\n  static file(filename, options) {\n    const resolvedFilename = pa.resolve(filename);\n\n    if (!fs.existsSync(resolvedFilename)) {\n      throw new VMError(`Script '${filename}' not found.`);\n    }\n\n    if (fs.statSync(resolvedFilename).isDirectory()) {\n      throw new VMError('Script must be file, got directory.');\n    }\n\n    return new NodeVM(options).run(fs.readFileSync(resolvedFilename, 'utf8'), resolvedFilename);\n  }\n\n}\n\nfunction vm2NestingLoader(resolver, vm, id) {\n  if (!cacheMakeNestingScript) {\n    cacheMakeNestingScript = compileScript('nesting.js', '(vm, nodevm) => ({VM: vm, NodeVM: nodevm})');\n  }\n\n  const makeNesting = vm._runScript(cacheMakeNestingScript);\n\n  return makeNesting(vm.readonly(VM), vm.readonly(NodeVM));\n}\n\nexports.NodeVM = NodeVM;","map":{"version":3,"sources":["C:/Users/Bin Tran/Desktop/BUAG/BUAG/frontend/node_modules/vm2/lib/nodevm.js"],"names":["fs","require","pa","Script","VMError","VMScript","MODULE_PREFIX","STRICT_MODULE_PREFIX","MODULE_SUFFIX","transformer","VM","resolverFromOptions","objectDefineProperty","Object","defineProperty","objectDefineProperties","defineProperties","HOST","freeze","__proto__","version","parseInt","process","versions","node","split","console","setTimeout","setInterval","setImmediate","clearTimeout","clearInterval","clearImmediate","compileScript","filename","script","displayErrors","cacheSandboxScript","cacheMakeNestingScript","NESTING_OVERRIDE","vm2","vm2NestingLoader","NodeVM","constructor","options","compiler","eval","allowEval","wasm","consoleType","requireOpts","nesting","wrapper","sourceExtensions","argv","env","strict","sandbox","value","resolver","_compiler","__dirname","readFileSync","closure","_runScript","extensions","loadJS","mod","i","length","loadJSON","loadNode","readonly","Module","jsonParse","createRequireForModule","requireImpl","vm","_Module","_jsonParse","_createRequireForModule","_requireImpl","_cacheRequireModule","writable","init","setGlobals","import","Array","isArray","l","call","method","args","module","path","_resolver","pathResolve","pathConcat","registerModule","run","code","customModule","customRequire","dirname","customDirname","sandboxModule","_compileNodeVMStrict","_compileNodeVM","resolvedFilename","pathDirname","unresolvedFilename","id","prefix","scriptCode","usedRequire","ret","Reflect","apply","exports","arguments","resolve","undefined","file","existsSync","statSync","isDirectory","makeNesting"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,MAAM;AACLE,EAAAA;AADK,IAEFF,OAAO,CAAC,IAAD,CAFX;;AAGA,MAAM;AACLG,EAAAA;AADK,IAEFH,OAAO,CAAC,UAAD,CAFX;;AAGA,MAAM;AACLI,EAAAA,QADK;AAELC,EAAAA,aAFK;AAGLC,EAAAA,oBAHK;AAILC,EAAAA;AAJK,IAKFP,OAAO,CAAC,UAAD,CALX;;AAMA,MAAM;AACLQ,EAAAA;AADK,IAEFR,OAAO,CAAC,eAAD,CAFX;;AAGA,MAAM;AACLS,EAAAA;AADK,IAEFT,OAAO,CAAC,MAAD,CAFX;;AAGA,MAAM;AACLU,EAAAA;AADK,IAEFV,OAAO,CAAC,mBAAD,CAFX;;AAIA,MAAMW,oBAAoB,GAAGC,MAAM,CAACC,cAApC;AACA,MAAMC,sBAAsB,GAAGF,MAAM,CAACG,gBAAtC;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,IAAI,GAAGJ,MAAM,CAACK,MAAP,CAAc;AAC1BC,EAAAA,SAAS,EAAE,IADe;AAE1BC,EAAAA,OAAO,EAAEC,QAAQ,CAACC,OAAO,CAACC,QAAR,CAAiBC,IAAjB,CAAsBC,KAAtB,CAA4B,GAA5B,EAAiC,CAAjC,CAAD,CAFS;AAG1BH,EAAAA,OAH0B;AAI1BI,EAAAA,OAJ0B;AAK1BC,EAAAA,UAL0B;AAM1BC,EAAAA,WAN0B;AAO1BC,EAAAA,YAP0B;AAQ1BC,EAAAA,YAR0B;AAS1BC,EAAAA,aAT0B;AAU1BC,EAAAA;AAV0B,CAAd,CAAb;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,aAAT,CAAuBC,QAAvB,EAAiCC,MAAjC,EAAyC;AACxC,SAAO,IAAIhC,MAAJ,CAAWgC,MAAX,EAAmB;AACzBhB,IAAAA,SAAS,EAAE,IADc;AAEzBe,IAAAA,QAFyB;AAGzBE,IAAAA,aAAa,EAAE;AAHU,GAAnB,CAAP;AAKA;;AAED,IAAIC,kBAAkB,GAAG,IAAzB;AACA,IAAIC,sBAAsB,GAAG,IAA7B;AAEA,MAAMC,gBAAgB,GAAG1B,MAAM,CAACK,MAAP,CAAc;AACtCC,EAAAA,SAAS,EAAE,IAD2B;AAEtCqB,EAAAA,GAAG,EAAEC;AAFiC,CAAd,CAAzB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,MAAN,SAAqBhC,EAArB,CAAwB;AAEvB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCiC,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AACzB,UAAM;AACLC,MAAAA,QADK;AAELC,MAAAA,IAAI,EAAEC,SAFD;AAGLC,MAAAA,IAHK;AAILtB,MAAAA,OAAO,EAAEuB,WAAW,GAAG,SAJlB;AAKLhD,MAAAA,OAAO,EAAEiD,WAAW,GAAG,KALlB;AAMLC,MAAAA,OAAO,GAAG,KANL;AAOLC,MAAAA,OAAO,GAAG,UAPL;AAQLC,MAAAA,gBAAgB,GAAG,CAAC,IAAD,CARd;AASLC,MAAAA,IATK;AAULC,MAAAA,GAVK;AAWLC,MAAAA,MAAM,GAAG,KAXJ;AAYLC,MAAAA;AAZK,QAaFb,OAbJ,CADyB,CAgBzB;;AACA,QAAIa,OAAO,IAAI,aAAa,OAAOA,OAAnC,EAA4C;AAC3C,YA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","sourcesContent":["'use strict';\n\n/**\n * This callback will be called to resolve a module if it couldn't be found.\n *\n * @callback resolveCallback\n * @param {string} moduleName - Name of the module used to resolve.\n * @param {string} dirname - Name of the current directory.\n * @return {(string|undefined)} The file or directory to use to load the requested module.\n */\n\n/**\n * This callback will be called to require a module instead of node's require.\n *\n * @callback customRequire\n * @param {string} moduleName - Name of the module requested.\n * @return {*} The required module object.\n */\n\nconst fs = require('fs');\nconst pa = require('path');\nconst {\n\tScript\n} = require('vm');\nconst {\n\tVMError\n} = require('./bridge');\nconst {\n\tVMScript,\n\tMODULE_PREFIX,\n\tSTRICT_MODULE_PREFIX,\n\tMODULE_SUFFIX\n} = require('./script');\nconst {\n\ttransformer\n} = require('./transformer');\nconst {\n\tVM\n} = require('./vm');\nconst {\n\tresolverFromOptions\n} = require('./resolver-compat');\n\nconst objectDefineProperty = Object.defineProperty;\nconst objectDefineProperties = Object.defineProperties;\n\n/**\n * Host objects\n *\n * @private\n */\nconst HOST = Object.freeze({\n\t__proto__: null,\n\tversion: parseInt(process.versions.node.split('.')[0]),\n\tprocess,\n\tconsole,\n\tsetTimeout,\n\tsetInterval,\n\tsetImmediate,\n\tclearTimeout,\n\tclearInterval,\n\tclearImmediate\n});\n\n/**\n * Compile a script.\n *\n * @private\n * @param {string} filename - Filename of the script.\n * @param {string} script - Script.\n * @return {vm.Script} The compiled script.\n */\nfunction compileScript(filename, script) {\n\treturn new Script(script, {\n\t\t__proto__: null,\n\t\tfilename,\n\t\tdisplayErrors: false\n\t});\n}\n\nlet cacheSandboxScript = null;\nlet cacheMakeNestingScript = null;\n\nconst NESTING_OVERRIDE = Object.freeze({\n\t__proto__: null,\n\tvm2: vm2NestingLoader\n});\n\n/**\n * Event caused by a <code>console.debug</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.debug\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.log</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.log\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.info</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.info\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.warn</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.warn\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.error</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.error\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.dir</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.dir\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.trace</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.trace\"\n * @type {...*}\n */\n\n/**\n * Class NodeVM.\n *\n * @public\n * @extends {VM}\n * @extends {EventEmitter}\n */\nclass NodeVM extends VM {\n\n\t/**\n\t * Create a new NodeVM instance.<br>\n\t *\n\t * Unlike VM, NodeVM lets you use require same way like in regular node.<br>\n\t *\n\t * However, it does not use the timeout.\n\t *\n\t * @public\n\t * @param {Object} [options] - VM options.\n\t * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.\n\t * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n\t * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>\n\t * Only available for node v10+.\n\t * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>\n\t * Only available for node v10+.\n\t * @param {(\"inherit\"|\"redirect\"|\"off\")} [options.console=\"inherit\"] - Sets the behavior of the console in the sandbox.\n\t * <code>inherit</code> to enable console, <code>redirect</code> to redirect to events, <code>off</code> to disable console.\n\t * @param {Object|boolean} [options.require=false] - Allow require inside the sandbox.\n\t * @param {(boolean|string[]|Object)} [options.require.external=false] - <b>WARNING: When allowing require the option <code>options.require.root</code>\n\t * should be set to restrict the script from requiring any module. Values can be true, an array of allowed external modules or an object.\n\t * @param {(string[])} [options.require.external.modules] - Array of allowed external modules. Also supports wildcards, so specifying ['@scope/*-ver-??],\n\t * for instance, will allow using all modules having a name of the form @scope/something-ver-aa, @scope/other-ver-11, etc.\n\t * @param {boolean} [options.require.external.transitive=false] - Boolean which indicates if transitive dependencies of external modules are allowed.\n\t * @param {string[]} [options.require.builtin=[]] - Array of allowed built-in modules, accepts [\"*\"] for all.\n\t * @param {(string|string[])} [options.require.root] - Restricted path(s) where local modules can be required. If omitted every path is allowed.\n\t * @param {Object} [options.require.mock] - Collection of mock modules (both external or built-in).\n\t * @param {(\"host\"|\"sandbox\")} [options.require.context=\"host\"] - <code>host</code> to require modules in host and proxy them to sandbox.\n\t * <code>sandbox</code> to load, compile and require modules in sandbox.\n\t * Builtin modules except <code>events</code> always required in host and proxied to sandbox.\n\t * @param {string[]} [options.require.import] - Array of modules to be loaded into NodeVM on start.\n\t * @param {resolveCallback} [options.require.resolve] - An additional lookup function in case a module wasn't\n\t * found in one of the traditional node lookup paths.\n\t * @param {customRequire} [options.require.customRequire=require] - Custom require to require host and built-in modules.\n\t * @param {boolean} [options.nesting=false] -\n\t * <b>WARNING: Allowing this is a security risk as scripts can create a NodeVM which can require any host module.</b>\n\t * Allow nesting of VMs.\n\t * @param {(\"commonjs\"|\"none\")} [options.wrapper=\"commonjs\"] - <code>commonjs</code> to wrap script into CommonJS wrapper,\n\t * <code>none</code> to retrieve value returned by the script.\n\t * @param {string[]} [options.sourceExtensions=[\"js\"]] - Array of file extensions to treat as source code.\n\t * @param {string[]} [options.argv=[]] - Array of arguments passed to <code>process.argv</code>.\n\t * This object will not be copied and the script can change this object.\n\t * @param {Object} [options.env={}] - Environment map passed to <code>process.env</code>.\n\t * This object will not be copied and the script can change this object.\n\t * @param {boolean} [options.strict=false] - If modules should be loaded in strict mode.\n\t * @throws {VMError} If the compiler is unknown.\n\t */\n\tconstructor(options = {}) {\n\t\tconst {\n\t\t\tcompiler,\n\t\t\teval: allowEval,\n\t\t\twasm,\n\t\t\tconsole: consoleType = 'inherit',\n\t\t\trequire: requireOpts = false,\n\t\t\tnesting = false,\n\t\t\twrapper = 'commonjs',\n\t\t\tsourceExtensions = ['js'],\n\t\t\targv,\n\t\t\tenv,\n\t\t\tstrict = false,\n\t\t\tsandbox\n\t\t} = options;\n\n\t\t// Throw this early\n\t\tif (sandbox && 'object' !== typeof sandbox) {\n\t\t\tthrow new VMError('Sandbox must be an object.');\n\t\t}\n\n\t\tsuper({__proto__: null, compiler: compiler, eval: allowEval, wasm});\n\n\t\t// This is only here for backwards compatibility.\n\t\tobjectDefineProperty(this, 'options', {__proto__: null, value: {\n\t\t\tconsole: consoleType,\n\t\t\trequire: requireOpts,\n\t\t\tnesting,\n\t\t\twrapper,\n\t\t\tsourceExtensions,\n\t\t\tstrict\n\t\t}});\n\n\t\tconst resolver = resolverFromOptions(this, requireOpts, nesting && NESTING_OVERRIDE, this._compiler);\n\n\t\tobjectDefineProperty(this, '_resolver', {__proto__: null, value: resolver});\n\n\t\tif (!cacheSandboxScript) {\n\t\t\tcacheSandboxScript = compileScript(`${__dirname}/setup-node-sandbox.js`,\n\t\t\t\t`(function (host, data) { ${fs.readFileSync(`${__dirname}/setup-node-sandbox.js`, 'utf8')}\\n})`);\n\t\t}\n\n\t\tconst closure = this._runScript(cacheSandboxScript);\n\n\t\tconst extensions = {\n\t\t\t__proto__: null\n\t\t};\n\n\t\tconst loadJS = (mod, filename) => resolver.loadJS(this, mod, filename);\n\n\t\tfor (let i = 0; i < sourceExtensions.length; i++) {\n\t\t\textensions['.' + sourceExtensions[i]] = loadJS;\n\t\t}\n\n\t\tif (!extensions['.json']) extensions['.json'] = (mod, filename) => resolver.loadJSON(this, mod, filename);\n\t\tif (!extensions['.node']) extensions['.node'] = (mod, filename) => resolver.loadNode(this, mod, filename);\n\n\n\t\tthis.readonly(HOST);\n\t\tthis.readonly(resolver);\n\t\tthis.readonly(this);\n\n\t\tconst {\n\t\t\tModule,\n\t\t\tjsonParse,\n\t\t\tcreateRequireForModule,\n\t\t\trequireImpl\n\t\t} = closure(HOST, {\n\t\t\t__proto__: null,\n\t\t\targv,\n\t\t\tenv,\n\t\t\tconsole: consoleType,\n\t\t\tvm: this,\n\t\t\tresolver,\n\t\t\textensions\n\t\t});\n\n\t\tobjectDefineProperties(this, {\n\t\t\t__proto__: null,\n\t\t\t_Module: {__proto__: null, value: Module},\n\t\t\t_jsonParse: {__proto__: null, value: jsonParse},\n\t\t\t_createRequireForModule: {__proto__: null, value: createRequireForModule},\n\t\t\t_requireImpl: {__proto__: null, value: requireImpl},\n\t\t\t_cacheRequireModule: {__proto__: null, value: null, writable: true}\n\t\t});\n\n\n\t\tresolver.init(this);\n\n\t\t// prepare global sandbox\n\t\tif (sandbox) {\n\t\t\tthis.setGlobals(sandbox);\n\t\t}\n\n\t\tif (requireOpts && requireOpts.import) {\n\t\t\tif (Array.isArray(requireOpts.import)) {\n\t\t\t\tfor (let i = 0, l = requireOpts.import.length; i < l; i++) {\n\t\t\t\t\tthis.require(requireOpts.import[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.require(requireOpts.import);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t * @deprecated Just call the method yourself like <code>method(args);</code>\n\t * @param {function} method - Function to invoke.\n\t * @param {...*} args - Arguments to pass to the function.\n\t * @return {*} Return value of the function.\n\t * @todo Can we remove this function? It even had a bug that would use args as this parameter.\n\t * @throws {*} Rethrows anything the method throws.\n\t * @throws {VMError} If method is not a function.\n\t * @throws {Error} If method is a class.\n\t */\n\tcall(method, ...args) {\n\t\tif ('function' === typeof method) {\n\t\t\treturn method(...args);\n\t\t} else {\n\t\t\tthrow new VMError('Unrecognized method type.');\n\t\t}\n\t}\n\n\t/**\n\t * Require a module in VM and return it's exports.\n\t *\n\t * @public\n\t * @param {string} module - Module name.\n\t * @return {*} Exported module.\n\t * @throws {*} If the module couldn't be found or loading it threw an error.\n\t */\n\trequire(module) {\n\t\tconst path = this._resolver.pathResolve('.');\n\t\tlet mod = this._cacheRequireModule;\n\t\tif (!mod || mod.path !== path) {\n\t\t\tconst filename = this._resolver.pathConcat(path, '/vm.js');\n\t\t\tmod = new (this._Module)(filename, path);\n\t\t\tthis._resolver.registerModule(mod, filename, path, null, false);\n\t\t\tthis._cacheRequireModule = mod;\n\t\t}\n\t\treturn this._requireImpl(mod, module, true);\n\t}\n\n\t/**\n\t * Run the code in NodeVM.\n\t *\n\t * First time you run this method, code is executed same way like in node's regular `require` - it's executed with\n\t * `module`, `require`, `exports`, `__dirname`, `__filename` variables and expect result in `module.exports'.\n\t *\n\t * @param {(string|VMScript)} code - Code to run.\n\t * @param {(string|Object)} [options] - Options map or filename.\n\t * @param {string} [options.filename=\"vm.js\"] - Filename that shows up in any stack traces produced from this script.<br>\n\t * This is only used if code is a String.\n\t * @param {boolean} [options.strict] - If modules should be loaded in strict mode. Defaults to NodeVM options.\n\t * @param {(\"commonjs\"|\"none\")} [options.wrapper] - <code>commonjs</code> to wrap script into CommonJS wrapper,\n\t * <code>none</code> to retrieve value returned by the script. Defaults to NodeVM options.\n\t * @return {*} Result of executed code.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t * @fires NodeVM.\"console.debug\"\n\t * @fires NodeVM.\"console.log\"\n\t * @fires NodeVM.\"console.info\"\n\t * @fires NodeVM.\"console.warn\"\n\t * @fires NodeVM.\"console.error\"\n\t * @fires NodeVM.\"console.dir\"\n\t * @fires NodeVM.\"console.trace\"\n\t */\n\trun(code, options) {\n\t\tlet script;\n\t\tlet filename;\n\n\t\tif (typeof options === 'object') {\n\t\t\tfilename = options.filename;\n\t\t} else {\n\t\t\tfilename = options;\n\t\t\toptions = {__proto__: null};\n\t\t}\n\n\t\tconst {\n\t\t\tstrict = this.options.strict,\n\t\t\twrapper = this.options.wrapper,\n\t\t\tmodule: customModule,\n\t\t\trequire: customRequire,\n\t\t\tdirname: customDirname = null\n\t\t} = options;\n\n\t\tlet sandboxModule = customModule;\n\t\tlet dirname = customDirname;\n\n\t\tif (code instanceof VMScript) {\n\t\t\tscript = strict ? code._compileNodeVMStrict() : code._compileNodeVM();\n\t\t\tif (!sandboxModule) {\n\t\t\t\tconst resolvedFilename = this._resolver.pathResolve(code.filename);\n\t\t\t\tdirname = this._resolver.pathDirname(resolvedFilename);\n\t\t\t\tsandboxModule = new (this._Module)(resolvedFilename, dirname);\n\t\t\t\tthis._resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);\n\t\t\t}\n\t\t} else {\n\t\t\tconst unresolvedFilename = filename || 'vm.js';\n\t\t\tif (!sandboxModule) {\n\t\t\t\tif (filename) {\n\t\t\t\t\tconst resolvedFilename = this._resolver.pathResolve(filename);\n\t\t\t\t\tdirname = this._resolver.pathDirname(resolvedFilename);\n\t\t\t\t\tsandboxModule = new (this._Module)(resolvedFilename, dirname);\n\t\t\t\t\tthis._resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);\n\t\t\t\t} else {\n\t\t\t\t\tsandboxModule = new (this._Module)(null, null);\n\t\t\t\t\tsandboxModule.id = unresolvedFilename;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst prefix = strict ? STRICT_MODULE_PREFIX : MODULE_PREFIX;\n\t\t\tlet scriptCode = this._compiler(code, unresolvedFilename);\n\t\t\tscriptCode = transformer(null, scriptCode, false, false, unresolvedFilename).code;\n\t\t\tscript = new Script(prefix + scriptCode + MODULE_SUFFIX, {\n\t\t\t\t__proto__: null,\n\t\t\t\tfilename: unresolvedFilename,\n\t\t\t\tdisplayErrors: false\n\t\t\t});\n\t\t}\n\n\t\tconst closure = this._runScript(script);\n\n\t\tconst usedRequire = customRequire || this._createRequireForModule(sandboxModule);\n\n\t\tconst ret = Reflect.apply(closure, this.sandbox, [sandboxModule.exports, usedRequire, sandboxModule, filename, dirname]);\n\t\treturn wrapper === 'commonjs' ? sandboxModule.exports : ret;\n\t}\n\n\t/**\n\t * Create NodeVM and run code inside it.\n\t *\n\t * @public\n\t * @static\n\t * @param {string} script - Code to execute.\n\t * @param {string} [filename] - File name (used in stack traces only).\n\t * @param {Object} [options] - VM options.\n\t * @param {string} [options.filename] - File name (used in stack traces only). Used if <code>filename</code> is omitted.\n\t * @return {*} Result of executed code.\n\t * @see {@link NodeVM} for the options.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\tstatic code(script, filename, options) {\n\t\tlet unresolvedFilename;\n\t\tif (filename != null) {\n\t\t\tif ('object' === typeof filename) {\n\t\t\t\toptions = filename;\n\t\t\t\tunresolvedFilename = options.filename;\n\t\t\t} else if ('string' === typeof filename) {\n\t\t\t\tunresolvedFilename = filename;\n\t\t\t} else {\n\t\t\t\tthrow new VMError('Invalid arguments.');\n\t\t\t}\n\t\t} else if ('object' === typeof options) {\n\t\t\tunresolvedFilename = options.filename;\n\t\t}\n\n\t\tif (arguments.length > 3) {\n\t\t\tthrow new VMError('Invalid number of arguments.');\n\t\t}\n\n\t\tconst resolvedFilename = typeof unresolvedFilename === 'string' ? pa.resolve(unresolvedFilename) : undefined;\n\n\t\treturn new NodeVM(options).run(script, resolvedFilename);\n\t}\n\n\t/**\n\t * Create NodeVM and run script from file inside it.\n\t *\n\t * @public\n\t * @static\n\t * @param {string} filename - Filename of file to load and execute in a NodeVM.\n\t * @param {Object} [options] - NodeVM options.\n\t * @return {*} Result of executed code.\n\t * @see {@link NodeVM} for the options.\n\t * @throws {Error} If filename is not a valid filename.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\tstatic file(filename, options) {\n\t\tconst resolvedFilename = pa.resolve(filename);\n\n\t\tif (!fs.existsSync(resolvedFilename)) {\n\t\t\tthrow new VMError(`Script '${filename}' not found.`);\n\t\t}\n\n\t\tif (fs.statSync(resolvedFilename).isDirectory()) {\n\t\t\tthrow new VMError('Script must be file, got directory.');\n\t\t}\n\n\t\treturn new NodeVM(options).run(fs.readFileSync(resolvedFilename, 'utf8'), resolvedFilename);\n\t}\n}\n\nfunction vm2NestingLoader(resolver, vm, id) {\n\tif (!cacheMakeNestingScript) {\n\t\tcacheMakeNestingScript = compileScript('nesting.js', '(vm, nodevm) => ({VM: vm, NodeVM: nodevm})');\n\t}\n\tconst makeNesting = vm._runScript(cacheMakeNestingScript);\n\treturn makeNesting(vm.readonly(VM), vm.readonly(NodeVM));\n}\n\nexports.NodeVM = NodeVM;\n"]},"metadata":{},"sourceType":"script"}