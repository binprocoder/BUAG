{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ImmutableTree_1 = require(\"./util/ImmutableTree\");\n\nvar Path_1 = require(\"./util/Path\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Node_1 = require(\"./snap/Node\");\n\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\n\nvar util_2 = require(\"@firebase/util\");\n/**\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\n * to reflect the write added.\n *\n * @constructor\n * @param {!ImmutableTree.<!Node>} writeTree\n */\n\n\nvar CompoundWrite =\n/** @class */\nfunction () {\n  function CompoundWrite(writeTree_) {\n    this.writeTree_ = writeTree_;\n  }\n  /**\n   * @param {!Path} path\n   * @param {!Node} node\n   * @return {!CompoundWrite}\n   */\n\n\n  CompoundWrite.prototype.addWrite = function (path, node) {\n    if (path.isEmpty()) {\n      return new CompoundWrite(new ImmutableTree_1.ImmutableTree(node));\n    } else {\n      var rootmost = this.writeTree_.findRootMostValueAndPath(path);\n\n      if (rootmost != null) {\n        var rootMostPath = rootmost.path;\n        var value = rootmost.value;\n        var relativePath = Path_1.Path.relativePath(rootMostPath, path);\n        value = value.updateChild(relativePath, node);\n        return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\n      } else {\n        var subtree = new ImmutableTree_1.ImmutableTree(node);\n        var newWriteTree = this.writeTree_.setTree(path, subtree);\n        return new CompoundWrite(newWriteTree);\n      }\n    }\n  };\n  /**\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} updates\n   * @return {!CompoundWrite}\n   */\n\n\n  CompoundWrite.prototype.addWrites = function (path, updates) {\n    var newWrite = this;\n    util_1.forEach(updates, function (childKey, node) {\n      newWrite = newWrite.addWrite(path.child(childKey), node);\n    });\n    return newWrite;\n  };\n  /**\n   * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\n   * location, which must be removed by calling this method with that path.\n   *\n   * @param {!Path} path The path at which a write and all deeper writes should be removed\n   * @return {!CompoundWrite} The new CompoundWrite with the removed path\n   */\n\n\n  CompoundWrite.prototype.removeWrite = function (path) {\n    if (path.isEmpty()) {\n      return CompoundWrite.Empty;\n    } else {\n      var newWriteTree = this.writeTree_.setTree(path, ImmutableTree_1.ImmutableTree.Empty);\n      return new CompoundWrite(newWriteTree);\n    }\n  };\n  /**\n   * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\n   * considered \"complete\".\n   *\n   * @param {!Path} path The path to check for\n   * @return {boolean} Whether there is a complete write at that path\n   */\n\n\n  CompoundWrite.prototype.hasCompleteWrite = function (path) {\n    return this.getCompleteNode(path) != null;\n  };\n  /**\n   * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\n   * writes from deeper paths, but will return child nodes from a more shallow path.\n   *\n   * @param {!Path} path The path to get a complete write\n   * @return {?Node} The node if complete at that path, or null otherwise.\n   */\n\n\n  CompoundWrite.prototype.getCompleteNode = function (path) {\n    var rootmost = this.writeTree_.findRootMostValueAndPath(path);\n\n    if (rootmost != null) {\n      return this.writeTree_.get(rootmost.path).getChild(Path_1.Path.relativePath(rootmost.path, path));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Returns all children that are guaranteed to be a complete overwrite.\n   *\n   * @return {!Array.<NamedNode>} A list of all complete children.\n   */\n\n\n  CompoundWrite.prototype.getCompleteChildren = function () {\n    var children = [];\n    var node = this.writeTree_.value;\n\n    if (node != null) {\n      // If it's a leaf node, it has no children; so nothing to do.\n      if (!node.isLeafNode()) {\n        node.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {\n          children.push(new Node_1.NamedNode(childName, childNode));\n        });\n      }\n    } else {\n      this.writeTree_.children.inorderTraversal(function (childName, childTree) {\n        if (childTree.value != null) {\n          children.push(new Node_1.NamedNode(childName, childTree.value));\n        }\n      });\n    }\n\n    return children;\n  };\n  /**\n   * @param {!Path} path\n   * @return {!CompoundWrite}\n   */\n\n\n  CompoundWrite.prototype.childCompoundWrite = function (path) {\n    if (path.isEmpty()) {\n      return this;\n    } else {\n      var shadowingNode = this.getCompleteNode(path);\n\n      if (shadowingNode != null) {\n        return new CompoundWrite(new ImmutableTree_1.ImmutableTree(shadowingNode));\n      } else {\n        return new CompoundWrite(this.writeTree_.subtree(path));\n      }\n    }\n  };\n  /**\n   * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\n   * @return {boolean} Whether this CompoundWrite is empty\n   */\n\n\n  CompoundWrite.prototype.isEmpty = function () {\n    return this.writeTree_.isEmpty();\n  };\n  /**\n   * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\n   * node\n   * @param {!Node} node The node to apply this CompoundWrite to\n   * @return {!Node} The node with all writes applied\n   */\n\n\n  CompoundWrite.prototype.apply = function (node) {\n    return CompoundWrite.applySubtreeWrite_(Path_1.Path.Empty, this.writeTree_, node);\n  };\n  /**\n   * @type {!CompoundWrite}\n   */\n\n\n  CompoundWrite.Empty = new CompoundWrite(new ImmutableTree_1.ImmutableTree(null));\n  /**\n   * @param {!Path} relativePath\n   * @param {!ImmutableTree.<!Node>} writeTree\n   * @param {!Node} node\n   * @return {!Node}\n   * @private\n   */\n\n  CompoundWrite.applySubtreeWrite_ = function (relativePath, writeTree, node) {\n    if (writeTree.value != null) {\n      // Since there a write is always a leaf, we're done here\n      return node.updateChild(relativePath, writeTree.value);\n    } else {\n      var priorityWrite_1 = null;\n      writeTree.children.inorderTraversal(function (childKey, childTree) {\n        if (childKey === '.priority') {\n          // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n          // to apply priorities to empty nodes that are later filled\n          util_2.assert(childTree.value !== null, 'Priority writes must always be leaf nodes');\n          priorityWrite_1 = childTree.value;\n        } else {\n          node = CompoundWrite.applySubtreeWrite_(relativePath.child(childKey), childTree, node);\n        }\n      }); // If there was a priority write, we only apply it if the node is not empty\n\n      if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {\n        node = node.updateChild(relativePath.child('.priority'), priorityWrite_1);\n      }\n\n      return node;\n    }\n  };\n\n  return CompoundWrite;\n}();\n\nexports.CompoundWrite = CompoundWrite;","map":{"version":3,"mappings":"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","names":["writeTree_","CompoundWrite","path","node","isEmpty","ImmutableTree_1","rootmost","findRootMostValueAndPath","rootMostPath","value","relativePath","Path_1","updateChild","set","subtree","newWriteTree","setTree","updates","newWrite","util_1","childKey","addWrite","child","Empty","getCompleteNode","get","getChild","children","isLeafNode","forEachChild","PriorityIndex_1","childName","childNode","push","Node_1","inorderTraversal","childTree","shadowingNode","applySubtreeWrite_","writeTree","priorityWrite_1","util_2","exports"],"sources":["../src/core/CompoundWrite.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ImmutableTree } from './util/ImmutableTree';\nimport { Path } from './util/Path';\nimport { forEach } from '@firebase/util';\nimport { Node, NamedNode } from './snap/Node';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { assert } from '@firebase/util';\nimport { ChildrenNode } from './snap/ChildrenNode';\n\n/**\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\n * to reflect the write added.\n *\n * @constructor\n * @param {!ImmutableTree.<!Node>} writeTree\n */\nexport class CompoundWrite {\n  constructor(private writeTree_: ImmutableTree<Node>) {}\n  /**\n   * @type {!CompoundWrite}\n   */\n  static Empty = new CompoundWrite(new ImmutableTree(null));\n\n  /**\n   * @param {!Path} path\n   * @param {!Node} node\n   * @return {!CompoundWrite}\n   */\n  addWrite(path: Path, node: Node): CompoundWrite {\n    if (path.isEmpty()) {\n      return new CompoundWrite(new ImmutableTree(node));\n    } else {\n      const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n      if (rootmost != null) {\n        const rootMostPath = rootmost.path;\n        let value = rootmost.value;\n        const relativePath = Path.relativePath(rootMostPath, path);\n        value = value.updateChild(relativePath, node);\n        return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\n      } else {\n        const subtree = new ImmutableTree(node);\n        const newWriteTree = this.writeTree_.setTree(path, subtree);\n        return new CompoundWrite(newWriteTree);\n      }\n    }\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} updates\n   * @return {!CompoundWrite}\n   */\n  addWrites(path: Path, updates: { [name: string]: Node }): CompoundWrite {\n    let newWrite = this as CompoundWrite;\n    forEach(updates, function(childKey: string, node: Node) {\n      newWrite = newWrite.addWrite(path.child(childKey), node);\n    });\n    return newWrite;\n  }\n\n  /**\n   * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\n   * location, which must be removed by calling this method with that path.\n   *\n   * @param {!Path} path The path at which a write and all deeper writes should be removed\n   * @return {!CompoundWrite} The new CompoundWrite with the removed path\n   */\n  removeWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return CompoundWrite.Empty;\n    } else {\n      const newWriteTree = this.writeTree_.setTree(path, ImmutableTree.Empty);\n      return new CompoundWrite(newWriteTree);\n    }\n  }\n\n  /**\n   * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\n   * considered \"complete\".\n   *\n   * @param {!Path} path The path to check for\n   * @return {boolean} Whether there is a complete write at that path\n   */\n  hasCompleteWrite(path: Path): boolean {\n    return this.getCompleteNode(path) != null;\n  }\n\n  /**\n   * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\n   * writes from deeper paths, but will return child nodes from a more shallow path.\n   *\n   * @param {!Path} path The path to get a complete write\n   * @return {?Node} The node if complete at that path, or null otherwise.\n   */\n  getCompleteNode(path: Path): Node | null {\n    const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n    if (rootmost != null) {\n      return this.writeTree_\n        .get(rootmost.path)\n        .getChild(Path.relativePath(rootmost.path, path));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns all children that are guaranteed to be a complete overwrite.\n   *\n   * @return {!Array.<NamedNode>} A list of all complete children.\n   */\n  getCompleteChildren(): Array<NamedNode> {\n    const children: NamedNode[] = [];\n    let node = this.writeTree_.value;\n    if (node != null) {\n      // If it's a leaf node, it has no children; so nothing to do.\n      if (!node.isLeafNode()) {\n        (node as ChildrenNode).forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childNode\n        ) {\n          children.push(new NamedNode(childName, childNode));\n        });\n      }\n    } else {\n      this.writeTree_.children.inorderTraversal(function(childName, childTree) {\n        if (childTree.value != null) {\n          children.push(new NamedNode(childName, childTree.value));\n        }\n      });\n    }\n    return children;\n  }\n\n  /**\n   * @param {!Path} path\n   * @return {!CompoundWrite}\n   */\n  childCompoundWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return this;\n    } else {\n      const shadowingNode = this.getCompleteNode(path);\n      if (shadowingNode != null) {\n        return new CompoundWrite(new ImmutableTree(shadowingNode));\n      } else {\n        return new CompoundWrite(this.writeTree_.subtree(path));\n      }\n    }\n  }\n\n  /**\n   * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\n   * @return {boolean} Whether this CompoundWrite is empty\n   */\n  isEmpty(): boolean {\n    return this.writeTree_.isEmpty();\n  }\n\n  /**\n   * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\n   * node\n   * @param {!Node} node The node to apply this CompoundWrite to\n   * @return {!Node} The node with all writes applied\n   */\n  apply(node: Node): Node {\n    return CompoundWrite.applySubtreeWrite_(Path.Empty, this.writeTree_, node);\n  }\n\n  /**\n   * @param {!Path} relativePath\n   * @param {!ImmutableTree.<!Node>} writeTree\n   * @param {!Node} node\n   * @return {!Node}\n   * @private\n   */\n  private static applySubtreeWrite_ = function(\n    relativePath: Path,\n    writeTree: ImmutableTree<Node>,\n    node: Node\n  ): Node {\n    if (writeTree.value != null) {\n      // Since there a write is always a leaf, we're done here\n      return node.updateChild(relativePath, writeTree.value);\n    } else {\n      let priorityWrite = null;\n      writeTree.children.inorderTraversal(function(childKey, childTree) {\n        if (childKey === '.priority') {\n          // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n          // to apply priorities to empty nodes that are later filled\n          assert(\n            childTree.value !== null,\n            'Priority writes must always be leaf nodes'\n          );\n          priorityWrite = childTree.value;\n        } else {\n          node = CompoundWrite.applySubtreeWrite_(\n            relativePath.child(childKey),\n            childTree,\n            node\n          );\n        }\n      });\n      // If there was a priority write, we only apply it if the node is not empty\n      if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\n        node = node.updateChild(relativePath.child('.priority'), priorityWrite);\n      }\n      return node;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}