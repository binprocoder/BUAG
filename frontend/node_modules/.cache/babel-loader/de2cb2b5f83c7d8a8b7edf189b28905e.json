{"ast":null,"code":"/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nimport { createSubscribe } from '@firebase/util';\nimport { patchProperty, deepCopy, deepExtend, ErrorFactory } from '@firebase/util';\n\nvar contains = function (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]'; // An array to capture listeners before the true auth functions\n// exist\n\nvar tokenListeners = [];\n/**\r\n * Global context object for a collection of services using\r\n * a shared authentication state.\r\n */\n\nvar FirebaseAppImpl =\n/** @class */\nfunction () {\n  function FirebaseAppImpl(options, name, firebase_) {\n    this.firebase_ = firebase_;\n    this.isDeleted_ = false;\n    this.services_ = {};\n    this.name_ = name;\n    this.options_ = deepCopy(options);\n    this.INTERNAL = {\n      getUid: function () {\n        return null;\n      },\n      getToken: function () {\n        return Promise.resolve(null);\n      },\n      addAuthTokenListener: function (callback) {\n        tokenListeners.push(callback); // Make sure callback is called, asynchronously, in the absence of the auth module\n\n        setTimeout(function () {\n          return callback(null);\n        }, 0);\n      },\n      removeAuthTokenListener: function (callback) {\n        tokenListeners = tokenListeners.filter(function (listener) {\n          return listener !== callback;\n        });\n      }\n    };\n  }\n\n  Object.defineProperty(FirebaseAppImpl.prototype, \"name\", {\n    get: function () {\n      this.checkDestroyed_();\n      return this.name_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FirebaseAppImpl.prototype, \"options\", {\n    get: function () {\n      this.checkDestroyed_();\n      return this.options_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FirebaseAppImpl.prototype.delete = function () {\n    var _this = this;\n\n    return new Promise(function (resolve) {\n      _this.checkDestroyed_();\n\n      resolve();\n    }).then(function () {\n      _this.firebase_.INTERNAL.removeApp(_this.name_);\n\n      var services = [];\n      Object.keys(_this.services_).forEach(function (serviceKey) {\n        Object.keys(_this.services_[serviceKey]).forEach(function (instanceKey) {\n          services.push(_this.services_[serviceKey][instanceKey]);\n        });\n      });\n      return Promise.all(services.map(function (service) {\n        return service.INTERNAL.delete();\n      }));\n    }).then(function () {\n      _this.isDeleted_ = true;\n      _this.services_ = {};\n    });\n  };\n  /**\r\n   * Return a service instance associated with this app (creating it\r\n   * on demand), identified by the passed instanceIdentifier.\r\n   *\r\n   * NOTE: Currently storage is the only one that is leveraging this\r\n   * functionality. They invoke it by calling:\r\n   *\r\n   * ```javascript\r\n   * firebase.app().storage('STORAGE BUCKET ID')\r\n   * ```\r\n   *\r\n   * The service name is passed to this already\r\n   * @internal\r\n   */\n\n\n  FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {\n    if (instanceIdentifier === void 0) {\n      instanceIdentifier = DEFAULT_ENTRY_NAME;\n    }\n\n    this.checkDestroyed_();\n\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\r\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\r\n       * then we will pass that instance on, otherwise we pass `null`\r\n       */\n      var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME ? instanceIdentifier : undefined;\n      var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);\n      this.services_[name][instanceIdentifier] = service;\n    }\n\n    return this.services_[name][instanceIdentifier];\n  };\n  /**\r\n   * Callback function used to extend an App instance at the time\r\n   * of service instance creation.\r\n   */\n\n\n  FirebaseAppImpl.prototype.extendApp = function (props) {\n    var _this = this; // Copy the object onto the FirebaseAppImpl prototype\n\n\n    deepExtend(this, props);\n    /**\r\n     * If the app has overwritten the addAuthTokenListener stub, forward\r\n     * the active token listeners on to the true fxn.\r\n     *\r\n     * TODO: This function is required due to our current module\r\n     * structure. Once we are able to rely strictly upon a single module\r\n     * implementation, this code should be refactored and Auth should\r\n     * provide these stubs and the upgrade logic\r\n     */\n\n    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n      tokenListeners.forEach(function (listener) {\n        _this.INTERNAL.addAuthTokenListener(listener);\n      });\n      tokenListeners = [];\n    }\n  };\n  /**\r\n   * This function will throw an Error if the App has already been deleted -\r\n   * use before performing API actions on the App.\r\n   */\n\n\n  FirebaseAppImpl.prototype.checkDestroyed_ = function () {\n    if (this.isDeleted_) {\n      error('app-deleted', {\n        name: this.name_\n      });\n    }\n  };\n\n  return FirebaseAppImpl;\n}(); // Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n\n\nFirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log('dc');\n/**\r\n * Return a firebase namespace object.\r\n *\r\n * In production, this will be called exactly once and the result\r\n * assigned to the 'firebase' global.  It may be called multiple times\r\n * in unit tests.\r\n */\n\nexport function createFirebaseNamespace() {\n  var apps_ = {};\n  var factories = {};\n  var appHooks = {}; // A namespace is a plain JavaScript Object.\n\n  var namespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    __esModule: true,\n    initializeApp: initializeApp,\n    app: app,\n    apps: null,\n    Promise: Promise,\n    SDK_VERSION: '4.8.0',\n    INTERNAL: {\n      registerService: registerService,\n      createFirebaseNamespace: createFirebaseNamespace,\n      extendNamespace: extendNamespace,\n      createSubscribe: createSubscribe,\n      ErrorFactory: ErrorFactory,\n      removeApp: removeApp,\n      factories: factories,\n      useAsService: useAsService,\n      Promise: Promise,\n      deepExtend: deepExtend\n    }\n  }; // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n\n  patchProperty(namespace, 'default', namespace); // firebase.apps is a read-only getter.\n\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n  /**\r\n   * Called by App.delete() - but before any services associated with the App\r\n   * are deleted.\r\n   */\n\n  function removeApp(name) {\n    var app = apps_[name];\n    callAppHooks(app, 'delete');\n    delete apps_[name];\n  }\n  /**\r\n   * Get the App object for a given name (or DEFAULT).\r\n   */\n\n\n  function app(name) {\n    name = name || DEFAULT_ENTRY_NAME;\n\n    if (!contains(apps_, name)) {\n      error('no-app', {\n        name: name\n      });\n    }\n\n    return apps_[name];\n  }\n\n  patchProperty(app, 'App', FirebaseAppImpl);\n  /**\r\n   * Create a new App instance (name must be unique).\r\n   */\n\n  function initializeApp(options, name) {\n    if (name === undefined) {\n      name = DEFAULT_ENTRY_NAME;\n    } else {\n      if (typeof name !== 'string' || name === '') {\n        error('bad-app-name', {\n          name: name + ''\n        });\n      }\n    }\n\n    if (contains(apps_, name)) {\n      error('duplicate-app', {\n        name: name\n      });\n    }\n\n    var app = new FirebaseAppImpl(options, name, namespace);\n    apps_[name] = app;\n    callAppHooks(app, 'create');\n    return app;\n  }\n  /*\r\n   * Return an array of all the non-deleted FirebaseApps.\r\n   */\n\n\n  function getApps() {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps_).map(function (name) {\n      return apps_[name];\n    });\n  }\n  /*\r\n   * Register a Firebase Service.\r\n   *\r\n   * firebase.INTERNAL.registerService()\r\n   *\r\n   * TODO: Implement serviceProperties.\r\n   */\n\n\n  function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {\n    // Cannot re-register a service that already exists\n    if (factories[name]) {\n      error('duplicate-service', {\n        name: name\n      });\n    } // Capture the service factory for later service instantiation\n\n\n    factories[name] = createService; // Capture the appHook, if passed\n\n    if (appHook) {\n      appHooks[name] = appHook; // Run the **new** app hook on all existing apps\n\n      getApps().forEach(function (app) {\n        appHook('create', app);\n      });\n    } // The Service namespace is an accessor function ...\n\n\n    var serviceNamespace = function (appArg) {\n      if (appArg === void 0) {\n        appArg = app();\n      }\n\n      if (typeof appArg[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        error('invalid-app-argument', {\n          name: name\n        });\n      } // Forward service instance lookup to the FirebaseApp.\n\n\n      return appArg[name]();\n    }; // ... and a container for service-level properties.\n\n\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    } // Monkey-patch the serviceNamespace onto the firebase namespace\n\n\n    namespace[name] = serviceNamespace; // Patch the FirebaseAppImpl prototype\n\n    FirebaseAppImpl.prototype[name] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var serviceFxn = this._getService.bind(this, name);\n\n      return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n    };\n\n    return serviceNamespace;\n  }\n  /**\r\n   * Patch the top-level firebase namespace with additional properties.\r\n   *\r\n   * firebase.INTERNAL.extendNamespace()\r\n   */\n\n\n  function extendNamespace(props) {\n    deepExtend(namespace, props);\n  }\n\n  function callAppHooks(app, eventName) {\n    Object.keys(factories).forEach(function (serviceName) {\n      // Ignore virtual services\n      var factoryName = useAsService(app, serviceName);\n\n      if (factoryName === null) {\n        return;\n      }\n\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    });\n  } // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n\n\n  function useAsService(app, name) {\n    if (name === 'serverAuth') {\n      return null;\n    }\n\n    var useService = name;\n    var options = app.options;\n    return useService;\n  }\n\n  return namespace;\n}\n\nfunction error(code, args) {\n  throw appErrors.create(code, args);\n} // TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\n\n\nvar errors = {\n  'no-app': \"No Firebase App '{$name}' has been created - \" + 'call Firebase App.initializeApp()',\n  'bad-app-name': \"Illegal App name: '{$name}\",\n  'duplicate-app': \"Firebase App named '{$name}' already exists\",\n  'app-deleted': \"Firebase App named '{$name}' already deleted\",\n  'duplicate-service': \"Firebase service named '{$name}' already registered\",\n  'sa-not-supported': 'Initializing the Firebase SDK with a service ' + 'account is only allowed in a Node.js environment. On client ' + 'devices, you should instead initialize the SDK with an api key and ' + 'auth domain',\n  'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' + 'Firebase App instance.'\n};\nvar appErrors = new ErrorFactory('app', 'Firebase', errors);","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAeA,SAASA,eAAT,QAAqD,gBAArD;AACA,SACEC,aADF,EAEEC,QAFF,EAGEC,UAHF,EAIEC,YAJF,QAMO,gBANP;;AAmNA,IAAMC,QAAQ,GAAG,UAASC,GAAT,EAAcC,GAAd,EAAiB;AAChC,SAAOC,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,GAArC,EAA0CC,GAA1C,CAAP;AACD,CAFD;;AAIA,IAAMK,kBAAkB,GAAG,WAA3B,C,CAEA;AACA;;AACA,IAAIC,cAAc,GAAG,EAArB;AAEA;;;;;AAIA;AAAA;AAAA;AAYE,2BACEC,OADF,EAEEC,IAFF,EAGUC,SAHV,EAGsC;AAA5B;AAZF,sBAAa,KAAb;AACA,qBAIJ,EAJI;AAaN,SAAKC,KAAL,GAAaF,IAAb;AACA,SAAKG,QAAL,GAAgBhB,QAAQ,CAAkBY,OAAlB,CAAxB;AACA,SAAKK,QAAL,GAAgB;AACdC,YAAM,EAAE;AAAM;AAAI,OADJ;AAEdC,cAAQ,EAAE;AAAM,sBAAO,CAACC,OAAR,CAAgB,IAAhB;AAAqB,OAFvB;AAGdC,0BAAoB,EAAE,UAACC,QAAD,EAAyC;AAC7DX,sBAAc,CAACY,IAAf,CAAoBD,QAApB,EAD6D,CAE7D;;AACAE,kBAAU,CAAC;AAAM,yBAAQ,CAAC,IAAD,CAAR;AAAc,SAArB,EAAuB,CAAvB,CAAV;AACD,OAPa;AAQdC,6BAAuB,EAAE,oBAAQ;AAC/Bd,sBAAc,GAAGA,cAAc,CAACe,MAAf,CACf,oBAAQ;AAAI,yBAAQ,KAAKJ,QAAb;AAAqB,SADlB,CAAjB;AAGD;AAZa,KAAhB;AAcD;;AAEDhB,wBAAIqB,yBAAJ,EAAI,MAAJ,EAAQ;SAAR;AACE,WAAKC,eAAL;AACA,aAAO,KAAKb,KAAZ;AACD,KAHO;oBAAA;;AAAA,GAAR;AAKAT,wBAAIqB,yBAAJ,EAAI,SAAJ,EAAW;SAAX;AACE,WAAKC,eAAL;AACA,aAAO,KAAKZ,QAAZ;AACD,KAHU;oBAAA;;AAAA,GAAX;;AAKAW;AAAA;;AACE,WAAO,IAAIE,OAAJ,CAAY,mBAAO;AACxBC,WAAI,CAACF,eAAL;;AACAR,aAAO;AACR,KAHM,EAIJW,IAJI,CAIC;AACJD,WAAI,CAAChB,SAAL,CAAeG,QAAf,CAAwBe,SAAxB,CAAkCF,KAAI,CAACf,KAAvC;;AACA,UAAIkB,QAAQ,GAAsB,EAAlC;AACA3B,YAAM,CAAC4B,IAAP,CAAYJ,KAAI,CAACK,SAAjB,EAA4BC,OAA5B,CAAoC,sBAAU;AAC5C9B,cAAM,CAAC4B,IAAP,CAAYJ,KAAI,CAACK,SAAL,CAAeE,UAAf,CAAZ,EAAwCD,OAAxC,CAAgD,uBAAW;AACzDH,kBAAQ,CAACV,IAAT,CAAcO,KAAI,CAACK,SAAL,CAAeE,UAAf,EAA2BC,WAA3B,CAAd;AACD,SAFD;AAGD,OAJD;AAKA,aAAOT,OAAO,CAACU,GAAR,CACLN,QAAQ,CAACO,GAAT,CAAa,mBAAO;AAClB,eAAOC,OAAO,CAACxB,QAAR,CAAkByB,MAAlB,EAAP;AACD,OAFD,CADK,CAAP;AAKD,KAjBI,EAkBJX,IAlBI,CAkBC;AACJD,WAAI,CAACa,UAAL,GAAkB,IAAlB;AACAb,WAAI,CAACK,SAAL,GAAiB,EAAjB;AACD,KArBI,CAAP;AAsBD,GAvBD;AAyBA;;;;;;;;;;;;;;;;AAcAR,oDACEd,IADF,EAEE+B,kBAFF,EAEiD;AAA/C;AAAAA;AAA+C;;AAE/C,SAAKhB,eAAL;;AAEA,QAAI,CAAC,KAAKO,SAAL,CAAetB,IAAf,CAAL,EAA2B;AACzB,WAAKsB,SAAL,CAAetB,IAAf,IAAuB,EAAvB;AACD;;AAED,QAAI,CAAC,KAAKsB,SAAL,CAAetB,IAAf,EAAqB+B,kBAArB,CAAL,EAA+C;AAC7C;;;;AAIA,UAAMC,iBAAiB,GACrBD,kBAAkB,KAAKlC,kBAAvB,GACIkC,kBADJ,GAEIE,SAHN;AAIA,UAAML,OAAO,GAAG,KAAK3B,SAAL,CAAeG,QAAf,CAAwB8B,SAAxB,CAAkClC,IAAlC,EACd,IADc,EAEd,KAAKmC,SAAL,CAAeC,IAAf,CAAoB,IAApB,CAFc,EAGdJ,iBAHc,CAAhB;AAKA,WAAKV,SAAL,CAAetB,IAAf,EAAqB+B,kBAArB,IAA2CH,OAA3C;AACD;;AAED,WAAO,KAAKN,SAAL,CAAetB,IAAf,EAAqB+B,kBAArB,CAAP;AACD,GA5BD;AA8BA;;;;;;AAIQjB,wCAAR,UAAkBuB,KAAlB,EAAgD;AAAhD,qBAAgD,CAC9C;;;AACAjD,cAAU,CAAC,IAAD,EAAOiD,KAAP,CAAV;AAEA;;;;;;;;;;AASA,QAAIA,KAAK,CAACjC,QAAN,IAAkBiC,KAAK,CAACjC,QAAN,CAAeI,oBAArC,EAA2D;AACzDV,oBAAc,CAACyB,OAAf,CAAuB,oBAAQ;AAC7BN,aAAI,CAACb,QAAL,CAAcI,oBAAd,CAAmC8B,QAAnC;AACD,OAFD;AAGAxC,oBAAc,GAAG,EAAjB;AACD;AACF,GAnBO;AAqBR;;;;;;AAIQgB,8CAAR;AACE,QAAI,KAAKgB,UAAT,EAAqB;AACnBS,WAAK,CAAC,aAAD,EAAgB;AAAEvC,YAAI,EAAE,KAAKE;AAAb,OAAhB,CAAL;AACD;AACF,GAJO;;AAKV;AApJA,I,CAsJA;AACA;;;AACCY,eAAe,CAACpB,SAAhB,CAA0BM,IAA1B,IAAkCc,eAAe,CAACpB,SAAhB,CAA0BK,OAA7D,IACEe,eAAe,CAACpB,SAAhB,CAA0BmC,MAD5B,IAEEW,OAAO,CAACC,GAAR,CAAY,IAAZ,CAFF;AAIA;;;;;;;;AAOA,OAAM;AACJ,MAAIC,KAAK,GAAoC,EAA7C;AACA,MAAIR,SAAS,GAAkD,EAA/D;AACA,MAAIS,QAAQ,GAAmC,EAA/C,CAHI,CAKJ;;AACA,MAAIC,SAAS,GAAG;AACd;AACA;AACAC,cAAU,EAAE,IAHE;AAIdC,iBAAa,EAAEA,aAJD;AAKdC,OAAG,EAAEA,GALS;AAMdC,QAAI,EAAE,IANQ;AAOdhC,WAAO,EAAEA,OAPK;AAQdiC,eAAW,EAAE,OARC;AASd7C,YAAQ,EAAE;AACR8C,qBAAe,EAAEA,eADT;AAERC,6BAAuB,EAAEA,uBAFjB;AAGRC,qBAAe,EAAEA,eAHT;AAIRnE,qBAAe,EAAEA,eAJT;AAKRI,kBAAY,EAAEA,YALN;AAMR8B,eAAS,EAAEA,SANH;AAORe,eAAS,EAAEA,SAPH;AAQRmB,kBAAY,EAAEA,YARN;AASRrC,aAAO,EAAEA,OATD;AAUR5B,gBAAU,EAAEA;AAVJ;AATI,GAAhB,CANI,CA6BJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAF,eAAa,CAAC0D,SAAD,EAAY,SAAZ,EAAuBA,SAAvB,CAAb,CAvCI,CAyCJ;;AACAnD,QAAM,CAAC6D,cAAP,CAAsBV,SAAtB,EAAiC,MAAjC,EAAyC;AACvCW,OAAG,EAAEC;AADkC,GAAzC;AAIA;;;;;AAIA,qBAAmBxD,IAAnB,EAA+B;AAC7B,QAAI+C,GAAG,GAAGL,KAAK,CAAC1C,IAAD,CAAf;AACAyD,gBAAY,CAACV,GAAD,EAAM,QAAN,CAAZ;AACA,WAAOL,KAAK,CAAC1C,IAAD,CAAZ;AACD;AAED;;;;;AAGA,eAAaA,IAAb,EAA0B;AACxBA,QAAI,GAAGA,IAAI,IAAIH,kBAAf;;AACA,QAAI,CAACP,QAAQ,CAACoD,KAAD,EAAQ1C,IAAR,CAAb,EAA4B;AAC1BuC,WAAK,CAAC,QAAD,EAAW;AAAEvC,YAAI,EAAEA;AAAR,OAAX,CAAL;AACD;;AACD,WAAO0C,KAAK,CAAC1C,IAAD,CAAZ;AACD;;AAEDd,eAAa,CAAC6D,GAAD,EAAM,KAAN,EAAajC,eAAb,CAAb;AAEA;;;;AAGA,yBAAuBf,OAAvB,EAAiDC,IAAjD,EAA8D;AAC5D,QAAIA,IAAI,KAAKiC,SAAb,EAAwB;AACtBjC,UAAI,GAAGH,kBAAP;AACD,KAFD,MAEO;AACL,UAAI,OAAOG,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,EAAzC,EAA6C;AAC3CuC,aAAK,CAAC,cAAD,EAAiB;AAAEvC,cAAI,EAAEA,IAAI,GAAG;AAAf,SAAjB,CAAL;AACD;AACF;;AACD,QAAIV,QAAQ,CAACoD,KAAD,EAAQ1C,IAAR,CAAZ,EAA2B;AACzBuC,WAAK,CAAC,eAAD,EAAkB;AAAEvC,YAAI,EAAEA;AAAR,OAAlB,CAAL;AACD;;AAED,QAAI+C,GAAG,GAAG,IAAIjC,eAAJ,CACRf,OADQ,EAERC,IAFQ,EAGR4C,SAHQ,CAAV;AAMAF,SAAK,CAAC1C,IAAD,CAAL,GAAe+C,GAAf;AACAU,gBAAY,CAACV,GAAD,EAAM,QAAN,CAAZ;AAEA,WAAOA,GAAP;AACD;AAED;;;;;AAGA;AACE;AACA,WAAOtD,MAAM,CAAC4B,IAAP,CAAYqB,KAAZ,EAAmBf,GAAnB,CAAuB,gBAAI;AAAI,kBAAK,CAAC3B,IAAD,CAAL;AAAW,KAA1C,CAAP;AACD;AAED;;;;;;;;;AAOA,2BACEA,IADF,EAEE0D,aAFF,EAGEC,iBAHF,EAIEC,OAJF,EAKEC,sBALF,EAKkC;AAEhC;AACA,QAAI3B,SAAS,CAAClC,IAAD,CAAb,EAAqB;AACnBuC,WAAK,CAAC,mBAAD,EAAsB;AAAEvC,YAAI,EAAEA;AAAR,OAAtB,CAAL;AACD,KAL+B,CAOhC;;;AACAkC,aAAS,CAAClC,IAAD,CAAT,GAAkB0D,aAAlB,CARgC,CAUhC;;AACA,QAAIE,OAAJ,EAAa;AACXjB,cAAQ,CAAC3C,IAAD,CAAR,GAAiB4D,OAAjB,CADW,CAGX;;AACAJ,aAAO,GAAGjC,OAAV,CAAkB,eAAG;AACnBqC,eAAO,CAAC,QAAD,EAAWb,GAAX,CAAP;AACD,OAFD;AAGD,KAlB+B,CAoBhC;;;AACA,QAAMe,gBAAgB,GAAG,UAACC,MAAD,EAA4B;AAA3B;AAAAA,iBAAsBhB,GAAG,EAAzB;AAA2B;;AACnD,UAAI,OAAQgB,MAAc,CAAC/D,IAAD,CAAtB,KAAiC,UAArC,EAAiD;AAC/C;AACA;AACAuC,aAAK,CAAC,sBAAD,EAAyB;AAAEvC,cAAI,EAAEA;AAAR,SAAzB,CAAL;AACD,OALkD,CAOnD;;;AACA,aAAQ+D,MAAc,CAAC/D,IAAD,CAAd,EAAR;AACD,KATD,CArBgC,CAgChC;;;AACA,QAAI2D,iBAAiB,KAAK1B,SAA1B,EAAqC;AACnC7C,gBAAU,CAAC0E,gBAAD,EAAmBH,iBAAnB,CAAV;AACD,KAnC+B,CAqChC;;;AACCf,aAAiB,CAAC5C,IAAD,CAAjB,GAA0B8D,gBAA1B,CAtC+B,CAwChC;;AACAhD,mBAAe,CAACpB,SAAhB,CAA0BM,IAA1B,IAAkC;AAAS;;WAAA,yCAAO;AAAPgE;;;AACzC,UAAMC,UAAU,GAAG,KAAKC,WAAL,CAAiB9B,IAAjB,CAAsB,IAAtB,EAA4BpC,IAA5B,CAAnB;;AACA,aAAOiE,UAAU,CAACE,KAAX,CAAiB,IAAjB,EAAuBN,sBAAsB,GAAGG,IAAH,GAAU,EAAvD,CAAP;AACD,KAHD;;AAKA,WAAOF,gBAAP;AACD;AAED;;;;;;;AAKA,2BAAyBzB,KAAzB,EAAuD;AACrDjD,cAAU,CAACwD,SAAD,EAAYP,KAAZ,CAAV;AACD;;AAED,wBAAsBU,GAAtB,EAAwCqB,SAAxC,EAAyD;AACvD3E,UAAM,CAAC4B,IAAP,CAAYa,SAAZ,EAAuBX,OAAvB,CAA+B,uBAAW;AACxC;AACA,UAAI8C,WAAW,GAAGhB,YAAY,CAACN,GAAD,EAAMuB,WAAN,CAA9B;;AACA,UAAID,WAAW,KAAK,IAApB,EAA0B;AACxB;AACD;;AAED,UAAI1B,QAAQ,CAAC0B,WAAD,CAAZ,EAA2B;AACzB1B,gBAAQ,CAAC0B,WAAD,CAAR,CAAsBD,SAAtB,EAAiCrB,GAAjC;AACD;AACF,KAVD;AAWD,GA1LG,CA4LJ;AACA;;;AACA,wBAAsBA,GAAtB,EAAwC/C,IAAxC,EAAoD;AAClD,QAAIA,IAAI,KAAK,YAAb,EAA2B;AACzB,aAAO,IAAP;AACD;;AAED,QAAIuE,UAAU,GAAGvE,IAAjB;AACA,QAAID,OAAO,GAAGgD,GAAG,CAAChD,OAAlB;AAEA,WAAOwE,UAAP;AACD;;AAED,SAAQ3B,SAAR;AACD;;AAWD,eAAe4B,IAAf,EAA+BR,IAA/B,EAA6D;AAC3D,QAAMS,SAAS,CAACC,MAAV,CAAiBF,IAAjB,EAAuBR,IAAvB,CAAN;AACD,C,CAED;AACA;;;AACA,IAAIW,MAAM,GAA+B;AACvC,YACE,kDACA,mCAHqC;AAIvC,kBAAgB,4BAJuB;AAKvC,mBAAiB,6CALsB;AAMvC,iBAAe,8CANwB;AAOvC,uBAAqB,qDAPkB;AAQvC,sBACE,kDACA,8DADA,GAEA,qEAFA,GAGA,aAZqC;AAavC,0BACE,sDACA;AAfqC,CAAzC;AAkBA,IAAIF,SAAS,GAAG,IAAIpF,YAAJ,CAA2B,KAA3B,EAAkC,UAAlC,EAA8CsF,MAA9C,CAAhB","names":["createSubscribe","patchProperty","deepCopy","deepExtend","ErrorFactory","contains","obj","key","Object","prototype","hasOwnProperty","call","DEFAULT_ENTRY_NAME","tokenListeners","options","name","firebase_","name_","options_","INTERNAL","getUid","getToken","resolve","addAuthTokenListener","callback","push","setTimeout","removeAuthTokenListener","filter","FirebaseAppImpl","checkDestroyed_","Promise","_this","then","removeApp","services","keys","services_","forEach","serviceKey","instanceKey","all","map","service","delete","isDeleted_","instanceIdentifier","instanceSpecifier","undefined","factories","extendApp","bind","props","listener","error","console","log","apps_","appHooks","namespace","__esModule","initializeApp","app","apps","SDK_VERSION","registerService","createFirebaseNamespace","extendNamespace","useAsService","defineProperty","get","getApps","callAppHooks","createService","serviceProperties","appHook","allowMultipleInstances","serviceNamespace","appArg","args","serviceFxn","_getService","apply","eventName","factoryName","serviceName","useService","code","appErrors","create","errors"],"sources":["dist/esm/src/firebaseApp.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createSubscribe, Observer, Subscribe } from '@firebase/util';\nimport {\n  patchProperty,\n  deepCopy,\n  deepExtend,\n  ErrorFactory,\n  FirebaseError\n} from '@firebase/util';\n\nexport interface FirebaseAuthTokenData {\n  accessToken: string;\n}\n\nexport interface FirebaseAppInternals {\n  getToken(refreshToken?: boolean): Promise<FirebaseAuthTokenData | null>;\n  getUid(): string | null;\n  addAuthTokenListener(fn: (token: string | null) => void): void;\n  removeAuthTokenListener(fn: (token: string | null) => void): void;\n}\n\nexport type FirebaseOptions = {\n  apiKey?: string;\n  authDomain?: string;\n  databaseURL?: string;\n  projectId?: string;\n  storageBucket?: string;\n  messagingSenderId?: string;\n  [name: string]: any;\n};\n\n// An instance of the firebase.App\nexport interface FirebaseApp {\n  /**\n   * The (read-only) name (identifier) for this App. '[DEFAULT]' is the default\n   * App.\n   */\n  name: string;\n\n  /**\n   * The (read-only) configuration options from the app initialization.\n   */\n  options: FirebaseOptions;\n\n  /**\n   * Make the given App unusable and free resources.\n   */\n  delete(): Promise<void>;\n\n  INTERNAL: FirebaseAppInternals;\n}\n\nexport interface FirebaseServiceInternals {\n  /**\n   * Delete the service and free it's resources - called from\n   * app.delete().\n   */\n  delete(): Promise<void>;\n}\n\n// Services are exposed through instances - each of which is associated with a\n// FirebaseApp.\nexport interface FirebaseService {\n  app: FirebaseApp;\n  INTERNAL?: FirebaseServiceInternals;\n}\n\nexport type AppHook = (event: string, app: FirebaseApp) => void;\n\n/**\n * Firebase Services create instances given a Firebase App instance and can\n * optionally add properties and methods to each FirebaseApp via the extendApp()\n * function.\n */\nexport interface FirebaseServiceFactory {\n  (\n    app: FirebaseApp,\n    extendApp?: (props: { [prop: string]: any }) => void,\n    instanceString?: string\n  ): FirebaseService;\n}\n\n/**\n * All ServiceNamespaces extend from FirebaseServiceNamespace\n */\nexport interface FirebaseServiceNamespace<T extends FirebaseService> {\n  (app?: FirebaseApp): T;\n}\n\nexport interface FirebaseErrorFactory<T> {\n  create(code: T, data?: { [prop: string]: any }): FirebaseError;\n}\n\nexport interface FirebaseErrorFactoryClass {\n  new (\n    service: string,\n    serviceName: string,\n    errors: { [code: string]: string }\n  ): FirebaseErrorFactory<any>;\n}\n\nexport interface FirebaseNamespace {\n  /**\n   * Create (and intialize) a FirebaseApp.\n   *\n   * @param options Options to configure the services use in the App.\n   * @param name The optional name of the app to initialize ('[DEFAULT]' if\n   *   none)\n   */\n  initializeApp(options: FirebaseOptions, name?: string): FirebaseApp;\n\n  app: {\n    /**\n     * Retrieve an instance of a FirebaseApp.\n     *\n     * Usage: firebase.app()\n     *\n     * @param name The optional name of the app to return ('[DEFAULT]' if none)\n     */\n    (name?: string): FirebaseApp;\n\n    /**\n     * For testing FirebaseApp instances:\n     *   app() instanceof firebase.app.App\n     * DO NOT call this constuctor directly (use firebase.app() instead).\n     */\n    App: Function;\n  };\n\n  /**\n   * A (read-only) array of all the initialized Apps.\n   */\n  apps: FirebaseApp[];\n\n  // Inherit the type information of our exported Promise implementation from\n  // es6-promises.\n  Promise: typeof Promise;\n\n  // The current SDK version ('${JSCORE_VERSION}').\n  SDK_VERSION: string;\n\n  // TODO: Migrate to firebase-app-internal.d.ts\n  INTERNAL: {\n    /**\n     * Internal API to register a Firebase Service into the firebase namespace.\n     *\n     * Each service will create a child namespace (firease.name) which acts as\n     * both a namespace for service specific properties, and also as a service\n     * accessor function (firebase.name() or firebase.name(app)).\n     *\n     * @param name The Firebase Service being registered.\n     * @param createService Factory function to create a service instance.\n     * @param serviceProperties Properties to copy to the service's namespace.\n     * @param appHook All appHooks called before intializeApp returns to caller.\n     * @param allowMultipleInstances Whether the registered service supports\n     *   multiple instances per app. If not specified, the default is false.\n     */\n    registerService(\n      name: string,\n      createService: FirebaseServiceFactory,\n      serviceProperties?: { [prop: string]: any },\n      appHook?: AppHook,\n      allowMultipleInstances?: boolean\n    ): FirebaseServiceNamespace<FirebaseService>;\n\n    /**\n     * Just used for testing to start from a fresh namespace.\n     */\n    createFirebaseNamespace(): FirebaseNamespace;\n\n    /**\n     * Internal API to install properties on the top-level firebase namespace.\n     * @prop props The top level properties of this object are copied to the\n     *   namespace.\n     */\n    extendNamespace(props: { [prop: string]: any }): void;\n\n    /**\n     * Create a Subscribe function.  A proxy Observer is created so that\n     * events can be sent to single Observer to be fanned out automatically.\n     */\n    createSubscribe<T>(\n      executor: (observer: Observer<T>) => void,\n      onNoObservers?: (observer: Observer<T>) => void\n    ): Subscribe<T>;\n\n    /**\n     * Utility exposed for internal testing.\n     */\n    deepExtend(target: any, source: any): any;\n\n    /**\n     * Internal API to remove an app from the list of registered apps.\n     */\n    removeApp(name: string): void;\n\n    /**\n     * Service factories for each registered service.\n     */\n    factories: { [name: string]: FirebaseServiceFactory };\n\n    /*\n     * Convert service name to factory name to use.\n     */\n    useAsService(app: FirebaseApp, serviceName: string): string | null;\n\n    /**\n     * Use to construct all thrown FirebaseError's.\n     */\n    ErrorFactory: FirebaseErrorFactoryClass;\n  };\n}\n\nconst contains = function(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n// An array to capture listeners before the true auth functions\n// exist\nlet tokenListeners = [];\n\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nclass FirebaseAppImpl implements FirebaseApp {\n  private options_: FirebaseOptions;\n  private name_: string;\n  private isDeleted_ = false;\n  private services_: {\n    [name: string]: {\n      [serviceName: string]: FirebaseService;\n    };\n  } = {};\n\n  public INTERNAL;\n\n  constructor(\n    options: FirebaseOptions,\n    name: string,\n    private firebase_: FirebaseNamespace\n  ) {\n    this.name_ = name;\n    this.options_ = deepCopy<FirebaseOptions>(options);\n    this.INTERNAL = {\n      getUid: () => null,\n      getToken: () => Promise.resolve(null),\n      addAuthTokenListener: (callback: (token: string | null) => void) => {\n        tokenListeners.push(callback);\n        // Make sure callback is called, asynchronously, in the absence of the auth module\n        setTimeout(() => callback(null), 0);\n      },\n      removeAuthTokenListener: callback => {\n        tokenListeners = tokenListeners.filter(\n          listener => listener !== callback\n        );\n      }\n    };\n  }\n\n  get name(): string {\n    this.checkDestroyed_();\n    return this.name_;\n  }\n\n  get options(): FirebaseOptions {\n    this.checkDestroyed_();\n    return this.options_;\n  }\n\n  delete(): Promise<void> {\n    return new Promise(resolve => {\n      this.checkDestroyed_();\n      resolve();\n    })\n      .then(() => {\n        this.firebase_.INTERNAL.removeApp(this.name_);\n        let services: FirebaseService[] = [];\n        Object.keys(this.services_).forEach(serviceKey => {\n          Object.keys(this.services_[serviceKey]).forEach(instanceKey => {\n            services.push(this.services_[serviceKey][instanceKey]);\n          });\n        });\n        return Promise.all(\n          services.map(service => {\n            return service.INTERNAL!.delete();\n          })\n        );\n      })\n      .then((): void => {\n        this.isDeleted_ = true;\n        this.services_ = {};\n      });\n  }\n\n  /**\n   * Return a service instance associated with this app (creating it\n   * on demand), identified by the passed instanceIdentifier.\n   *\n   * NOTE: Currently storage is the only one that is leveraging this\n   * functionality. They invoke it by calling:\n   *\n   * ```javascript\n   * firebase.app().storage('STORAGE BUCKET ID')\n   * ```\n   *\n   * The service name is passed to this already\n   * @internal\n   */\n  _getService(\n    name: string,\n    instanceIdentifier: string = DEFAULT_ENTRY_NAME\n  ): FirebaseService {\n    this.checkDestroyed_();\n\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\n       * then we will pass that instance on, otherwise we pass `null`\n       */\n      const instanceSpecifier =\n        instanceIdentifier !== DEFAULT_ENTRY_NAME\n          ? instanceIdentifier\n          : undefined;\n      const service = this.firebase_.INTERNAL.factories[name](\n        this,\n        this.extendApp.bind(this),\n        instanceSpecifier\n      );\n      this.services_[name][instanceIdentifier] = service;\n    }\n\n    return this.services_[name][instanceIdentifier];\n  }\n\n  /**\n   * Callback function used to extend an App instance at the time\n   * of service instance creation.\n   */\n  private extendApp(props: { [name: string]: any }): void {\n    // Copy the object onto the FirebaseAppImpl prototype\n    deepExtend(this, props);\n\n    /**\n     * If the app has overwritten the addAuthTokenListener stub, forward\n     * the active token listeners on to the true fxn.\n     *\n     * TODO: This function is required due to our current module\n     * structure. Once we are able to rely strictly upon a single module\n     * implementation, this code should be refactored and Auth should\n     * provide these stubs and the upgrade logic\n     */\n    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n      tokenListeners.forEach(listener => {\n        this.INTERNAL.addAuthTokenListener(listener);\n      });\n      tokenListeners = [];\n    }\n  }\n\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  private checkDestroyed_(): void {\n    if (this.isDeleted_) {\n      error('app-deleted', { name: this.name_ });\n    }\n  }\n}\n\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||\n  FirebaseAppImpl.prototype.delete ||\n  console.log('dc');\n\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nexport function createFirebaseNamespace(): FirebaseNamespace {\n  let apps_: { [name: string]: FirebaseApp } = {};\n  let factories: { [service: string]: FirebaseServiceFactory } = {};\n  let appHooks: { [service: string]: AppHook } = {};\n\n  // A namespace is a plain JavaScript Object.\n  let namespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    __esModule: true,\n    initializeApp: initializeApp,\n    app: app as any,\n    apps: null as any,\n    Promise: Promise,\n    SDK_VERSION: '${JSCORE_VERSION}',\n    INTERNAL: {\n      registerService: registerService,\n      createFirebaseNamespace: createFirebaseNamespace,\n      extendNamespace: extendNamespace,\n      createSubscribe: createSubscribe,\n      ErrorFactory: ErrorFactory,\n      removeApp: removeApp,\n      factories: factories,\n      useAsService: useAsService,\n      Promise: Promise,\n      deepExtend: deepExtend\n    }\n  };\n\n  // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n  patchProperty(namespace, 'default', namespace);\n\n  // firebase.apps is a read-only getter.\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n\n  /**\n   * Called by App.delete() - but before any services associated with the App\n   * are deleted.\n   */\n  function removeApp(name: string): void {\n    let app = apps_[name];\n    callAppHooks(app, 'delete');\n    delete apps_[name];\n  }\n\n  /**\n   * Get the App object for a given name (or DEFAULT).\n   */\n  function app(name?: string): FirebaseApp {\n    name = name || DEFAULT_ENTRY_NAME;\n    if (!contains(apps_, name)) {\n      error('no-app', { name: name });\n    }\n    return apps_[name];\n  }\n\n  patchProperty(app, 'App', FirebaseAppImpl);\n\n  /**\n   * Create a new App instance (name must be unique).\n   */\n  function initializeApp(options: FirebaseOptions, name?: string): FirebaseApp {\n    if (name === undefined) {\n      name = DEFAULT_ENTRY_NAME;\n    } else {\n      if (typeof name !== 'string' || name === '') {\n        error('bad-app-name', { name: name + '' });\n      }\n    }\n    if (contains(apps_, name)) {\n      error('duplicate-app', { name: name });\n    }\n\n    let app = new FirebaseAppImpl(\n      options,\n      name!,\n      namespace as FirebaseNamespace\n    );\n\n    apps_[name!] = app;\n    callAppHooks(app, 'create');\n\n    return app;\n  }\n\n  /*\n   * Return an array of all the non-deleted FirebaseApps.\n   */\n  function getApps(): FirebaseApp[] {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps_).map(name => apps_[name]);\n  }\n\n  /*\n   * Register a Firebase Service.\n   *\n   * firebase.INTERNAL.registerService()\n   *\n   * TODO: Implement serviceProperties.\n   */\n  function registerService(\n    name: string,\n    createService: FirebaseServiceFactory,\n    serviceProperties?: { [prop: string]: any },\n    appHook?: AppHook,\n    allowMultipleInstances?: boolean\n  ): FirebaseServiceNamespace<FirebaseService> {\n    // Cannot re-register a service that already exists\n    if (factories[name]) {\n      error('duplicate-service', { name: name });\n    }\n\n    // Capture the service factory for later service instantiation\n    factories[name] = createService;\n\n    // Capture the appHook, if passed\n    if (appHook) {\n      appHooks[name] = appHook;\n\n      // Run the **new** app hook on all existing apps\n      getApps().forEach(app => {\n        appHook('create', app);\n      });\n    }\n\n    // The Service namespace is an accessor function ...\n    const serviceNamespace = (appArg: FirebaseApp = app()) => {\n      if (typeof (appArg as any)[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        error('invalid-app-argument', { name: name });\n      }\n\n      // Forward service instance lookup to the FirebaseApp.\n      return (appArg as any)[name]();\n    };\n\n    // ... and a container for service-level properties.\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    }\n\n    // Monkey-patch the serviceNamespace onto the firebase namespace\n    (namespace as any)[name] = serviceNamespace;\n\n    // Patch the FirebaseAppImpl prototype\n    FirebaseAppImpl.prototype[name] = function(...args) {\n      const serviceFxn = this._getService.bind(this, name);\n      return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n    };\n\n    return serviceNamespace;\n  }\n\n  /**\n   * Patch the top-level firebase namespace with additional properties.\n   *\n   * firebase.INTERNAL.extendNamespace()\n   */\n  function extendNamespace(props: { [prop: string]: any }): void {\n    deepExtend(namespace, props);\n  }\n\n  function callAppHooks(app: FirebaseApp, eventName: string) {\n    Object.keys(factories).forEach(serviceName => {\n      // Ignore virtual services\n      let factoryName = useAsService(app, serviceName);\n      if (factoryName === null) {\n        return;\n      }\n\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    });\n  }\n\n  // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n  function useAsService(app: FirebaseApp, name: string): string | null {\n    if (name === 'serverAuth') {\n      return null;\n    }\n\n    let useService = name;\n    let options = app.options;\n\n    return useService;\n  }\n\n  return (namespace as any) as FirebaseNamespace;\n}\n\ntype AppError =\n  | 'no-app'\n  | 'bad-app-name'\n  | 'duplicate-app'\n  | 'app-deleted'\n  | 'duplicate-service'\n  | 'sa-not-supported'\n  | 'invalid-app-argument';\n\nfunction error(code: AppError, args?: { [name: string]: any }) {\n  throw appErrors.create(code, args);\n}\n\n// TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\nlet errors: { [code: string]: string } = {\n  'no-app':\n    \"No Firebase App '{$name}' has been created - \" +\n    'call Firebase App.initializeApp()',\n  'bad-app-name': \"Illegal App name: '{$name}\",\n  'duplicate-app': \"Firebase App named '{$name}' already exists\",\n  'app-deleted': \"Firebase App named '{$name}' already deleted\",\n  'duplicate-service': \"Firebase service named '{$name}' already registered\",\n  'sa-not-supported':\n    'Initializing the Firebase SDK with a service ' +\n    'account is only allowed in a Node.js environment. On client ' +\n    'devices, you should instead initialize the SDK with an api key and ' +\n    'auth domain',\n  'invalid-app-argument':\n    'firebase.{$name}() takes either no argument or a ' +\n    'Firebase App instance.'\n};\n\nlet appErrors = new ErrorFactory<AppError>('app', 'Firebase', errors);\n"]},"metadata":{},"sourceType":"module"}