{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"../util/util\");\n\nvar snap_1 = require(\"./snap\");\n\nvar __childrenNodeConstructor;\n/**\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\n * implements Node and stores the value of the node (a string,\n * number, or boolean) accessible via getValue().\n */\n\n\nvar LeafNode =\n/** @class */\nfunction () {\n  /**\n   * @implements {Node}\n   * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.\n   *                                         The object type is possible in the event of a deferred value\n   * @param {!Node=} priorityNode_ The priority of this node.\n   */\n  function LeafNode(value_, priorityNode_) {\n    if (priorityNode_ === void 0) {\n      priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n\n    this.value_ = value_;\n    this.priorityNode_ = priorityNode_;\n    this.lazyHash_ = null;\n    util_1.assert(this.value_ !== undefined && this.value_ !== null, \"LeafNode shouldn't be created with null/undefined value.\");\n    snap_1.validatePriorityNode(this.priorityNode_);\n  }\n\n  Object.defineProperty(LeafNode, \"__childrenNodeConstructor\", {\n    get: function () {\n      return __childrenNodeConstructor;\n    },\n    set: function (val) {\n      __childrenNodeConstructor = val;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @inheritDoc */\n\n  LeafNode.prototype.isLeafNode = function () {\n    return true;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.getPriority = function () {\n    return this.priorityNode_;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.updatePriority = function (newPriorityNode) {\n    return new LeafNode(this.value_, newPriorityNode);\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.getImmediateChild = function (childName) {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.getChild = function (path) {\n    if (path.isEmpty()) {\n      return this;\n    } else if (path.getFront() === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.hasChild = function () {\n    return false;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.getPredecessorChildName = function (childName, childNode) {\n    return null;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.updateImmediateChild = function (childName, newChildNode) {\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else if (newChildNode.isEmpty() && childName !== '.priority') {\n      return this;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);\n    }\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.updateChild = function (path, newChildNode) {\n    var front = path.getFront();\n\n    if (front === null) {\n      return newChildNode;\n    } else if (newChildNode.isEmpty() && front !== '.priority') {\n      return this;\n    } else {\n      util_1.assert(front !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');\n      return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(), newChildNode));\n    }\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.isEmpty = function () {\n    return false;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.numChildren = function () {\n    return 0;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.forEachChild = function (index, action) {\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.val = function (exportFormat) {\n    if (exportFormat && !this.getPriority().isEmpty()) return {\n      '.value': this.getValue(),\n      '.priority': this.getPriority().val()\n    };else return this.getValue();\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.hash = function () {\n    if (this.lazyHash_ === null) {\n      var toHash = '';\n      if (!this.priorityNode_.isEmpty()) toHash += 'priority:' + snap_1.priorityHashText(this.priorityNode_.val()) + ':';\n      var type = typeof this.value_;\n      toHash += type + ':';\n\n      if (type === 'number') {\n        toHash += util_2.doubleToIEEE754String(this.value_);\n      } else {\n        toHash += this.value_;\n      }\n\n      this.lazyHash_ = util_2.sha1(toHash);\n    }\n\n    return this.lazyHash_;\n  };\n  /**\n   * Returns the value of the leaf node.\n   * @return {Object|string|number|boolean} The value of the node.\n   */\n\n\n  LeafNode.prototype.getValue = function () {\n    return this.value_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.compareTo = function (other) {\n    if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n      return 1;\n    } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n      return -1;\n    } else {\n      util_1.assert(other.isLeafNode(), 'Unknown node type');\n      return this.compareToLeafNode_(other);\n    }\n  };\n  /**\n   * Comparison specifically for two leaf nodes\n   * @param {!LeafNode} otherLeaf\n   * @return {!number}\n   * @private\n   */\n\n\n  LeafNode.prototype.compareToLeafNode_ = function (otherLeaf) {\n    var otherLeafType = typeof otherLeaf.value_;\n    var thisLeafType = typeof this.value_;\n    var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n    var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n    util_1.assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\n    util_1.assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\n\n    if (otherIndex === thisIndex) {\n      // Same type, compare values\n      if (thisLeafType === 'object') {\n        // Deferred value nodes are all equal, but we should also never get to this point...\n        return 0;\n      } else {\n        // Note that this works because true > false, all others are number or string comparisons\n        if (this.value_ < otherLeaf.value_) {\n          return -1;\n        } else if (this.value_ === otherLeaf.value_) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n    } else {\n      return thisIndex - otherIndex;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.withIndex = function () {\n    return this;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.isIndexed = function () {\n    return true;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.equals = function (other) {\n    /**\n     * @inheritDoc\n     */\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      var otherLeaf = other;\n      return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);\n    } else {\n      return false;\n    }\n  };\n  /**\n   * The sort order for comparing leaf nodes of different types. If two leaf nodes have\n   * the same type, the comparison falls back to their value\n   * @type {Array.<!string>}\n   * @const\n   */\n\n\n  LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n  return LeafNode;\n}();\n\nexports.LeafNode = LeafNode;","map":{"version":3,"mappings":"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","names":["__childrenNodeConstructor","value_","priorityNode_","LeafNode","EMPTY_NODE","util_1","undefined","snap_1","Object","val","newPriorityNode","childName","path","isEmpty","getFront","childNode","newChildNode","updatePriority","updateImmediateChild","front","getLength","updateChild","popFront","index","action","exportFormat","getPriority","getValue","lazyHash_","toHash","type","util_2","other","isLeafNode","compareToLeafNode_","otherLeaf","otherLeafType","thisLeafType","otherIndex","VALUE_TYPE_ORDER","indexOf","thisIndex","equals","exports"],"sources":["../src/core/snap/LeafNode.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { doubleToIEEE754String, sha1 } from '../util/util';\nimport { priorityHashText, validatePriorityNode } from './snap';\nimport { Node } from './Node';\nimport { Path } from '../util/Path';\nimport { Index } from './indexes/Index';\nimport { ChildrenNodeConstructor } from './ChildrenNode';\n\nlet __childrenNodeConstructor: ChildrenNodeConstructor;\n\n/**\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\n * implements Node and stores the value of the node (a string,\n * number, or boolean) accessible via getValue().\n */\nexport class LeafNode implements Node {\n  static set __childrenNodeConstructor(val: ChildrenNodeConstructor) {\n    __childrenNodeConstructor = val;\n  }\n\n  static get __childrenNodeConstructor() {\n    return __childrenNodeConstructor;\n  }\n\n  /**\n   * The sort order for comparing leaf nodes of different types. If two leaf nodes have\n   * the same type, the comparison falls back to their value\n   * @type {Array.<!string>}\n   * @const\n   */\n  static VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n\n  private lazyHash_: string | null = null;\n\n  /**\n   * @implements {Node}\n   * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.\n   *                                         The object type is possible in the event of a deferred value\n   * @param {!Node=} priorityNode_ The priority of this node.\n   */\n  constructor(\n    private readonly value_: string | number | boolean | object,\n    private priorityNode_: Node = LeafNode.__childrenNodeConstructor.EMPTY_NODE\n  ) {\n    assert(\n      this.value_ !== undefined && this.value_ !== null,\n      \"LeafNode shouldn't be created with null/undefined value.\"\n    );\n\n    validatePriorityNode(this.priorityNode_);\n  }\n\n  /** @inheritDoc */\n  isLeafNode(): boolean {\n    return true;\n  }\n\n  /** @inheritDoc */\n  getPriority(): Node {\n    return this.priorityNode_;\n  }\n\n  /** @inheritDoc */\n  updatePriority(newPriorityNode: Node): Node {\n    return new LeafNode(this.value_, newPriorityNode);\n  }\n\n  /** @inheritDoc */\n  getImmediateChild(childName: string): Node {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  }\n\n  /** @inheritDoc */\n  getChild(path: Path): Node {\n    if (path.isEmpty()) {\n      return this;\n    } else if (path.getFront() === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasChild(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  getPredecessorChildName(childName: String, childNode: Node): null {\n    return null;\n  }\n\n  /** @inheritDoc */\n  updateImmediateChild(childName: string, newChildNode: Node): Node {\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else if (newChildNode.isEmpty() && childName !== '.priority') {\n      return this;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(\n        childName,\n        newChildNode\n      ).updatePriority(this.priorityNode_);\n    }\n  }\n\n  /** @inheritDoc */\n  updateChild(path: Path, newChildNode: Node): Node {\n    const front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else if (newChildNode.isEmpty() && front !== '.priority') {\n      return this;\n    } else {\n      assert(\n        front !== '.priority' || path.getLength() === 1,\n        '.priority must be the last token in a path'\n      );\n\n      return this.updateImmediateChild(\n        front,\n        LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(\n          path.popFront(),\n          newChildNode\n        )\n      );\n    }\n  }\n\n  /** @inheritDoc */\n  isEmpty(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  numChildren(): number {\n    return 0;\n  }\n\n  /** @inheritDoc */\n  forEachChild(index: Index, action: (s: string, n: Node) => void): any {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  val(exportFormat?: boolean): Object {\n    if (exportFormat && !this.getPriority().isEmpty())\n      return {\n        '.value': this.getValue(),\n        '.priority': this.getPriority().val()\n      };\n    else return this.getValue();\n  }\n\n  /** @inheritDoc */\n  hash(): string {\n    if (this.lazyHash_ === null) {\n      let toHash = '';\n      if (!this.priorityNode_.isEmpty())\n        toHash +=\n          'priority:' +\n          priorityHashText(this.priorityNode_.val() as number | string) +\n          ':';\n\n      const type = typeof this.value_;\n      toHash += type + ':';\n      if (type === 'number') {\n        toHash += doubleToIEEE754String(this.value_ as number);\n      } else {\n        toHash += this.value_;\n      }\n      this.lazyHash_ = sha1(toHash);\n    }\n    return this.lazyHash_;\n  }\n\n  /**\n   * Returns the value of the leaf node.\n   * @return {Object|string|number|boolean} The value of the node.\n   */\n  getValue(): object | string | number | boolean {\n    return this.value_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compareTo(other: Node): number {\n    if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n      return 1;\n    } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n      return -1;\n    } else {\n      assert(other.isLeafNode(), 'Unknown node type');\n      return this.compareToLeafNode_(other as LeafNode);\n    }\n  }\n\n  /**\n   * Comparison specifically for two leaf nodes\n   * @param {!LeafNode} otherLeaf\n   * @return {!number}\n   * @private\n   */\n  private compareToLeafNode_(otherLeaf: LeafNode): number {\n    const otherLeafType = typeof otherLeaf.value_;\n    const thisLeafType = typeof this.value_;\n    const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n    const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n    assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\n    assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\n    if (otherIndex === thisIndex) {\n      // Same type, compare values\n      if (thisLeafType === 'object') {\n        // Deferred value nodes are all equal, but we should also never get to this point...\n        return 0;\n      } else {\n        // Note that this works because true > false, all others are number or string comparisons\n        if (this.value_ < otherLeaf.value_) {\n          return -1;\n        } else if (this.value_ === otherLeaf.value_) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n    } else {\n      return thisIndex - otherIndex;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  withIndex(): Node {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isIndexed(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  equals(other: Node): boolean {\n    /**\n     * @inheritDoc\n     */\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      const otherLeaf = other as LeafNode;\n      return (\n        this.value_ === otherLeaf.value_ &&\n        this.priorityNode_.equals(otherLeaf.priorityNode_)\n      );\n    } else {\n      return false;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}