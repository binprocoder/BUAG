{"ast":null,"code":"/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * @fileoverview Defines types for interacting with blob transfer tasks.\r\n */\nimport { InternalTaskState } from './implementation/taskenums';\nimport { Observer } from './implementation/observer';\nimport { TaskEvent, TaskState } from './implementation/taskenums';\nimport { UploadTaskSnapshot } from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport { async as fbsAsync } from './implementation/async';\nimport * as errors from './implementation/error';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\n/**\r\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\r\n * upload and manage callbacks for various events.\r\n */\n\nvar UploadTask =\n/** @class */\nfunction () {\n  /**\r\n   * @param ref The firebaseStorage.Reference object this task came\r\n   *     from, untyped to avoid cyclic dependencies.\r\n   * @param blob The blob to upload.\r\n   */\n  function UploadTask(ref, authWrapper, location, mappings, blob, metadata) {\n    if (metadata === void 0) {\n      metadata = null;\n    }\n\n    var _this = this;\n\n    this.transferred_ = 0;\n    this.needToFetchStatus_ = false;\n    this.needToFetchMetadata_ = false;\n    this.observers_ = [];\n    this.error_ = null;\n    this.uploadUrl_ = null;\n    this.request_ = null;\n    this.chunkMultiplier_ = 1;\n    this.resolve_ = null;\n    this.reject_ = null;\n    this.ref_ = ref;\n    this.authWrapper_ = authWrapper;\n    this.location_ = location;\n    this.blob_ = blob;\n    this.metadata_ = metadata;\n    this.mappings_ = mappings;\n    this.resumable_ = this.shouldDoResumable_(this.blob_);\n    this.state_ = InternalTaskState.RUNNING;\n\n    this.errorHandler_ = function (error) {\n      _this.request_ = null;\n      _this.chunkMultiplier_ = 1;\n\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        _this.needToFetchStatus_ = true;\n\n        _this.completeTransitions_();\n      } else {\n        _this.error_ = error;\n\n        _this.transition_(InternalTaskState.ERROR);\n      }\n    };\n\n    this.metadataErrorHandler_ = function (error) {\n      _this.request_ = null;\n\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        _this.completeTransitions_();\n      } else {\n        _this.error_ = error;\n\n        _this.transition_(InternalTaskState.ERROR);\n      }\n    };\n\n    this.promise_ = fbsPromiseimpl.make(function (resolve, reject) {\n      _this.resolve_ = resolve;\n      _this.reject_ = reject;\n\n      _this.start_();\n    }); // Prevent uncaught rejections on the internal promise from bubbling out\n    // to the top level with a dummy handler.\n\n    this.promise_.then(null, function () {});\n  }\n\n  UploadTask.prototype.makeProgressCallback_ = function () {\n    var _this = this;\n\n    var sizeBefore = this.transferred_;\n    return function (loaded, total) {\n      _this.updateProgress_(sizeBefore + loaded);\n    };\n  };\n\n  UploadTask.prototype.shouldDoResumable_ = function (blob) {\n    return blob.size() > 256 * 1024;\n  };\n\n  UploadTask.prototype.start_ = function () {\n    if (this.state_ !== InternalTaskState.RUNNING) {\n      // This can happen if someone pauses us in a resume callback, for example.\n      return;\n    }\n\n    if (this.request_ !== null) {\n      return;\n    }\n\n    if (this.resumable_) {\n      if (this.uploadUrl_ === null) {\n        this.createResumable_();\n      } else {\n        if (this.needToFetchStatus_) {\n          this.fetchStatus_();\n        } else {\n          if (this.needToFetchMetadata_) {\n            // Happens if we miss the metadata on upload completion.\n            this.fetchMetadata_();\n          } else {\n            this.continueUpload_();\n          }\n        }\n      }\n    } else {\n      this.oneShotUpload_();\n    }\n  };\n\n  UploadTask.prototype.resolveToken_ = function (callback) {\n    var _this = this;\n\n    this.authWrapper_.getAuthToken().then(function (authToken) {\n      switch (_this.state_) {\n        case InternalTaskState.RUNNING:\n          callback(authToken);\n          break;\n\n        case InternalTaskState.CANCELING:\n          _this.transition_(InternalTaskState.CANCELED);\n\n          break;\n\n        case InternalTaskState.PAUSING:\n          _this.transition_(InternalTaskState.PAUSED);\n\n          break;\n\n        default:\n      }\n    });\n  }; // TODO(andysoto): assert false\n\n\n  UploadTask.prototype.createResumable_ = function () {\n    var _this = this;\n\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.createResumableUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);\n\n      var createRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n\n      _this.request_ = createRequest;\n      createRequest.getPromise().then(function (url) {\n        _this.request_ = null;\n        _this.uploadUrl_ = url;\n        _this.needToFetchStatus_ = false;\n\n        _this.completeTransitions_();\n      }, _this.errorHandler_);\n    });\n  };\n\n  UploadTask.prototype.fetchStatus_ = function () {\n    var _this = this; // TODO(andysoto): assert(this.uploadUrl_ !== null);\n\n\n    var url = this.uploadUrl_;\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.getResumableUploadStatus(_this.authWrapper_, _this.location_, url, _this.blob_);\n\n      var statusRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n\n      _this.request_ = statusRequest;\n      statusRequest.getPromise().then(function (status) {\n        status = status;\n        _this.request_ = null;\n\n        _this.updateProgress_(status.current);\n\n        _this.needToFetchStatus_ = false;\n\n        if (status.finalized) {\n          _this.needToFetchMetadata_ = true;\n        }\n\n        _this.completeTransitions_();\n      }, _this.errorHandler_);\n    });\n  };\n\n  UploadTask.prototype.continueUpload_ = function () {\n    var _this = this;\n\n    var chunkSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n    var status = new fbsRequests.ResumableUploadStatus(this.transferred_, this.blob_.size()); // TODO(andysoto): assert(this.uploadUrl_ !== null);\n\n    var url = this.uploadUrl_;\n    this.resolveToken_(function (authToken) {\n      var requestInfo;\n\n      try {\n        requestInfo = fbsRequests.continueResumableUpload(_this.location_, _this.authWrapper_, url, _this.blob_, chunkSize, _this.mappings_, status, _this.makeProgressCallback_());\n      } catch (e) {\n        _this.error_ = e;\n\n        _this.transition_(InternalTaskState.ERROR);\n\n        return;\n      }\n\n      var uploadRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n\n      _this.request_ = uploadRequest;\n      uploadRequest.getPromise().then(function (newStatus) {\n        _this.increaseMultiplier_();\n\n        _this.request_ = null;\n\n        _this.updateProgress_(newStatus.current);\n\n        if (newStatus.finalized) {\n          _this.metadata_ = newStatus.metadata;\n\n          _this.transition_(InternalTaskState.SUCCESS);\n        } else {\n          _this.completeTransitions_();\n        }\n      }, _this.errorHandler_);\n    });\n  };\n\n  UploadTask.prototype.increaseMultiplier_ = function () {\n    var currentSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_; // Max chunk size is 32M.\n\n    if (currentSize < 32 * 1024 * 1024) {\n      this.chunkMultiplier_ *= 2;\n    }\n  };\n\n  UploadTask.prototype.fetchMetadata_ = function () {\n    var _this = this;\n\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.getMetadata(_this.authWrapper_, _this.location_, _this.mappings_);\n\n      var metadataRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n\n      _this.request_ = metadataRequest;\n      metadataRequest.getPromise().then(function (metadata) {\n        _this.request_ = null;\n        _this.metadata_ = metadata;\n\n        _this.transition_(InternalTaskState.SUCCESS);\n      }, _this.metadataErrorHandler_);\n    });\n  };\n\n  UploadTask.prototype.oneShotUpload_ = function () {\n    var _this = this;\n\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.multipartUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);\n\n      var multipartRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n\n      _this.request_ = multipartRequest;\n      multipartRequest.getPromise().then(function (metadata) {\n        _this.request_ = null;\n        _this.metadata_ = metadata;\n\n        _this.updateProgress_(_this.blob_.size());\n\n        _this.transition_(InternalTaskState.SUCCESS);\n      }, _this.errorHandler_);\n    });\n  };\n\n  UploadTask.prototype.updateProgress_ = function (transferred) {\n    var old = this.transferred_;\n    this.transferred_ = transferred; // A progress update can make the \"transferred\" value smaller (e.g. a\n    // partial upload not completed by server, after which the \"transferred\"\n    // value may reset to the value at the beginning of the request).\n\n    if (this.transferred_ !== old) {\n      this.notifyObservers_();\n    }\n  };\n\n  UploadTask.prototype.transition_ = function (state) {\n    if (this.state_ === state) {\n      return;\n    }\n\n    switch (state) {\n      case InternalTaskState.CANCELING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n\n        break;\n\n      case InternalTaskState.PAUSING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING);\n        this.state_ = state;\n\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n\n        break;\n\n      case InternalTaskState.RUNNING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        var wasPaused = this.state_ === InternalTaskState.PAUSED;\n        this.state_ = state;\n\n        if (wasPaused) {\n          this.notifyObservers_();\n          this.start_();\n        }\n\n        break;\n\n      case InternalTaskState.PAUSED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n\n      case InternalTaskState.CANCELED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.error_ = errors.canceled();\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n\n      case InternalTaskState.ERROR:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n\n      case InternalTaskState.SUCCESS:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n    }\n  };\n\n  UploadTask.prototype.completeTransitions_ = function () {\n    switch (this.state_) {\n      case InternalTaskState.PAUSING:\n        this.transition_(InternalTaskState.PAUSED);\n        break;\n\n      case InternalTaskState.CANCELING:\n        this.transition_(InternalTaskState.CANCELED);\n        break;\n\n      case InternalTaskState.RUNNING:\n        this.start_();\n        break;\n\n      default:\n        // TODO(andysoto): assert(false);\n        break;\n    }\n  };\n\n  Object.defineProperty(UploadTask.prototype, \"snapshot\", {\n    get: function () {\n      var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n      return new UploadTaskSnapshot(this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adds a callback for an event.\r\n   * @param type The type of event to listen for.\r\n   */\n\n  UploadTask.prototype.on = function (type, nextOrObserver, error, completed) {\n    if (nextOrObserver === void 0) {\n      nextOrObserver = undefined;\n    }\n\n    if (error === void 0) {\n      error = undefined;\n    }\n\n    if (completed === void 0) {\n      completed = undefined;\n    }\n\n    function typeValidator(_p) {\n      if (type !== TaskEvent.STATE_CHANGED) {\n        throw \"Expected one of the event types: [\" + TaskEvent.STATE_CHANGED + \"].\";\n      }\n    }\n\n    var nextOrObserverMessage = 'Expected a function or an Object with one of ' + '`next`, `error`, `complete` properties.';\n    var nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n    var observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n\n    function nextOrObserverValidator(p) {\n      try {\n        nextValidator(p);\n        return;\n      } catch (e) {}\n\n      try {\n        observerValidator(p);\n        var anyDefined = typeUtils.isJustDef(p['next']) || typeUtils.isJustDef(p['error']) || typeUtils.isJustDef(p['complete']);\n\n        if (!anyDefined) {\n          throw '';\n        }\n\n        return;\n      } catch (e) {\n        throw nextOrObserverMessage;\n      }\n    }\n\n    var specs = [fbsArgs.stringSpec(typeValidator), fbsArgs.looseObjectSpec(nextOrObserverValidator, true), fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)];\n    fbsArgs.validate('on', specs, arguments);\n    var self = this;\n\n    function makeBinder(specs) {\n      function binder(nextOrObserver, error, opt_complete) {\n        if (specs !== null) {\n          fbsArgs.validate('on', specs, arguments);\n        }\n\n        var observer = new Observer(nextOrObserver, error, completed);\n        self.addObserver_(observer);\n        return function () {\n          self.removeObserver_(observer);\n        };\n      }\n\n      return binder;\n    }\n\n    function binderNextOrObserverValidator(p) {\n      if (p === null) {\n        throw nextOrObserverMessage;\n      }\n\n      nextOrObserverValidator(p);\n    }\n\n    var binderSpecs = [fbsArgs.looseObjectSpec(binderNextOrObserverValidator), fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)];\n    var typeOnly = !(typeUtils.isJustDef(nextOrObserver) || typeUtils.isJustDef(error) || typeUtils.isJustDef(completed));\n\n    if (typeOnly) {\n      return makeBinder(binderSpecs);\n    } else {\n      return makeBinder(null)(nextOrObserver, error, completed);\n    }\n  };\n  /**\r\n   * This object behaves like a Promise, and resolves with its snapshot data\r\n   * when the upload completes.\r\n   * @param onFulfilled The fulfillment callback. Promise chaining works as normal.\r\n   * @param onRejected The rejection callback.\r\n   */\n\n\n  UploadTask.prototype.then = function (onFulfilled, onRejected) {\n    // These casts are needed so that TypeScript can infer the types of the\n    // resulting Promise.\n    return this.promise_.then(onFulfilled, onRejected);\n  };\n  /**\r\n   * Equivalent to calling `then(null, onRejected)`.\r\n   */\n\n\n  UploadTask.prototype.catch = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n  /**\r\n   * Adds the given observer.\r\n   */\n\n\n  UploadTask.prototype.addObserver_ = function (observer) {\n    this.observers_.push(observer);\n    this.notifyObserver_(observer);\n  };\n  /**\r\n   * Removes the given observer.\r\n   */\n\n\n  UploadTask.prototype.removeObserver_ = function (observer) {\n    fbsArray.remove(this.observers_, observer);\n  };\n\n  UploadTask.prototype.notifyObservers_ = function () {\n    var _this = this;\n\n    this.finishPromise_();\n    var observers = fbsArray.clone(this.observers_);\n    observers.forEach(function (observer) {\n      _this.notifyObserver_(observer);\n    });\n  };\n\n  UploadTask.prototype.finishPromise_ = function () {\n    if (this.resolve_ !== null) {\n      var triggered = true;\n\n      switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n        case TaskState.SUCCESS:\n          fbsAsync(this.resolve_.bind(null, this.snapshot))();\n          break;\n\n        case TaskState.CANCELED:\n        case TaskState.ERROR:\n          var toCall = this.reject_;\n          fbsAsync(toCall.bind(null, this.error_))();\n          break;\n\n        default:\n          triggered = false;\n          break;\n      }\n\n      if (triggered) {\n        this.resolve_ = null;\n        this.reject_ = null;\n      }\n    }\n  };\n\n  UploadTask.prototype.notifyObserver_ = function (observer) {\n    var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n\n    switch (externalState) {\n      case TaskState.RUNNING:\n      case TaskState.PAUSED:\n        if (observer.next !== null) {\n          fbsAsync(observer.next.bind(observer, this.snapshot))();\n        }\n\n        break;\n\n      case TaskState.SUCCESS:\n        if (observer.complete !== null) {\n          fbsAsync(observer.complete.bind(observer))();\n        }\n\n        break;\n\n      case TaskState.CANCELED:\n      case TaskState.ERROR:\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_))();\n        }\n\n        break;\n\n      default:\n        // TODO(andysoto): assert(false);\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_))();\n        }\n\n    }\n  };\n  /**\r\n   * Resumes a paused task. Has no effect on a currently running or failed task.\r\n   * @return True if the operation took effect, false if ignored.\r\n   */\n\n\n  UploadTask.prototype.resume = function () {\n    fbsArgs.validate('resume', [], arguments);\n    var valid = this.state_ === InternalTaskState.PAUSED || this.state_ === InternalTaskState.PAUSING;\n\n    if (valid) {\n      this.transition_(InternalTaskState.RUNNING);\n    }\n\n    return valid;\n  };\n  /**\r\n   * Pauses a currently running task. Has no effect on a paused or failed task.\r\n   * @return True if the operation took effect, false if ignored.\r\n   */\n\n\n  UploadTask.prototype.pause = function () {\n    fbsArgs.validate('pause', [], arguments);\n    var valid = this.state_ === InternalTaskState.RUNNING;\n\n    if (valid) {\n      this.transition_(InternalTaskState.PAUSING);\n    }\n\n    return valid;\n  };\n  /**\r\n   * Cancels a currently running or paused task. Has no effect on a complete or\r\n   * failed task.\r\n   * @return True if the operation took effect, false if ignored.\r\n   */\n\n\n  UploadTask.prototype.cancel = function () {\n    fbsArgs.validate('cancel', [], arguments);\n    var valid = this.state_ === InternalTaskState.RUNNING || this.state_ === InternalTaskState.PAUSING;\n\n    if (valid) {\n      this.transition_(InternalTaskState.CANCELING);\n    }\n\n    return valid;\n  };\n\n  return UploadTask;\n}();\n\nexport { UploadTask };","map":{"version":3,"mappings":"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","names":["InternalTaskState","Observer","TaskEvent","TaskState","UploadTaskSnapshot","fbsArgs","fbsArray","async","fbsAsync","errors","fbsPromiseimpl","fbsRequests","fbsTaskEnums","typeUtils","ref","authWrapper","location","mappings","blob","metadata","ref_","authWrapper_","location_","blob_","metadata_","mappings_","resumable_","shouldDoResumable_","state_","RUNNING","errorHandler_","_this","request_","chunkMultiplier_","error","codeEquals","Code","CANCELED","needToFetchStatus_","completeTransitions_","error_","transition_","ERROR","metadataErrorHandler_","promise_","make","resolve","reject","resolve_","reject_","start_","then","UploadTask","sizeBefore","transferred_","loaded","total","updateProgress_","size","uploadUrl_","createResumable_","fetchStatus_","needToFetchMetadata_","fetchMetadata_","continueUpload_","oneShotUpload_","callback","getAuthToken","authToken","CANCELING","PAUSING","PAUSED","resolveToken_","requestInfo","createResumableUpload","createRequest","makeRequest","getPromise","url","getResumableUploadStatus","statusRequest","status","current","finalized","chunkSize","resumableUploadChunkSize","ResumableUploadStatus","continueResumableUpload","makeProgressCallback_","e","uploadRequest","newStatus","increaseMultiplier_","SUCCESS","currentSize","getMetadata","metadataRequest","multipartUpload","multipartRequest","transferred","old","notifyObservers_","state","cancel","wasPaused","canceled","Object","externalState","taskStateFromInternalTaskState","type","nextOrObserver","completed","_p","STATE_CHANGED","nextOrObserverMessage","nextValidator","nullFunctionSpec","validator","observerValidator","looseObjectSpec","p","anyDefined","isJustDef","specs","stringSpec","typeValidator","nextOrObserverValidator","validate","arguments","self","opt_complete","observer","addObserver_","removeObserver_","binder","binderSpecs","binderNextOrObserverValidator","typeOnly","makeBinder","onFulfilled","onRejected","observers_","push","notifyObserver_","remove","finishPromise_","observers","clone","forEach","triggered","bind","snapshot","toCall","next","complete","valid"],"sources":["../src/task.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\n\nimport { AuthWrapper } from './implementation/authwrapper';\nimport { FbsBlob } from './implementation/blob';\nimport { FirebaseStorageError } from './implementation/error';\nimport { InternalTaskState } from './implementation/taskenums';\nimport { Metadata } from './metadata';\nimport {\n  NextFn,\n  ErrorFn,\n  CompleteFn,\n  Unsubscribe,\n  Observer\n} from './implementation/observer';\nimport { Request } from './implementation/request';\nimport * as RequestExports from './implementation/request';\nimport { Subscribe } from './implementation/observer';\nimport { TaskEvent, TaskState } from './implementation/taskenums';\nimport { UploadTaskSnapshot } from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport { ArgSpec } from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport { async as fbsAsync } from './implementation/async';\nimport { errors as fbsErrors } from './implementation/error';\nimport * as errors from './implementation/error';\nimport { Location } from './implementation/location';\nimport * as fbsMetadata from './implementation/metadata';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport { RequestInfo } from './implementation/requestinfo';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\nimport { Reference } from './reference';\n\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\nexport class UploadTask {\n  private ref_: Reference;\n  private authWrapper_: AuthWrapper;\n  private location_: Location;\n  private blob_: FbsBlob;\n  private metadata_: Metadata | null;\n  private mappings_: fbsMetadata.Mappings;\n  private transferred_: number = 0;\n  private needToFetchStatus_: boolean = false;\n  private needToFetchMetadata_: boolean = false;\n  private observers_: Observer<UploadTaskSnapshot>[] = [];\n  private resumable_: boolean;\n  private state_: InternalTaskState;\n  private error_: Error | null = null;\n  private uploadUrl_: string | null = null;\n  private request_: Request<any> | null = null;\n  private chunkMultiplier_: number = 1;\n  private errorHandler_: (p1: FirebaseStorageError) => void;\n  private metadataErrorHandler_: (p1: FirebaseStorageError) => void;\n  private resolve_: ((p1: UploadTaskSnapshot) => void) | null = null;\n  private reject_: ((p1: Error) => void) | null = null;\n  private promise_: Promise<UploadTaskSnapshot>;\n\n  /**\n   * @param ref The firebaseStorage.Reference object this task came\n   *     from, untyped to avoid cyclic dependencies.\n   * @param blob The blob to upload.\n   */\n  constructor(\n    ref: Reference,\n    authWrapper: AuthWrapper,\n    location: Location,\n    mappings: fbsMetadata.Mappings,\n    blob: FbsBlob,\n    metadata: Metadata | null = null\n  ) {\n    this.ref_ = ref;\n    this.authWrapper_ = authWrapper;\n    this.location_ = location;\n    this.blob_ = blob;\n    this.metadata_ = metadata;\n    this.mappings_ = mappings;\n    this.resumable_ = this.shouldDoResumable_(this.blob_);\n    this.state_ = InternalTaskState.RUNNING;\n    this.errorHandler_ = error => {\n      this.request_ = null;\n      this.chunkMultiplier_ = 1;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.needToFetchStatus_ = true;\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.metadataErrorHandler_ = error => {\n      this.request_ = null;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.promise_ = fbsPromiseimpl.make((resolve, reject) => {\n      this.resolve_ = resolve;\n      this.reject_ = reject;\n      this.start_();\n    });\n\n    // Prevent uncaught rejections on the internal promise from bubbling out\n    // to the top level with a dummy handler.\n    this.promise_.then(null, () => {});\n  }\n\n  private makeProgressCallback_(): (p1: number, p2: number) => void {\n    const sizeBefore = this.transferred_;\n    return (loaded, total) => {\n      this.updateProgress_(sizeBefore + loaded);\n    };\n  }\n\n  private shouldDoResumable_(blob: FbsBlob): boolean {\n    return blob.size() > 256 * 1024;\n  }\n\n  private start_() {\n    if (this.state_ !== InternalTaskState.RUNNING) {\n      // This can happen if someone pauses us in a resume callback, for example.\n      return;\n    }\n    if (this.request_ !== null) {\n      return;\n    }\n    if (this.resumable_) {\n      if (this.uploadUrl_ === null) {\n        this.createResumable_();\n      } else {\n        if (this.needToFetchStatus_) {\n          this.fetchStatus_();\n        } else {\n          if (this.needToFetchMetadata_) {\n            // Happens if we miss the metadata on upload completion.\n            this.fetchMetadata_();\n          } else {\n            this.continueUpload_();\n          }\n        }\n      }\n    } else {\n      this.oneShotUpload_();\n    }\n  }\n\n  private resolveToken_(callback: (p1: string | null) => void) {\n    this.authWrapper_.getAuthToken().then(authToken => {\n      switch (this.state_) {\n        case InternalTaskState.RUNNING:\n          callback(authToken);\n          break;\n        case InternalTaskState.CANCELING:\n          this.transition_(InternalTaskState.CANCELED);\n          break;\n        case InternalTaskState.PAUSING:\n          this.transition_(InternalTaskState.PAUSED);\n          break;\n        default:\n      }\n    });\n  }\n\n  // TODO(andysoto): assert false\n\n  private createResumable_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.createResumableUpload(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_,\n        this.blob_,\n        this.metadata_\n      );\n      const createRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = createRequest;\n      createRequest.getPromise().then((url: string) => {\n        this.request_ = null;\n        this.uploadUrl_ = url;\n        this.needToFetchStatus_ = false;\n        this.completeTransitions_();\n      }, this.errorHandler_);\n    });\n  }\n\n  private fetchStatus_() {\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = this.uploadUrl_ as string;\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.getResumableUploadStatus(\n        this.authWrapper_,\n        this.location_,\n        url,\n        this.blob_\n      );\n      const statusRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = statusRequest;\n      statusRequest.getPromise().then(status => {\n        status = status as fbsRequests.ResumableUploadStatus;\n        this.request_ = null;\n        this.updateProgress_(status.current);\n        this.needToFetchStatus_ = false;\n        if (status.finalized) {\n          this.needToFetchMetadata_ = true;\n        }\n        this.completeTransitions_();\n      }, this.errorHandler_);\n    });\n  }\n\n  private continueUpload_() {\n    const chunkSize =\n      fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n    const status = new fbsRequests.ResumableUploadStatus(\n      this.transferred_,\n      this.blob_.size()\n    );\n\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = this.uploadUrl_ as string;\n    this.resolveToken_(authToken => {\n      let requestInfo;\n      try {\n        requestInfo = fbsRequests.continueResumableUpload(\n          this.location_,\n          this.authWrapper_,\n          url,\n          this.blob_,\n          chunkSize,\n          this.mappings_,\n          status,\n          this.makeProgressCallback_()\n        );\n      } catch (e) {\n        this.error_ = e;\n        this.transition_(InternalTaskState.ERROR);\n        return;\n      }\n      const uploadRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = uploadRequest;\n      uploadRequest\n        .getPromise()\n        .then((newStatus: fbsRequests.ResumableUploadStatus) => {\n          this.increaseMultiplier_();\n          this.request_ = null;\n          this.updateProgress_(newStatus.current);\n          if (newStatus.finalized) {\n            this.metadata_ = newStatus.metadata;\n            this.transition_(InternalTaskState.SUCCESS);\n          } else {\n            this.completeTransitions_();\n          }\n        }, this.errorHandler_);\n    });\n  }\n\n  private increaseMultiplier_() {\n    const currentSize =\n      fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n\n    // Max chunk size is 32M.\n    if (currentSize < 32 * 1024 * 1024) {\n      this.chunkMultiplier_ *= 2;\n    }\n  }\n\n  private fetchMetadata_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.getMetadata(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_\n      );\n      const metadataRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = metadataRequest;\n      metadataRequest.getPromise().then(metadata => {\n        this.request_ = null;\n        this.metadata_ = metadata;\n        this.transition_(InternalTaskState.SUCCESS);\n      }, this.metadataErrorHandler_);\n    });\n  }\n\n  private oneShotUpload_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.multipartUpload(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_,\n        this.blob_,\n        this.metadata_\n      );\n      const multipartRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = multipartRequest;\n      multipartRequest.getPromise().then(metadata => {\n        this.request_ = null;\n        this.metadata_ = metadata;\n        this.updateProgress_(this.blob_.size());\n        this.transition_(InternalTaskState.SUCCESS);\n      }, this.errorHandler_);\n    });\n  }\n\n  private updateProgress_(transferred: number) {\n    const old = this.transferred_;\n    this.transferred_ = transferred;\n\n    // A progress update can make the \"transferred\" value smaller (e.g. a\n    // partial upload not completed by server, after which the \"transferred\"\n    // value may reset to the value at the beginning of the request).\n    if (this.transferred_ !== old) {\n      this.notifyObservers_();\n    }\n  }\n\n  private transition_(state: InternalTaskState) {\n    if (this.state_ === state) {\n      return;\n    }\n    switch (state) {\n      case InternalTaskState.CANCELING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.PAUSING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.RUNNING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        const wasPaused = this.state_ === InternalTaskState.PAUSED;\n        this.state_ = state;\n        if (wasPaused) {\n          this.notifyObservers_();\n          this.start_();\n        }\n        break;\n      case InternalTaskState.PAUSED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.CANCELED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.error_ = errors.canceled();\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.ERROR:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.SUCCESS:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n    }\n  }\n\n  private completeTransitions_() {\n    switch (this.state_) {\n      case InternalTaskState.PAUSING:\n        this.transition_(InternalTaskState.PAUSED);\n        break;\n      case InternalTaskState.CANCELING:\n        this.transition_(InternalTaskState.CANCELED);\n        break;\n      case InternalTaskState.RUNNING:\n        this.start_();\n        break;\n      default:\n        // TODO(andysoto): assert(false);\n        break;\n    }\n  }\n\n  get snapshot(): UploadTaskSnapshot {\n    const externalState = fbsTaskEnums.taskStateFromInternalTaskState(\n      this.state_\n    );\n    return new UploadTaskSnapshot(\n      this.transferred_,\n      this.blob_.size(),\n      externalState,\n      this.metadata_,\n      this,\n      this.ref_\n    );\n  }\n\n  /**\n   * Adds a callback for an event.\n   * @param type The type of event to listen for.\n   */\n  on(\n    type: TaskEvent,\n    nextOrObserver = undefined,\n    error = undefined,\n    completed = undefined\n  ): Unsubscribe | Subscribe<UploadTaskSnapshot> {\n    function typeValidator(_p: any) {\n      if (type !== TaskEvent.STATE_CHANGED) {\n        throw `Expected one of the event types: [${TaskEvent.STATE_CHANGED}].`;\n      }\n    }\n    const nextOrObserverMessage =\n      'Expected a function or an Object with one of ' +\n      '`next`, `error`, `complete` properties.';\n    const nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n    const observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n\n    function nextOrObserverValidator(p: any) {\n      try {\n        nextValidator(p);\n        return;\n      } catch (e) {}\n      try {\n        observerValidator(p);\n        const anyDefined =\n          typeUtils.isJustDef(p['next']) ||\n          typeUtils.isJustDef(p['error']) ||\n          typeUtils.isJustDef(p['complete']);\n        if (!anyDefined) {\n          throw '';\n        }\n        return;\n      } catch (e) {\n        throw nextOrObserverMessage;\n      }\n    }\n    const specs = [\n      fbsArgs.stringSpec(typeValidator),\n      fbsArgs.looseObjectSpec(nextOrObserverValidator, true),\n      fbsArgs.nullFunctionSpec(true),\n      fbsArgs.nullFunctionSpec(true)\n    ];\n    fbsArgs.validate('on', specs, arguments);\n    const self = this;\n\n    function makeBinder(\n      specs: ArgSpec[] | null\n    ): Subscribe<UploadTaskSnapshot> {\n      function binder(\n        nextOrObserver:\n          | NextFn<UploadTaskSnapshot>\n          | { [name: string]: string | null }\n          | null,\n        error?: ErrorFn | null,\n        opt_complete?: CompleteFn | null\n      ) {\n        if (specs !== null) {\n          fbsArgs.validate('on', specs, arguments);\n        }\n        const observer = new Observer(nextOrObserver, error, completed);\n        self.addObserver_(observer);\n        return () => {\n          self.removeObserver_(observer);\n        };\n      }\n      return binder;\n    }\n\n    function binderNextOrObserverValidator(p: any) {\n      if (p === null) {\n        throw nextOrObserverMessage;\n      }\n      nextOrObserverValidator(p);\n    }\n    const binderSpecs = [\n      fbsArgs.looseObjectSpec(binderNextOrObserverValidator),\n      fbsArgs.nullFunctionSpec(true),\n      fbsArgs.nullFunctionSpec(true)\n    ];\n    const typeOnly = !(\n      typeUtils.isJustDef(nextOrObserver) ||\n      typeUtils.isJustDef(error) ||\n      typeUtils.isJustDef(completed)\n    );\n    if (typeOnly) {\n      return makeBinder(binderSpecs);\n    } else {\n      return makeBinder(null)(nextOrObserver, error, completed);\n    }\n  }\n\n  /**\n   * This object behaves like a Promise, and resolves with its snapshot data\n   * when the upload completes.\n   * @param onFulfilled The fulfillment callback. Promise chaining works as normal.\n   * @param onRejected The rejection callback.\n   */\n  then<U>(\n    onFulfilled?: ((value: UploadTaskSnapshot) => U | Promise<U>) | null,\n    onRejected?: ((error: any) => U | Promise<U>) | null\n  ): Promise<U> {\n    // These casts are needed so that TypeScript can infer the types of the\n    // resulting Promise.\n    return this.promise_.then<U>(\n      onFulfilled as (value: UploadTaskSnapshot) => U | Promise<U>,\n      onRejected as ((error: any) => Promise<never>) | null\n    );\n  }\n\n  /**\n   * Equivalent to calling `then(null, onRejected)`.\n   */\n  catch<T>(onRejected: (p1: Error) => T | Promise<T>): Promise<T> {\n    return this.then(null, onRejected);\n  }\n\n  /**\n   * Adds the given observer.\n   */\n  private addObserver_(observer: Observer<UploadTaskSnapshot>) {\n    this.observers_.push(observer);\n    this.notifyObserver_(observer);\n  }\n\n  /**\n   * Removes the given observer.\n   */\n  private removeObserver_(observer: Observer<UploadTaskSnapshot>) {\n    fbsArray.remove(this.observers_, observer);\n  }\n\n  private notifyObservers_() {\n    this.finishPromise_();\n    const observers = fbsArray.clone(this.observers_);\n    observers.forEach(observer => {\n      this.notifyObserver_(observer);\n    });\n  }\n\n  private finishPromise_() {\n    if (this.resolve_ !== null) {\n      let triggered = true;\n      switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n        case TaskState.SUCCESS:\n          fbsAsync(this.resolve_.bind(null, this.snapshot))();\n          break;\n        case TaskState.CANCELED:\n        case TaskState.ERROR:\n          const toCall = this.reject_ as ((p1: Error) => void);\n          fbsAsync(toCall.bind(null, this.error_ as Error))();\n          break;\n        default:\n          triggered = false;\n          break;\n      }\n      if (triggered) {\n        this.resolve_ = null;\n        this.reject_ = null;\n      }\n    }\n  }\n\n  private notifyObserver_(observer: Observer<UploadTaskSnapshot>) {\n    const externalState = fbsTaskEnums.taskStateFromInternalTaskState(\n      this.state_\n    );\n    switch (externalState) {\n      case TaskState.RUNNING:\n      case TaskState.PAUSED:\n        if (observer.next !== null) {\n          fbsAsync(observer.next.bind(observer, this.snapshot))();\n        }\n        break;\n      case TaskState.SUCCESS:\n        if (observer.complete !== null) {\n          fbsAsync(observer.complete.bind(observer))();\n        }\n        break;\n      case TaskState.CANCELED:\n      case TaskState.ERROR:\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_ as Error))();\n        }\n        break;\n      default:\n        // TODO(andysoto): assert(false);\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_ as Error))();\n        }\n    }\n  }\n\n  /**\n   * Resumes a paused task. Has no effect on a currently running or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  resume(): boolean {\n    fbsArgs.validate('resume', [], arguments);\n    const valid =\n      this.state_ === InternalTaskState.PAUSED ||\n      this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.RUNNING);\n    }\n    return valid;\n  }\n\n  /**\n   * Pauses a currently running task. Has no effect on a paused or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  pause(): boolean {\n    fbsArgs.validate('pause', [], arguments);\n    const valid = this.state_ === InternalTaskState.RUNNING;\n    if (valid) {\n      this.transition_(InternalTaskState.PAUSING);\n    }\n    return valid;\n  }\n\n  /**\n   * Cancels a currently running or paused task. Has no effect on a complete or\n   * failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  cancel(): boolean {\n    fbsArgs.validate('cancel', [], arguments);\n    const valid =\n      this.state_ === InternalTaskState.RUNNING ||\n      this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.CANCELING);\n    }\n    return valid;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}