{"ast":null,"code":"/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * @file Provides a Blob-like wrapper for various binary types (including the\r\n * native Blob type). This makes it possible to upload types like ArrayBuffers,\r\n * making uploads possible in environments without the native Blob type.\r\n */\nimport * as fs from './fs';\nimport * as string from './string';\nimport { StringFormat } from './string';\nimport * as type from './type';\n/**\r\n * @param opt_elideCopy If true, doesn't copy mutable input data\r\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\r\n *     modified after this blob's construction.\r\n */\n\nvar FbsBlob =\n/** @class */\nfunction () {\n  function FbsBlob(data, opt_elideCopy) {\n    var size = 0;\n    var blobType = '';\n\n    if (type.isNativeBlob(data)) {\n      this.data_ = data;\n      size = data.size;\n      blobType = data.type;\n    } else if (data instanceof ArrayBuffer) {\n      if (opt_elideCopy) {\n        this.data_ = new Uint8Array(data);\n      } else {\n        this.data_ = new Uint8Array(data.byteLength);\n        this.data_.set(new Uint8Array(data));\n      }\n\n      size = this.data_.length;\n    } else if (data instanceof Uint8Array) {\n      if (opt_elideCopy) {\n        this.data_ = data;\n      } else {\n        this.data_ = new Uint8Array(data.length);\n        this.data_.set(data);\n      }\n\n      size = data.length;\n    }\n\n    this.size_ = size;\n    this.type_ = blobType;\n  }\n\n  FbsBlob.prototype.size = function () {\n    return this.size_;\n  };\n\n  FbsBlob.prototype.type = function () {\n    return this.type_;\n  };\n\n  FbsBlob.prototype.slice = function (startByte, endByte) {\n    if (type.isNativeBlob(this.data_)) {\n      var realBlob = this.data_;\n      var sliced = fs.sliceBlob(realBlob, startByte, endByte);\n\n      if (sliced === null) {\n        return null;\n      }\n\n      return new FbsBlob(sliced);\n    } else {\n      var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);\n      return new FbsBlob(slice, true);\n    }\n  };\n\n  FbsBlob.getBlob = function () {\n    var var_args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      var_args[_i] = arguments[_i];\n    }\n\n    if (type.isNativeBlobDefined()) {\n      var blobby = var_args.map(function (val) {\n        if (val instanceof FbsBlob) {\n          return val.data_;\n        } else {\n          return val;\n        }\n      });\n      return new FbsBlob(fs.getBlob.apply(null, blobby));\n    } else {\n      var uint8Arrays = var_args.map(function (val) {\n        if (type.isString(val)) {\n          return string.dataFromString(StringFormat.RAW, val).data;\n        } else {\n          // Blobs don't exist, so this has to be a Uint8Array.\n          return val.data_;\n        }\n      });\n      var finalLength_1 = 0;\n      uint8Arrays.forEach(function (array) {\n        finalLength_1 += array.byteLength;\n      });\n      var merged_1 = new Uint8Array(finalLength_1);\n      var index_1 = 0;\n      uint8Arrays.forEach(function (array) {\n        for (var i = 0; i < array.length; i++) {\n          merged_1[index_1++] = array[i];\n        }\n      });\n      return new FbsBlob(merged_1, true);\n    }\n  };\n\n  FbsBlob.prototype.uploadData = function () {\n    return this.data_;\n  };\n\n  return FbsBlob;\n}();\n\nexport { FbsBlob };","map":{"version":3,"mappings":"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","names":["fs","string","StringFormat","type","data","opt_elideCopy","size","blobType","isNativeBlob","data_","ArrayBuffer","Uint8Array","byteLength","set","length","size_","type_","FbsBlob","startByte","endByte","realBlob","sliced","sliceBlob","slice","buffer","var_args","isNativeBlobDefined","blobby","map","val","getBlob","apply","uint8Arrays","isString","dataFromString","RAW","finalLength_1","forEach","array","merged_1","index_1","i"],"sources":["../src/implementation/blob.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Provides a Blob-like wrapper for various binary types (including the\n * native Blob type). This makes it possible to upload types like ArrayBuffers,\n * making uploads possible in environments without the native Blob type.\n */\nimport * as fs from './fs';\nimport * as string from './string';\nimport { StringFormat } from './string';\nimport * as type from './type';\n\n/**\n * @param opt_elideCopy If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n */\nexport class FbsBlob {\n  private data_: Blob | Uint8Array;\n  private size_: number;\n  private type_: string;\n\n  constructor(data: Blob | Uint8Array | ArrayBuffer, opt_elideCopy?: boolean) {\n    let size: number = 0;\n    let blobType: string = '';\n    if (type.isNativeBlob(data)) {\n      this.data_ = data as Blob;\n      size = (data as Blob).size;\n      blobType = (data as Blob).type;\n    } else if (data instanceof ArrayBuffer) {\n      if (opt_elideCopy) {\n        this.data_ = new Uint8Array(data);\n      } else {\n        this.data_ = new Uint8Array(data.byteLength);\n        this.data_.set(new Uint8Array(data));\n      }\n      size = this.data_.length;\n    } else if (data instanceof Uint8Array) {\n      if (opt_elideCopy) {\n        this.data_ = data as Uint8Array;\n      } else {\n        this.data_ = new Uint8Array(data.length);\n        this.data_.set(data as Uint8Array);\n      }\n      size = data.length;\n    }\n    this.size_ = size;\n    this.type_ = blobType;\n  }\n\n  size(): number {\n    return this.size_;\n  }\n\n  type(): string {\n    return this.type_;\n  }\n\n  slice(startByte: number, endByte: number): FbsBlob | null {\n    if (type.isNativeBlob(this.data_)) {\n      let realBlob = this.data_ as Blob;\n      let sliced = fs.sliceBlob(realBlob, startByte, endByte);\n      if (sliced === null) {\n        return null;\n      }\n      return new FbsBlob(sliced);\n    } else {\n      let slice = new Uint8Array(\n        (this.data_ as Uint8Array).buffer,\n        startByte,\n        endByte - startByte\n      );\n      return new FbsBlob(slice, true);\n    }\n  }\n\n  static getBlob(...var_args: (string | FbsBlob)[]): FbsBlob | null {\n    if (type.isNativeBlobDefined()) {\n      var blobby: (Blob | Uint8Array | string)[] = var_args.map(function(\n        val: string | FbsBlob\n      ): Blob | Uint8Array | string {\n        if (val instanceof FbsBlob) {\n          return val.data_;\n        } else {\n          return val;\n        }\n      });\n      return new FbsBlob(fs.getBlob.apply(null, blobby));\n    } else {\n      let uint8Arrays: Uint8Array[] = var_args.map(function(\n        val: string | FbsBlob\n      ): Uint8Array {\n        if (type.isString(val)) {\n          return string.dataFromString(StringFormat.RAW, val as string).data;\n        } else {\n          // Blobs don't exist, so this has to be a Uint8Array.\n          return (val as FbsBlob).data_ as Uint8Array;\n        }\n      });\n      let finalLength = 0;\n      uint8Arrays.forEach(function(array: Uint8Array): void {\n        finalLength += array.byteLength;\n      });\n      let merged = new Uint8Array(finalLength);\n      let index = 0;\n      uint8Arrays.forEach(function(array: Uint8Array) {\n        for (let i = 0; i < array.length; i++) {\n          merged[index++] = array[i];\n        }\n      });\n      return new FbsBlob(merged, true);\n    }\n  }\n\n  uploadData(): Blob | Uint8Array {\n    return this.data_;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}