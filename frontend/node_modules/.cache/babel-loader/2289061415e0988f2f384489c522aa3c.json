{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar childSet_1 = require(\"./childSet\");\n\nvar util_2 = require(\"@firebase/util\");\n\nvar Node_1 = require(\"./Node\");\n\nvar PriorityIndex_1 = require(\"./indexes/PriorityIndex\");\n\nvar KeyIndex_1 = require(\"./indexes/KeyIndex\");\n\nvar _defaultIndexMap;\n\nvar fallbackObject = {};\n/**\r\n *\r\n * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes\r\n * @param {Object.<string, Index>} indexSet\r\n * @constructor\r\n */\n\nvar IndexMap =\n/** @class */\nfunction () {\n  function IndexMap(indexes_, indexSet_) {\n    this.indexes_ = indexes_;\n    this.indexSet_ = indexSet_;\n  }\n\n  Object.defineProperty(IndexMap, \"Default\", {\n    /**\r\n     * The default IndexMap for nodes without a priority\r\n     * @type {!IndexMap}\r\n     * @const\r\n     */\n    get: function () {\n      util_1.assert(fallbackObject && PriorityIndex_1.PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');\n      _defaultIndexMap = _defaultIndexMap || new IndexMap({\n        '.priority': fallbackObject\n      }, {\n        '.priority': PriorityIndex_1.PRIORITY_INDEX\n      });\n      return _defaultIndexMap;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   *\r\n   * @param {!string} indexKey\r\n   * @return {?SortedMap.<NamedNode, Node>}\r\n   */\n\n  IndexMap.prototype.get = function (indexKey) {\n    var sortedMap = util_2.safeGet(this.indexes_, indexKey);\n    if (!sortedMap) throw new Error('No index defined for ' + indexKey);\n\n    if (sortedMap === fallbackObject) {\n      // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n      // regular child map\n      return null;\n    } else {\n      return sortedMap;\n    }\n  };\n  /**\r\n   * @param {!Index} indexDefinition\r\n   * @return {boolean}\r\n   */\n\n\n  IndexMap.prototype.hasIndex = function (indexDefinition) {\n    return util_2.contains(this.indexSet_, indexDefinition.toString());\n  };\n  /**\r\n   * @param {!Index} indexDefinition\r\n   * @param {!SortedMap.<string, !Node>} existingChildren\r\n   * @return {!IndexMap}\r\n   */\n\n\n  IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) {\n    util_1.assert(indexDefinition !== KeyIndex_1.KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\n    var childList = [];\n    var sawIndexedValue = false;\n    var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);\n    var next = iter.getNext();\n\n    while (next) {\n      sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n      childList.push(next);\n      next = iter.getNext();\n    }\n\n    var newIndex;\n\n    if (sawIndexedValue) {\n      newIndex = childSet_1.buildChildSet(childList, indexDefinition.getCompare());\n    } else {\n      newIndex = fallbackObject;\n    }\n\n    var indexName = indexDefinition.toString();\n    var newIndexSet = util_2.clone(this.indexSet_);\n    newIndexSet[indexName] = indexDefinition;\n    var newIndexes = util_2.clone(this.indexes_);\n    newIndexes[indexName] = newIndex;\n    return new IndexMap(newIndexes, newIndexSet);\n  };\n  /**\r\n   * Ensure that this node is properly tracked in any indexes that we're maintaining\r\n   * @param {!NamedNode} namedNode\r\n   * @param {!SortedMap.<string, !Node>} existingChildren\r\n   * @return {!IndexMap}\r\n   */\n\n\n  IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) {\n    var _this = this;\n\n    var newIndexes = util_2.map(this.indexes_, function (indexedChildren, indexName) {\n      var index = util_2.safeGet(_this.indexSet_, indexName);\n      util_1.assert(index, 'Missing index implementation for ' + indexName);\n\n      if (indexedChildren === fallbackObject) {\n        // Check to see if we need to index everything\n        if (index.isDefinedOn(namedNode.node)) {\n          // We need to build this index\n          var childList = [];\n          var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);\n          var next = iter.getNext();\n\n          while (next) {\n            if (next.name != namedNode.name) {\n              childList.push(next);\n            }\n\n            next = iter.getNext();\n          }\n\n          childList.push(namedNode);\n          return childSet_1.buildChildSet(childList, index.getCompare());\n        } else {\n          // No change, this remains a fallback\n          return fallbackObject;\n        }\n      } else {\n        var existingSnap = existingChildren.get(namedNode.name);\n        var newChildren = indexedChildren;\n\n        if (existingSnap) {\n          newChildren = newChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));\n        }\n\n        return newChildren.insert(namedNode, namedNode.node);\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  };\n  /**\r\n   * Create a new IndexMap instance with the given value removed\r\n   * @param {!NamedNode} namedNode\r\n   * @param {!SortedMap.<string, !Node>} existingChildren\r\n   * @return {!IndexMap}\r\n   */\n\n\n  IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) {\n    var newIndexes = util_2.map(this.indexes_, function (indexedChildren) {\n      if (indexedChildren === fallbackObject) {\n        // This is the fallback. Just return it, nothing to do in this case\n        return indexedChildren;\n      } else {\n        var existingSnap = existingChildren.get(namedNode.name);\n\n        if (existingSnap) {\n          return indexedChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));\n        } else {\n          // No record of this child\n          return indexedChildren;\n        }\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  };\n\n  return IndexMap;\n}();\n\nexports.IndexMap = IndexMap;","map":{"version":3,"mappings":"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","names":["_defaultIndexMap","fallbackObject","indexes_","indexSet_","Object","IndexMap","util_1","PriorityIndex_1","indexKey","sortedMap","util_2","Error","indexDefinition","toString","existingChildren","KeyIndex_1","childList","sawIndexedValue","iter","getIterator","Node_1","Wrap","next","getNext","isDefinedOn","node","push","newIndex","childSet_1","getCompare","indexName","newIndexSet","newIndexes","namedNode","indexedChildren","index","_this","name","existingSnap","get","newChildren","remove","insert","exports"],"sources":["../src/core/snap/IndexMap.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { buildChildSet } from './childSet';\nimport { contains, clone, map, safeGet } from '@firebase/util';\nimport { NamedNode, Node } from './Node';\nimport { PRIORITY_INDEX } from './indexes/PriorityIndex';\nimport { KEY_INDEX } from './indexes/KeyIndex';\nimport { SortedMap } from '../util/SortedMap';\nimport { Index } from './indexes/Index';\n\nlet _defaultIndexMap: IndexMap;\n\nconst fallbackObject = {};\n\n/**\n *\n * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes\n * @param {Object.<string, Index>} indexSet\n * @constructor\n */\nexport class IndexMap {\n  /**\n   * The default IndexMap for nodes without a priority\n   * @type {!IndexMap}\n   * @const\n   */\n  static get Default(): IndexMap {\n    assert(\n      fallbackObject && PRIORITY_INDEX,\n      'ChildrenNode.ts has not been loaded'\n    );\n    _defaultIndexMap =\n      _defaultIndexMap ||\n      new IndexMap(\n        { '.priority': fallbackObject },\n        { '.priority': PRIORITY_INDEX }\n      );\n    return _defaultIndexMap;\n  }\n\n  constructor(\n    private indexes_: {\n      [k: string]: SortedMap<NamedNode, Node> | /*FallbackType*/ object;\n    },\n    private indexSet_: { [k: string]: Index }\n  ) {}\n\n  /**\n   *\n   * @param {!string} indexKey\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  get(indexKey: string): SortedMap<NamedNode, Node> | null {\n    const sortedMap = safeGet(this.indexes_, indexKey);\n    if (!sortedMap) throw new Error('No index defined for ' + indexKey);\n\n    if (sortedMap === fallbackObject) {\n      // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n      // regular child map\n      return null;\n    } else {\n      return sortedMap;\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {boolean}\n   */\n  hasIndex(indexDefinition: Index): boolean {\n    return contains(this.indexSet_, indexDefinition.toString());\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  addIndex(\n    indexDefinition: Index,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    assert(\n      indexDefinition !== KEY_INDEX,\n      \"KeyIndex always exists and isn't meant to be added to the IndexMap.\"\n    );\n    const childList = [];\n    let sawIndexedValue = false;\n    const iter = existingChildren.getIterator(NamedNode.Wrap);\n    let next = iter.getNext();\n    while (next) {\n      sawIndexedValue =\n        sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n      childList.push(next);\n      next = iter.getNext();\n    }\n    let newIndex;\n    if (sawIndexedValue) {\n      newIndex = buildChildSet(childList, indexDefinition.getCompare());\n    } else {\n      newIndex = fallbackObject;\n    }\n    const indexName = indexDefinition.toString();\n    const newIndexSet = clone(this.indexSet_);\n    newIndexSet[indexName] = indexDefinition;\n    const newIndexes = clone(this.indexes_);\n    newIndexes[indexName] = newIndex;\n    return new IndexMap(newIndexes, newIndexSet);\n  }\n\n  /**\n   * Ensure that this node is properly tracked in any indexes that we're maintaining\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  addToIndexes(\n    namedNode: NamedNode,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    const newIndexes = map(\n      this.indexes_,\n      (indexedChildren: SortedMap<NamedNode, Node>, indexName: string) => {\n        const index = safeGet(this.indexSet_, indexName);\n        assert(index, 'Missing index implementation for ' + indexName);\n        if (indexedChildren === fallbackObject) {\n          // Check to see if we need to index everything\n          if (index.isDefinedOn(namedNode.node)) {\n            // We need to build this index\n            const childList = [];\n            const iter = existingChildren.getIterator(NamedNode.Wrap);\n            let next = iter.getNext();\n            while (next) {\n              if (next.name != namedNode.name) {\n                childList.push(next);\n              }\n              next = iter.getNext();\n            }\n            childList.push(namedNode);\n            return buildChildSet(childList, index.getCompare());\n          } else {\n            // No change, this remains a fallback\n            return fallbackObject;\n          }\n        } else {\n          const existingSnap = existingChildren.get(namedNode.name);\n          let newChildren = indexedChildren;\n          if (existingSnap) {\n            newChildren = newChildren.remove(\n              new NamedNode(namedNode.name, existingSnap)\n            );\n          }\n          return newChildren.insert(namedNode, namedNode.node);\n        }\n      }\n    );\n    return new IndexMap(newIndexes, this.indexSet_);\n  }\n\n  /**\n   * Create a new IndexMap instance with the given value removed\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  removeFromIndexes(\n    namedNode: NamedNode,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    const newIndexes = map(this.indexes_, function(\n      indexedChildren: SortedMap<NamedNode, Node>\n    ) {\n      if (indexedChildren === fallbackObject) {\n        // This is the fallback. Just return it, nothing to do in this case\n        return indexedChildren;\n      } else {\n        const existingSnap = existingChildren.get(namedNode.name);\n        if (existingSnap) {\n          return indexedChildren.remove(\n            new NamedNode(namedNode.name, existingSnap)\n          );\n        } else {\n          // No record of this child\n          return indexedChildren;\n        }\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}