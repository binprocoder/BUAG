{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport FCMDetails from '../models/fcm-details';\nvar FCM_MSG = 'FCM_MSG';\n\nvar SWController =\n/** @class */\nfunction (_super) {\n  __extends(SWController, _super);\n\n  function SWController(app) {\n    var _this = _super.call(this, app) || this;\n\n    self.addEventListener('push', function (e) {\n      return _this.onPush_(e);\n    }, false);\n    self.addEventListener('pushsubscriptionchange', function (e) {\n      return _this.onSubChange_(e);\n    }, false);\n    self.addEventListener('notificationclick', function (e) {\n      return _this.onNotificationClick_(e);\n    }, false);\n    /**\n     * @private\n     * @type {function(Object)|null}\n     */\n\n    _this.bgMessageHandler_ = null;\n    return _this;\n  }\n  /**\n   * A handler for push events that shows notifications based on the content of\n   * the payload.\n   *\n   * The payload must be a JSON-encoded Object with a `notification` key. The\n   * value of the `notification` property will be used as the NotificationOptions\n   * object passed to showNotification. Additionally, the `title` property of the\n   * notification object will be used as the title.\n   *\n   * If there is no notification data in the payload then no notification will be\n   * shown.\n   * @private\n   */\n\n\n  SWController.prototype.onPush_ = function (event) {\n    var _this = this;\n\n    var msgPayload;\n\n    try {\n      msgPayload = event.data.json();\n    } catch (err) {\n      // Not JSON so not an FCM message\n      return;\n    }\n\n    var handleMsgPromise = this.hasVisibleClients_().then(function (hasVisibleClients) {\n      if (hasVisibleClients) {\n        // Do not need to show a notification.\n        if (msgPayload.notification || _this.bgMessageHandler_) {\n          // Send to page\n          return _this.sendMessageToWindowClients_(msgPayload);\n        }\n\n        return;\n      }\n\n      var notificationDetails = _this.getNotificationData_(msgPayload);\n\n      if (notificationDetails) {\n        var notificationTitle = notificationDetails.title || '';\n        return self.registration.showNotification(notificationTitle, notificationDetails);\n      } else if (_this.bgMessageHandler_) {\n        return _this.bgMessageHandler_(msgPayload);\n      }\n    });\n    event.waitUntil(handleMsgPromise);\n  };\n  /**\n   * @private\n   */\n\n\n  SWController.prototype.onSubChange_ = function (event) {\n    var _this = this;\n\n    var promiseChain = this.getToken().then(function (token) {\n      if (!token) {\n        // We can't resubscribe if we don't have an FCM token for this scope.\n        throw _this.errorFactory_.create(Errors.codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE);\n      }\n\n      var tokenDetails = null;\n\n      var tokenManager = _this.getTokenManager();\n\n      return tokenManager.getTokenDetailsFromToken(token).then(function (details) {\n        tokenDetails = details;\n\n        if (!tokenDetails) {\n          throw _this.errorFactory_.create(Errors.codes.INVALID_SAVED_TOKEN);\n        } // Attempt to get a new subscription\n\n\n        return self.registration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);\n      }).then(function (newSubscription) {\n        // Send new subscription to FCM.\n        return tokenManager.subscribeToFCM(tokenDetails.fcmSenderId, newSubscription, tokenDetails.fcmPushSet);\n      }).catch(function (err) {\n        // The best thing we can do is log this to the terminal so\n        // developers might notice the error.\n        return tokenManager.deleteToken(tokenDetails.fcmToken).then(function () {\n          throw _this.errorFactory_.create(Errors.codes.UNABLE_TO_RESUBSCRIBE, {\n            message: err\n          });\n        });\n      });\n    });\n    event.waitUntil(promiseChain);\n  };\n  /**\n   * @private\n   */\n\n\n  SWController.prototype.onNotificationClick_ = function (event) {\n    var _this = this;\n\n    if (!(event.notification && event.notification.data && event.notification.data[FCM_MSG])) {\n      // Not an FCM notification, do nothing.\n      return;\n    } // Prevent other listeners from receiving the event\n\n\n    event.stopImmediatePropagation();\n    event.notification.close();\n    var msgPayload = event.notification.data[FCM_MSG];\n    var clickAction = msgPayload['notification']['click_action'];\n\n    if (!clickAction) {\n      // Nothing to do.\n      return;\n    }\n\n    var promiseChain = this.getWindowClient_(clickAction).then(function (windowClient) {\n      if (!windowClient) {\n        // Unable to find window client so need to open one.\n        return self.clients.openWindow(clickAction);\n      }\n\n      return windowClient;\n    }).then(function (windowClient) {\n      if (!windowClient) {\n        // Window Client will not be returned if it's for a third party origin.\n        return;\n      } // Delete notification data from payload before sending to the page.\n\n\n      var notificationData = msgPayload['notification'];\n      delete msgPayload['notification'];\n      var internalMsg = WorkerPageMessage.createNewMsg(WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED, msgPayload); // Attempt to send a message to the client to handle the data\n      // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n\n      return _this.attemptToMessageClient_(windowClient, internalMsg);\n    });\n    event.waitUntil(promiseChain);\n  };\n  /**\n   * @private\n   * @param {Object} msgPayload\n   * @return {NotificationOptions|undefined}\n   */\n\n\n  SWController.prototype.getNotificationData_ = function (msgPayload) {\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    var notificationInformation = Object.assign({}, msgPayload.notification); // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n\n    notificationInformation['data'] = (_a = {}, _a[FCM_MSG] = msgPayload, _a);\n    return notificationInformation;\n\n    var _a;\n  };\n  /**\n   * Calling setBackgroundMessageHandler will opt in to some specific\n   * behaviours.\n   * 1.) If a notification doesn't need to be shown due to a window already\n   * being visible, then push messages will be sent to the page.\n   * 2.) If a notification needs to be shown, and the message contains no\n   * notification data this method will be called\n   * and the promise it returns will be passed to event.waitUntil.\n   * If you do not set this callback then all push messages will let and the\n   * developer can handle them in a their own 'push' event callback\n   * @export\n   * @param {function(Object)} callback The callback to be called when a push\n   * message is received and a notification must be shown. The callback will\n   * be given the data from the push message.\n   */\n\n\n  SWController.prototype.setBackgroundMessageHandler = function (callback) {\n    if (callback && typeof callback !== 'function') {\n      throw this.errorFactory_.create(Errors.codes.BG_HANDLER_FUNCTION_EXPECTED);\n    }\n\n    this.bgMessageHandler_ = callback;\n  };\n  /**\n   * @private\n   * @param {string} url The URL to look for when focusing a client.\n   * @return {Object} Returns an existing window client or a newly opened\n   * WindowClient.\n   */\n\n\n  SWController.prototype.getWindowClient_ = function (url) {\n    // Use URL to normalize the URL when comparing to windowClients.\n    // This at least handles whether to include trailing slashes or not\n    var parsedURL = new URL(url).href;\n    return self.clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true\n    }).then(function (clientList) {\n      var suitableClient = null;\n\n      for (var i = 0; i < clientList.length; i++) {\n        var parsedClientUrl = new URL(clientList[i].url).href;\n\n        if (parsedClientUrl === parsedURL) {\n          suitableClient = clientList[i];\n          break;\n        }\n      }\n\n      if (suitableClient) {\n        suitableClient.focus();\n        return suitableClient;\n      }\n    });\n  };\n  /**\n   * This message will attempt to send the message to a window client.\n   * @private\n   * @param {Object} client The WindowClient to send the message to.\n   * @param {Object} message The message to send to the client.\n   * @returns {Promise} Returns a promise that resolves after sending the\n   * message. This does not guarantee that the message was successfully\n   * received.\n   */\n\n\n  SWController.prototype.attemptToMessageClient_ = function (client, message) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (!client) {\n        return reject(_this.errorFactory_.create(Errors.codes.NO_WINDOW_CLIENT_TO_MSG));\n      }\n\n      client.postMessage(message);\n      resolve();\n    });\n  };\n  /**\n   * @private\n   * @returns {Promise<boolean>} If there is currently a visible WindowClient,\n   * this method will resolve to true, otherwise false.\n   */\n\n\n  SWController.prototype.hasVisibleClients_ = function () {\n    return self.clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true\n    }).then(function (clientList) {\n      return clientList.some(function (client) {\n        return client.visibilityState === 'visible';\n      });\n    });\n  };\n  /**\n   * @private\n   * @param {Object} msgPayload The data from the push event that should be sent\n   * to all available pages.\n   * @returns {Promise} Returns a promise that resolves once the message\n   * has been sent to all WindowClients.\n   */\n\n\n  SWController.prototype.sendMessageToWindowClients_ = function (msgPayload) {\n    var _this = this;\n\n    return self.clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true\n    }).then(function (clientList) {\n      var internalMsg = WorkerPageMessage.createNewMsg(WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED, msgPayload);\n      return Promise.all(clientList.map(function (client) {\n        return _this.attemptToMessageClient_(client, internalMsg);\n      }));\n    });\n  };\n  /**\n   * This will register the default service worker and return the registration.\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n\n\n  SWController.prototype.getSWRegistration_ = function () {\n    return Promise.resolve(self.registration);\n  };\n\n  return SWController;\n}(ControllerInterface);\n\nexport default SWController;","map":{"version":3,"mappings":"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","names":["ControllerInterface","Errors","WorkerPageMessage","FCMDetails","FCM_MSG","__extends","app","_super","self","addEventListener","onPush_","e","onSubChange_","onNotificationClick_","_this","bgMessageHandler_","SWController","event","msgPayload","data","json","err","handleMsgPromise","hasVisibleClients_","then","hasVisibleClients","notification","sendMessageToWindowClients_","notificationDetails","getNotificationData_","notificationTitle","title","registration","showNotification","waitUntil","promiseChain","getToken","token","errorFactory_","create","codes","NO_FCM_TOKEN_FOR_RESUBSCRIBE","tokenDetails","tokenManager","getTokenManager","getTokenDetailsFromToken","details","INVALID_SAVED_TOKEN","pushManager","subscribe","SUBSCRIPTION_OPTIONS","subscribeToFCM","fcmSenderId","newSubscription","fcmPushSet","catch","deleteToken","fcmToken","UNABLE_TO_RESUBSCRIBE","message","stopImmediatePropagation","close","clickAction","getWindowClient_","windowClient","clients","openWindow","notificationData","internalMsg","createNewMsg","TYPES_OF_MSG","NOTIFICATION_CLICKED","attemptToMessageClient_","notificationInformation","Object","assign","_a","callback","BG_HANDLER_FUNCTION_EXPECTED","url","parsedURL","URL","href","matchAll","type","includeUncontrolled","suitableClient","i","clientList","length","parsedClientUrl","focus","client","Promise","resolve","reject","NO_WINDOW_CLIENT_TO_MSG","postMessage","some","visibilityState","PUSH_MSG_RECEIVED","all","map"],"sources":["../src/controllers/sw-controller.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport FCMDetails from '../models/fcm-details';\n\nconst FCM_MSG = 'FCM_MSG';\n\nexport default class SWController extends ControllerInterface {\n  private bgMessageHandler_: (input: Object) => Promise<any>;\n\n  constructor(app) {\n    super(app);\n\n    self.addEventListener('push', e => this.onPush_(e), false);\n    self.addEventListener(\n      'pushsubscriptionchange',\n      e => this.onSubChange_(e),\n      false\n    );\n    self.addEventListener(\n      'notificationclick',\n      e => this.onNotificationClick_(e),\n      false\n    );\n\n    /**\n     * @private\n     * @type {function(Object)|null}\n     */\n    this.bgMessageHandler_ = null;\n  }\n\n  /**\n   * A handler for push events that shows notifications based on the content of\n   * the payload.\n   *\n   * The payload must be a JSON-encoded Object with a `notification` key. The\n   * value of the `notification` property will be used as the NotificationOptions\n   * object passed to showNotification. Additionally, the `title` property of the\n   * notification object will be used as the title.\n   *\n   * If there is no notification data in the payload then no notification will be\n   * shown.\n   * @private\n   */\n  onPush_(event) {\n    let msgPayload;\n    try {\n      msgPayload = event.data.json();\n    } catch (err) {\n      // Not JSON so not an FCM message\n      return;\n    }\n\n    const handleMsgPromise = this.hasVisibleClients_().then(\n      hasVisibleClients => {\n        if (hasVisibleClients) {\n          // Do not need to show a notification.\n          if (msgPayload.notification || this.bgMessageHandler_) {\n            // Send to page\n            return this.sendMessageToWindowClients_(msgPayload);\n          }\n          return;\n        }\n\n        const notificationDetails = this.getNotificationData_(msgPayload);\n        if (notificationDetails) {\n          const notificationTitle = notificationDetails.title || '';\n          return (self as any).registration.showNotification(\n            notificationTitle,\n            notificationDetails\n          );\n        } else if (this.bgMessageHandler_) {\n          return this.bgMessageHandler_(msgPayload);\n        }\n      }\n    );\n\n    event.waitUntil(handleMsgPromise);\n  }\n\n  /**\n   * @private\n   */\n  onSubChange_(event) {\n    const promiseChain = this.getToken().then(token => {\n      if (!token) {\n        // We can't resubscribe if we don't have an FCM token for this scope.\n        throw this.errorFactory_.create(\n          Errors.codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE\n        );\n      }\n\n      let tokenDetails = null;\n      const tokenManager = this.getTokenManager();\n      return tokenManager\n        .getTokenDetailsFromToken(token)\n        .then(details => {\n          tokenDetails = details;\n          if (!tokenDetails) {\n            throw this.errorFactory_.create(Errors.codes.INVALID_SAVED_TOKEN);\n          }\n\n          // Attempt to get a new subscription\n          return (self as any).registration.pushManager.subscribe(\n            FCMDetails.SUBSCRIPTION_OPTIONS\n          );\n        })\n        .then(newSubscription => {\n          // Send new subscription to FCM.\n          return tokenManager.subscribeToFCM(\n            tokenDetails.fcmSenderId,\n            newSubscription,\n            tokenDetails.fcmPushSet\n          );\n        })\n        .catch(err => {\n          // The best thing we can do is log this to the terminal so\n          // developers might notice the error.\n          return tokenManager.deleteToken(tokenDetails.fcmToken).then(() => {\n            throw this.errorFactory_.create(\n              Errors.codes.UNABLE_TO_RESUBSCRIBE,\n              {\n                message: err\n              }\n            );\n          });\n        });\n    });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n   * @private\n   */\n  onNotificationClick_(event) {\n    if (\n      !(\n        event.notification &&\n        event.notification.data &&\n        event.notification.data[FCM_MSG]\n      )\n    ) {\n      // Not an FCM notification, do nothing.\n      return;\n    }\n\n    // Prevent other listeners from receiving the event\n    event.stopImmediatePropagation();\n\n    event.notification.close();\n\n    const msgPayload = event.notification.data[FCM_MSG];\n    const clickAction = msgPayload['notification']['click_action'];\n    if (!clickAction) {\n      // Nothing to do.\n      return;\n    }\n\n    const promiseChain = this.getWindowClient_(clickAction)\n      .then(windowClient => {\n        if (!windowClient) {\n          // Unable to find window client so need to open one.\n          return (self as any).clients.openWindow(clickAction);\n        }\n        return windowClient;\n      })\n      .then(windowClient => {\n        if (!windowClient) {\n          // Window Client will not be returned if it's for a third party origin.\n          return;\n        }\n\n        // Delete notification data from payload before sending to the page.\n        const notificationData = msgPayload['notification'];\n        delete msgPayload['notification'];\n\n        const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED,\n          msgPayload\n        );\n        // Attempt to send a message to the client to handle the data\n        // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n        return this.attemptToMessageClient_(windowClient, internalMsg);\n      });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload\n   * @return {NotificationOptions|undefined}\n   */\n  getNotificationData_(msgPayload) {\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    const notificationInformation = Object.assign({}, msgPayload.notification);\n    // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n    notificationInformation['data'] = {\n      [FCM_MSG]: msgPayload\n    };\n\n    return notificationInformation;\n  }\n\n  /**\n   * Calling setBackgroundMessageHandler will opt in to some specific\n   * behaviours.\n   * 1.) If a notification doesn't need to be shown due to a window already\n   * being visible, then push messages will be sent to the page.\n   * 2.) If a notification needs to be shown, and the message contains no\n   * notification data this method will be called\n   * and the promise it returns will be passed to event.waitUntil.\n   * If you do not set this callback then all push messages will let and the\n   * developer can handle them in a their own 'push' event callback\n   * @export\n   * @param {function(Object)} callback The callback to be called when a push\n   * message is received and a notification must be shown. The callback will\n   * be given the data from the push message.\n   */\n  setBackgroundMessageHandler(callback) {\n    if (callback && typeof callback !== 'function') {\n      throw this.errorFactory_.create(\n        Errors.codes.BG_HANDLER_FUNCTION_EXPECTED\n      );\n    }\n\n    this.bgMessageHandler_ = callback;\n  }\n\n  /**\n   * @private\n   * @param {string} url The URL to look for when focusing a client.\n   * @return {Object} Returns an existing window client or a newly opened\n   * WindowClient.\n   */\n  getWindowClient_(url) {\n    // Use URL to normalize the URL when comparing to windowClients.\n    // This at least handles whether to include trailing slashes or not\n    const parsedURL = new URL(url).href;\n\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        let suitableClient = null;\n        for (let i = 0; i < clientList.length; i++) {\n          const parsedClientUrl = new URL(clientList[i].url).href;\n          if (parsedClientUrl === parsedURL) {\n            suitableClient = clientList[i];\n            break;\n          }\n        }\n\n        if (suitableClient) {\n          suitableClient.focus();\n          return suitableClient;\n        }\n      });\n  }\n\n  /**\n   * This message will attempt to send the message to a window client.\n   * @private\n   * @param {Object} client The WindowClient to send the message to.\n   * @param {Object} message The message to send to the client.\n   * @returns {Promise} Returns a promise that resolves after sending the\n   * message. This does not guarantee that the message was successfully\n   * received.\n   */\n  attemptToMessageClient_(client, message) {\n    return new Promise((resolve, reject) => {\n      if (!client) {\n        return reject(\n          this.errorFactory_.create(Errors.codes.NO_WINDOW_CLIENT_TO_MSG)\n        );\n      }\n\n      client.postMessage(message);\n      resolve();\n    });\n  }\n\n  /**\n   * @private\n   * @returns {Promise<boolean>} If there is currently a visible WindowClient,\n   * this method will resolve to true, otherwise false.\n   */\n  hasVisibleClients_() {\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        return clientList.some(client => client.visibilityState === 'visible');\n      });\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload The data from the push event that should be sent\n   * to all available pages.\n   * @returns {Promise} Returns a promise that resolves once the message\n   * has been sent to all WindowClients.\n   */\n  sendMessageToWindowClients_(msgPayload) {\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED,\n          msgPayload\n        );\n\n        return Promise.all(\n          clientList.map(client => {\n            return this.attemptToMessageClient_(client, internalMsg);\n          })\n        );\n      });\n  }\n\n  /**\n   * This will register the default service worker and return the registration.\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n  getSWRegistration_() {\n    return Promise.resolve((self as any).registration);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}