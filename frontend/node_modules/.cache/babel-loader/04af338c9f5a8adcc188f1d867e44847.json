{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ServerValues_1 = require(\"./util/ServerValues\");\n\nvar nodeFromJSON_1 = require(\"./snap/nodeFromJSON\");\n\nvar Path_1 = require(\"./util/Path\");\n\nvar SparseSnapshotTree_1 = require(\"./SparseSnapshotTree\");\n\nvar SyncTree_1 = require(\"./SyncTree\");\n\nvar SnapshotHolder_1 = require(\"./SnapshotHolder\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"./util/util\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar AuthTokenProvider_1 = require(\"./AuthTokenProvider\");\n\nvar StatsManager_1 = require(\"./stats/StatsManager\");\n\nvar StatsReporter_1 = require(\"./stats/StatsReporter\");\n\nvar StatsListener_1 = require(\"./stats/StatsListener\");\n\nvar EventQueue_1 = require(\"./view/EventQueue\");\n\nvar PersistentConnection_1 = require(\"./PersistentConnection\");\n\nvar ReadonlyRestClient_1 = require(\"./ReadonlyRestClient\");\n\nvar Database_1 = require(\"../api/Database\");\n\nvar INTERRUPT_REASON = 'repo_interrupt';\n/**\n * A connection to a single data repository.\n */\n\nvar Repo =\n/** @class */\nfunction () {\n  /**\n   * @param {!RepoInfo} repoInfo_\n   * @param {boolean} forceRestClient\n   * @param {!FirebaseApp} app\n   */\n  function Repo(repoInfo_, forceRestClient, app) {\n    var _this = this;\n\n    this.repoInfo_ = repoInfo_;\n    this.app = app;\n    this.dataUpdateCount = 0;\n    this.statsListener_ = null;\n    this.eventQueue_ = new EventQueue_1.EventQueue();\n    this.nextWriteId_ = 1;\n    this.interceptServerDataCallback_ = null; // A list of data pieces and paths to be set when this client disconnects.\n\n    this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();\n    /**\n     * TODO: This should be @private but it's used by test_access.js and internal.js\n     * @type {?PersistentConnection}\n     */\n\n    this.persistentConnection_ = null;\n    /** @type {!AuthTokenProvider} */\n\n    var authTokenProvider = new AuthTokenProvider_1.AuthTokenProvider(app);\n    this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo_);\n\n    if (forceRestClient || util_2.beingCrawled()) {\n      this.server_ = new ReadonlyRestClient_1.ReadonlyRestClient(this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider); // Minor hack: Fire onConnect immediately, since there's no actual connection.\n\n      setTimeout(this.onConnectStatus_.bind(this, true), 0);\n    } else {\n      var authOverride = app.options['databaseAuthVariableOverride']; // Validate authOverride\n\n      if (typeof authOverride !== 'undefined' && authOverride !== null) {\n        if (typeof authOverride !== 'object') {\n          throw new Error('Only objects are supported for option databaseAuthVariableOverride');\n        }\n\n        try {\n          util_1.stringify(authOverride);\n        } catch (e) {\n          throw new Error('Invalid authOverride provided: ' + e);\n        }\n      }\n\n      this.persistentConnection_ = new PersistentConnection_1.PersistentConnection(this.repoInfo_, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);\n      this.server_ = this.persistentConnection_;\n    }\n\n    authTokenProvider.addTokenChangeListener(function (token) {\n      _this.server_.refreshAuthToken(token);\n    }); // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n\n    this.statsReporter_ = StatsManager_1.StatsManager.getOrCreateReporter(repoInfo_, function () {\n      return new StatsReporter_1.StatsReporter(_this.stats_, _this.server_);\n    });\n    this.transactions_init_(); // Used for .info.\n\n    this.infoData_ = new SnapshotHolder_1.SnapshotHolder();\n    this.infoSyncTree_ = new SyncTree_1.SyncTree({\n      startListening: function (query, tag, currentHashFn, onComplete) {\n        var infoEvents = [];\n\n        var node = _this.infoData_.getNode(query.path); // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n        // on initial data...\n\n\n        if (!node.isEmpty()) {\n          infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);\n          setTimeout(function () {\n            onComplete('ok');\n          }, 0);\n        }\n\n        return infoEvents;\n      },\n      stopListening: function () {}\n    });\n    this.updateInfo_('connected', false);\n    this.serverSyncTree_ = new SyncTree_1.SyncTree({\n      startListening: function (query, tag, currentHashFn, onComplete) {\n        _this.server_.listen(query, currentHashFn, tag, function (status, data) {\n          var events = onComplete(status, data);\n\n          _this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n        }); // No synchronous events for network-backed sync trees\n\n\n        return [];\n      },\n      stopListening: function (query, tag) {\n        _this.server_.unlisten(query, tag);\n      }\n    });\n  }\n  /**\n   * @return {string}  The URL corresponding to the root of this Firebase.\n   */\n\n\n  Repo.prototype.toString = function () {\n    return (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host;\n  };\n  /**\n   * @return {!string} The namespace represented by the repo.\n   */\n\n\n  Repo.prototype.name = function () {\n    return this.repoInfo_.namespace;\n  };\n  /**\n   * @return {!number} The time in milliseconds, taking the server offset into account if we have one.\n   */\n\n\n  Repo.prototype.serverTime = function () {\n    var offsetNode = this.infoData_.getNode(new Path_1.Path('.info/serverTimeOffset'));\n    var offset = offsetNode.val() || 0;\n    return new Date().getTime() + offset;\n  };\n  /**\n   * Generate ServerValues using some variables from the repo object.\n   * @return {!Object}\n   */\n\n\n  Repo.prototype.generateServerValues = function () {\n    return ServerValues_1.generateWithValues({\n      timestamp: this.serverTime()\n    });\n  };\n  /**\n   * Called by realtime when we get new messages from the server.\n   *\n   * @private\n   * @param {string} pathString\n   * @param {*} data\n   * @param {boolean} isMerge\n   * @param {?number} tag\n   */\n\n\n  Repo.prototype.onDataUpdate_ = function (pathString, data, isMerge, tag) {\n    // For testing.\n    this.dataUpdateCount++;\n    var path = new Path_1.Path(pathString);\n    data = this.interceptServerDataCallback_ ? this.interceptServerDataCallback_(pathString, data) : data;\n    var events = [];\n\n    if (tag) {\n      if (isMerge) {\n        var taggedChildren = util_3.map(data, function (raw) {\n          return nodeFromJSON_1.nodeFromJSON(raw);\n        });\n        events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);\n      } else {\n        var taggedSnap = nodeFromJSON_1.nodeFromJSON(data);\n        events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);\n      }\n    } else if (isMerge) {\n      var changedChildren = util_3.map(data, function (raw) {\n        return nodeFromJSON_1.nodeFromJSON(raw);\n      });\n      events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n    } else {\n      var snap = nodeFromJSON_1.nodeFromJSON(data);\n      events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n    }\n\n    var affectedPath = path;\n\n    if (events.length > 0) {\n      // Since we have a listener outstanding for each transaction, receiving any events\n      // is a proxy for some change having occurred.\n      affectedPath = this.rerunTransactions_(path);\n    }\n\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n  };\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @param {?function(!string, *):*} callback\n   * @private\n   */\n\n\n  Repo.prototype.interceptServerData_ = function (callback) {\n    this.interceptServerDataCallback_ = callback;\n  };\n  /**\n   * @param {!boolean} connectStatus\n   * @private\n   */\n\n\n  Repo.prototype.onConnectStatus_ = function (connectStatus) {\n    this.updateInfo_('connected', connectStatus);\n\n    if (connectStatus === false) {\n      this.runOnDisconnectEvents_();\n    }\n  };\n  /**\n   * @param {!Object} updates\n   * @private\n   */\n\n\n  Repo.prototype.onServerInfoUpdate_ = function (updates) {\n    var _this = this;\n\n    util_2.each(updates, function (value, key) {\n      _this.updateInfo_(key, value);\n    });\n  };\n  /**\n   *\n   * @param {!string} pathString\n   * @param {*} value\n   * @private\n   */\n\n\n  Repo.prototype.updateInfo_ = function (pathString, value) {\n    var path = new Path_1.Path('/.info/' + pathString);\n    var newNode = nodeFromJSON_1.nodeFromJSON(value);\n    this.infoData_.updateSnapshot(path, newNode);\n    var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n  };\n  /**\n   * @return {!number}\n   * @private\n   */\n\n\n  Repo.prototype.getNextWriteId_ = function () {\n    return this.nextWriteId_++;\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} newVal\n   * @param {number|string|null} newPriority\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.setWithPriority = function (path, newVal, newPriority, onComplete) {\n    var _this = this;\n\n    this.log_('set', {\n      path: path.toString(),\n      value: newVal,\n      priority: newPriority\n    }); // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n\n    var serverValues = this.generateServerValues();\n    var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, newPriority);\n    var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n    var writeId = this.getNextWriteId_();\n    var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);\n    this.eventQueue_.queueEvents(events);\n    this.server_.put(path.toString(), newNodeUnresolved.val(\n    /*export=*/\n    true), function (status, errorReason) {\n      var success = status === 'ok';\n\n      if (!success) {\n        util_2.warn('set at ' + path + ' failed: ' + status);\n      }\n\n      var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);\n\n      _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n    var affectedPath = this.abortTransactions_(path);\n    this.rerunTransactions_(affectedPath); // We queued the events above, so just flush the queue here\n\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n  };\n  /**\n   * @param {!Path} path\n   * @param {!Object} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.update = function (path, childrenToMerge, onComplete) {\n    var _this = this;\n\n    this.log_('update', {\n      path: path.toString(),\n      value: childrenToMerge\n    }); // Start with our existing data and merge each child into it.\n\n    var empty = true;\n    var serverValues = this.generateServerValues();\n    var changedChildren = {};\n    util_3.forEach(childrenToMerge, function (changedKey, changedValue) {\n      empty = false;\n      var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(changedValue);\n      changedChildren[changedKey] = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n    });\n\n    if (!empty) {\n      var writeId_1 = this.getNextWriteId_();\n      var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);\n      this.eventQueue_.queueEvents(events);\n      this.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) {\n        var success = status === 'ok';\n\n        if (!success) {\n          util_2.warn('update at ' + path + ' failed: ' + status);\n        }\n\n        var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);\n\n        var affectedPath = clearEvents.length > 0 ? _this.rerunTransactions_(path) : path;\n\n        _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n\n        _this.callOnCompleteCallback(onComplete, status, errorReason);\n      });\n      util_3.forEach(childrenToMerge, function (changedPath) {\n        var affectedPath = _this.abortTransactions_(path.child(changedPath));\n\n        _this.rerunTransactions_(affectedPath);\n      }); // We queued the events above, so just flush the queue here\n\n      this.eventQueue_.raiseEventsForChangedPath(path, []);\n    } else {\n      util_2.log(\"update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n    }\n  };\n  /**\n   * Applies all of the changes stored up in the onDisconnect_ tree.\n   * @private\n   */\n\n\n  Repo.prototype.runOnDisconnectEvents_ = function () {\n    var _this = this;\n\n    this.log_('onDisconnectEvents');\n    var serverValues = this.generateServerValues();\n    var resolvedOnDisconnectTree = ServerValues_1.resolveDeferredValueTree(this.onDisconnect_, serverValues);\n    var events = [];\n    resolvedOnDisconnectTree.forEachTree(Path_1.Path.Empty, function (path, snap) {\n      events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));\n\n      var affectedPath = _this.abortTransactions_(path);\n\n      _this.rerunTransactions_(affectedPath);\n    });\n    this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();\n    this.eventQueue_.raiseEventsForChangedPath(Path_1.Path.Empty, events);\n  };\n  /**\n   * @param {!Path} path\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.onDisconnectCancel = function (path, onComplete) {\n    var _this = this;\n\n    this.server_.onDisconnectCancel(path.toString(), function (status, errorReason) {\n      if (status === 'ok') {\n        _this.onDisconnect_.forget(path);\n      }\n\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.onDisconnectSet = function (path, value, onComplete) {\n    var _this = this;\n\n    var newNode = nodeFromJSON_1.nodeFromJSON(value);\n    this.server_.onDisconnectPut(path.toString(), newNode.val(\n    /*export=*/\n    true), function (status, errorReason) {\n      if (status === 'ok') {\n        _this.onDisconnect_.remember(path, newNode);\n      }\n\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {*} priority\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.onDisconnectSetWithPriority = function (path, value, priority, onComplete) {\n    var _this = this;\n\n    var newNode = nodeFromJSON_1.nodeFromJSON(value, priority);\n    this.server_.onDisconnectPut(path.toString(), newNode.val(\n    /*export=*/\n    true), function (status, errorReason) {\n      if (status === 'ok') {\n        _this.onDisconnect_.remember(path, newNode);\n      }\n\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.onDisconnectUpdate = function (path, childrenToMerge, onComplete) {\n    var _this = this;\n\n    if (util_3.isEmpty(childrenToMerge)) {\n      util_2.log(\"onDisconnect().update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n      return;\n    }\n\n    this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) {\n      if (status === 'ok') {\n        util_3.forEach(childrenToMerge, function (childName, childNode) {\n          var newChildNode = nodeFromJSON_1.nodeFromJSON(childNode);\n\n          _this.onDisconnect_.remember(path.child(childName), newChildNode);\n        });\n      }\n\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   */\n\n\n  Repo.prototype.addEventCallbackForQuery = function (query, eventRegistration) {\n    var events;\n\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);\n    } else {\n      events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);\n    }\n\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  };\n  /**\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration\n   */\n\n\n  Repo.prototype.removeEventCallbackForQuery = function (query, eventRegistration) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    var events;\n\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);\n    } else {\n      events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);\n    }\n\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  };\n\n  Repo.prototype.interrupt = function () {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n  };\n\n  Repo.prototype.resume = function () {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n  };\n\n  Repo.prototype.stats = function (showDelta) {\n    if (showDelta === void 0) {\n      showDelta = false;\n    }\n\n    if (typeof console === 'undefined') return;\n    var stats;\n\n    if (showDelta) {\n      if (!this.statsListener_) this.statsListener_ = new StatsListener_1.StatsListener(this.stats_);\n      stats = this.statsListener_.get();\n    } else {\n      stats = this.stats_.get();\n    }\n\n    var longestName = Object.keys(stats).reduce(function (previousValue, currentValue) {\n      return Math.max(currentValue.length, previousValue);\n    }, 0);\n    util_3.forEach(stats, function (stat, value) {\n      // pad stat names to be the same length (plus 2 extra spaces).\n      for (var i = stat.length; i < longestName + 2; i++) stat += ' ';\n\n      console.log(stat + value);\n    });\n  };\n\n  Repo.prototype.statsIncrementCounter = function (metric) {\n    this.stats_.incrementCounter(metric);\n    this.statsReporter_.includeStat(metric);\n  };\n  /**\n   * @param {...*} var_args\n   * @private\n   */\n\n\n  Repo.prototype.log_ = function () {\n    var var_args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      var_args[_i] = arguments[_i];\n    }\n\n    var prefix = '';\n\n    if (this.persistentConnection_) {\n      prefix = this.persistentConnection_.id + ':';\n    }\n\n    util_2.log.apply(void 0, [prefix].concat(var_args));\n  };\n  /**\n   * @param {?function(?Error, *=)} callback\n   * @param {!string} status\n   * @param {?string=} errorReason\n   */\n\n\n  Repo.prototype.callOnCompleteCallback = function (callback, status, errorReason) {\n    if (callback) {\n      util_2.exceptionGuard(function () {\n        if (status == 'ok') {\n          callback(null);\n        } else {\n          var code = (status || 'error').toUpperCase();\n          var message = code;\n          if (errorReason) message += ': ' + errorReason;\n          var error = new Error(message);\n          error.code = code;\n          callback(error);\n        }\n      });\n    }\n  };\n\n  Object.defineProperty(Repo.prototype, \"database\", {\n    get: function () {\n      return this.__database || (this.__database = new Database_1.Database(this));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Repo;\n}();\n\nexports.Repo = Repo;","map":{"version":3,"mappings":"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","names":["INTERRUPT_REASON","repoInfo_","forceRestClient","app","EventQueue_1","SparseSnapshotTree_1","authTokenProvider","AuthTokenProvider_1","stats_","StatsManager_1","getCollection","util_2","server_","ReadonlyRestClient_1","onDataUpdate_","bind","setTimeout","onConnectStatus_","authOverride","options","Error","util_1","e","persistentConnection_","PersistentConnection_1","onServerInfoUpdate_","addTokenChangeListener","_this","refreshAuthToken","token","statsReporter_","getOrCreateReporter","StatsReporter_1","transactions_init_","infoData_","SnapshotHolder_1","infoSyncTree_","SyncTree_1","startListening","query","tag","currentHashFn","onComplete","infoEvents","node","getNode","path","isEmpty","applyServerOverwrite","stopListening","updateInfo_","serverSyncTree_","listen","status","data","events","eventQueue_","raiseEventsForChangedPath","unlisten","Repo","secure","host","namespace","offsetNode","Path_1","offset","val","Date","getTime","ServerValues_1","timestamp","serverTime","pathString","isMerge","dataUpdateCount","interceptServerDataCallback_","taggedChildren","util_3","raw","applyTaggedQueryMerge","taggedSnap","nodeFromJSON_1","applyTaggedQueryOverwrite","changedChildren","applyServerMerge","snap","affectedPath","length","rerunTransactions_","callback","connectStatus","runOnDisconnectEvents_","updates","value","key","newNode","updateSnapshot","nextWriteId_","newVal","newPriority","log_","toString","priority","serverValues","generateServerValues","newNodeUnresolved","writeId","getNextWriteId_","applyUserOverwrite","queueEvents","put","errorReason","success","clearEvents","ackUserWrite","callOnCompleteCallback","abortTransactions_","childrenToMerge","empty","changedKey","changedValue","writeId_1","applyUserMerge","merge","changedPath","child","resolvedOnDisconnectTree","onDisconnect_","forEachTree","Empty","concat","onDisconnectCancel","forget","onDisconnectPut","remember","onDisconnectMerge","childName","childNode","newChildNode","eventRegistration","getFront","addEventRegistration","raiseEventsAtPath","removeEventRegistration","interrupt","resume","showDelta","console","stats","statsListener_","StatsListener_1","get","longestName","Object","keys","reduce","previousValue","currentValue","max","stat","i","log","metric","incrementCounter","includeStat","var_args","prefix","id","apply","code","toUpperCase","message","error","__database","Database_1","exports"],"sources":["../src/core/Repo.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  generateWithValues,\n  resolveDeferredValueSnapshot,\n  resolveDeferredValueTree\n} from './util/ServerValues';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { Path } from './util/Path';\nimport { SparseSnapshotTree } from './SparseSnapshotTree';\nimport { SyncTree } from './SyncTree';\nimport { SnapshotHolder } from './SnapshotHolder';\nimport { stringify } from '@firebase/util';\nimport { beingCrawled, each, exceptionGuard, warn, log } from './util/util';\nimport { map, forEach, isEmpty } from '@firebase/util';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { StatsManager } from './stats/StatsManager';\nimport { StatsReporter } from './stats/StatsReporter';\nimport { StatsListener } from './stats/StatsListener';\nimport { EventQueue } from './view/EventQueue';\nimport { PersistentConnection } from './PersistentConnection';\nimport { ReadonlyRestClient } from './ReadonlyRestClient';\nimport { FirebaseApp } from '@firebase/app';\nimport { RepoInfo } from './RepoInfo';\nimport { Database } from '../api/Database';\nimport { ServerActions } from './ServerActions';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { StatsCollection } from './stats/StatsCollection';\nimport { Event } from './view/Event';\nimport { Node } from './snap/Node';\n\nconst INTERRUPT_REASON = 'repo_interrupt';\n\n/**\n * A connection to a single data repository.\n */\nexport class Repo {\n  dataUpdateCount = 0;\n  private infoSyncTree_: SyncTree;\n  private serverSyncTree_: SyncTree;\n\n  private stats_: StatsCollection;\n  private statsListener_: StatsListener | null = null;\n  private eventQueue_ = new EventQueue();\n  private nextWriteId_ = 1;\n  private server_: ServerActions;\n  private statsReporter_: StatsReporter;\n  private transactions_init_: () => void;\n  private infoData_: SnapshotHolder;\n  private abortTransactions_: (path: Path) => Path;\n  private rerunTransactions_: (changedPath: Path) => Path;\n  private interceptServerDataCallback_:\n    | ((a: string, b: any) => void)\n    | null = null;\n  private __database: Database;\n\n  // A list of data pieces and paths to be set when this client disconnects.\n  private onDisconnect_ = new SparseSnapshotTree();\n\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @type {?PersistentConnection}\n   */\n  persistentConnection_: PersistentConnection | null = null;\n\n  /**\n   * @param {!RepoInfo} repoInfo_\n   * @param {boolean} forceRestClient\n   * @param {!FirebaseApp} app\n   */\n  constructor(\n    public repoInfo_: RepoInfo,\n    forceRestClient: boolean,\n    public app: FirebaseApp\n  ) {\n    /** @type {!AuthTokenProvider} */\n    const authTokenProvider = new AuthTokenProvider(app);\n\n    this.stats_ = StatsManager.getCollection(repoInfo_);\n\n    if (forceRestClient || beingCrawled()) {\n      this.server_ = new ReadonlyRestClient(\n        this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        authTokenProvider\n      );\n\n      // Minor hack: Fire onConnect immediately, since there's no actual connection.\n      setTimeout(this.onConnectStatus_.bind(this, true), 0);\n    } else {\n      const authOverride = app.options['databaseAuthVariableOverride'];\n      // Validate authOverride\n      if (typeof authOverride !== 'undefined' && authOverride !== null) {\n        if (typeof authOverride !== 'object') {\n          throw new Error(\n            'Only objects are supported for option databaseAuthVariableOverride'\n          );\n        }\n        try {\n          stringify(authOverride);\n        } catch (e) {\n          throw new Error('Invalid authOverride provided: ' + e);\n        }\n      }\n\n      this.persistentConnection_ = new PersistentConnection(\n        this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        this.onConnectStatus_.bind(this),\n        this.onServerInfoUpdate_.bind(this),\n        authTokenProvider,\n        authOverride\n      );\n\n      this.server_ = this.persistentConnection_;\n    }\n\n    authTokenProvider.addTokenChangeListener(token => {\n      this.server_.refreshAuthToken(token);\n    });\n\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n    this.statsReporter_ = StatsManager.getOrCreateReporter(\n      repoInfo_,\n      () => new StatsReporter(this.stats_, this.server_)\n    );\n\n    this.transactions_init_();\n\n    // Used for .info.\n    this.infoData_ = new SnapshotHolder();\n    this.infoSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        let infoEvents: Event[] = [];\n        const node = this.infoData_.getNode(query.path);\n        // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n        // on initial data...\n        if (!node.isEmpty()) {\n          infoEvents = this.infoSyncTree_.applyServerOverwrite(\n            query.path,\n            node\n          );\n          setTimeout(() => {\n            onComplete('ok');\n          }, 0);\n        }\n        return infoEvents;\n      },\n      stopListening: () => {}\n    });\n    this.updateInfo_('connected', false);\n\n    this.serverSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        this.server_.listen(query, currentHashFn, tag, (status, data) => {\n          const events = onComplete(status, data);\n          this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n        });\n        // No synchronous events for network-backed sync trees\n        return [];\n      },\n      stopListening: (query, tag) => {\n        this.server_.unlisten(query, tag);\n      }\n    });\n  }\n\n  /**\n   * @return {string}  The URL corresponding to the root of this Firebase.\n   */\n  toString(): string {\n    return (\n      (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host\n    );\n  }\n\n  /**\n   * @return {!string} The namespace represented by the repo.\n   */\n  name(): string {\n    return this.repoInfo_.namespace;\n  }\n\n  /**\n   * @return {!number} The time in milliseconds, taking the server offset into account if we have one.\n   */\n  serverTime(): number {\n    const offsetNode = this.infoData_.getNode(\n      new Path('.info/serverTimeOffset')\n    );\n    const offset = (offsetNode.val() as number) || 0;\n    return new Date().getTime() + offset;\n  }\n\n  /**\n   * Generate ServerValues using some variables from the repo object.\n   * @return {!Object}\n   */\n  generateServerValues(): Object {\n    return generateWithValues({\n      timestamp: this.serverTime()\n    });\n  }\n\n  /**\n   * Called by realtime when we get new messages from the server.\n   *\n   * @private\n   * @param {string} pathString\n   * @param {*} data\n   * @param {boolean} isMerge\n   * @param {?number} tag\n   */\n  private onDataUpdate_(\n    pathString: string,\n    data: any,\n    isMerge: boolean,\n    tag: number | null\n  ) {\n    // For testing.\n    this.dataUpdateCount++;\n    const path = new Path(pathString);\n    data = this.interceptServerDataCallback_\n      ? this.interceptServerDataCallback_(pathString, data)\n      : data;\n    let events = [];\n    if (tag) {\n      if (isMerge) {\n        const taggedChildren = map(data as { [k: string]: any }, (raw: any) =>\n          nodeFromJSON(raw)\n        );\n        events = this.serverSyncTree_.applyTaggedQueryMerge(\n          path,\n          taggedChildren,\n          tag\n        );\n      } else {\n        const taggedSnap = nodeFromJSON(data);\n        events = this.serverSyncTree_.applyTaggedQueryOverwrite(\n          path,\n          taggedSnap,\n          tag\n        );\n      }\n    } else if (isMerge) {\n      const changedChildren = map(data as { [k: string]: any }, (raw: any) =>\n        nodeFromJSON(raw)\n      );\n      events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n    } else {\n      const snap = nodeFromJSON(data);\n      events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n    }\n    let affectedPath = path;\n    if (events.length > 0) {\n      // Since we have a listener outstanding for each transaction, receiving any events\n      // is a proxy for some change having occurred.\n      affectedPath = this.rerunTransactions_(path);\n    }\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n  }\n\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @param {?function(!string, *):*} callback\n   * @private\n   */\n  interceptServerData_(callback: ((a: string, b: any) => any) | null) {\n    this.interceptServerDataCallback_ = callback;\n  }\n\n  /**\n   * @param {!boolean} connectStatus\n   * @private\n   */\n  private onConnectStatus_(connectStatus: boolean) {\n    this.updateInfo_('connected', connectStatus);\n    if (connectStatus === false) {\n      this.runOnDisconnectEvents_();\n    }\n  }\n\n  /**\n   * @param {!Object} updates\n   * @private\n   */\n  private onServerInfoUpdate_(updates: Object) {\n    each(updates, (value: any, key: string) => {\n      this.updateInfo_(key, value);\n    });\n  }\n\n  /**\n   *\n   * @param {!string} pathString\n   * @param {*} value\n   * @private\n   */\n  private updateInfo_(pathString: string, value: any) {\n    const path = new Path('/.info/' + pathString);\n    const newNode = nodeFromJSON(value);\n    this.infoData_.updateSnapshot(path, newNode);\n    const events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n  }\n\n  /**\n   * @return {!number}\n   * @private\n   */\n  private getNextWriteId_(): number {\n    return this.nextWriteId_++;\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} newVal\n   * @param {number|string|null} newPriority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  setWithPriority(\n    path: Path,\n    newVal: any,\n    newPriority: number | string | null,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.log_('set', {\n      path: path.toString(),\n      value: newVal,\n      priority: newPriority\n    });\n\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n\n    const writeId = this.getNextWriteId_();\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      writeId,\n      true\n    );\n    this.eventQueue_.queueEvents(events);\n    this.server_.put(\n      path.toString(),\n      newNodeUnresolved.val(/*export=*/ true),\n      (status, errorReason) => {\n        const success = status === 'ok';\n        if (!success) {\n          warn('set at ' + path + ' failed: ' + status);\n        }\n\n        const clearEvents = this.serverSyncTree_.ackUserWrite(\n          writeId,\n          !success\n        );\n        this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n    const affectedPath = this.abortTransactions_(path);\n    this.rerunTransactions_(affectedPath);\n    // We queued the events above, so just flush the queue here\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {!Object} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  update(\n    path: Path,\n    childrenToMerge: { [k: string]: any },\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.log_('update', { path: path.toString(), value: childrenToMerge });\n\n    // Start with our existing data and merge each child into it.\n    let empty = true;\n    const serverValues = this.generateServerValues();\n    const changedChildren: { [k: string]: Node } = {};\n    forEach(childrenToMerge, (changedKey: string, changedValue: any) => {\n      empty = false;\n      const newNodeUnresolved = nodeFromJSON(changedValue);\n      changedChildren[changedKey] = resolveDeferredValueSnapshot(\n        newNodeUnresolved,\n        serverValues\n      );\n    });\n\n    if (!empty) {\n      const writeId = this.getNextWriteId_();\n      const events = this.serverSyncTree_.applyUserMerge(\n        path,\n        changedChildren,\n        writeId\n      );\n      this.eventQueue_.queueEvents(events);\n      this.server_.merge(\n        path.toString(),\n        childrenToMerge,\n        (status, errorReason) => {\n          const success = status === 'ok';\n          if (!success) {\n            warn('update at ' + path + ' failed: ' + status);\n          }\n\n          const clearEvents = this.serverSyncTree_.ackUserWrite(\n            writeId,\n            !success\n          );\n          const affectedPath =\n            clearEvents.length > 0 ? this.rerunTransactions_(path) : path;\n          this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n          this.callOnCompleteCallback(onComplete, status, errorReason);\n        }\n      );\n\n      forEach(childrenToMerge, (changedPath: string) => {\n        const affectedPath = this.abortTransactions_(path.child(changedPath));\n        this.rerunTransactions_(affectedPath);\n      });\n\n      // We queued the events above, so just flush the queue here\n      this.eventQueue_.raiseEventsForChangedPath(path, []);\n    } else {\n      log(\"update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n    }\n  }\n\n  /**\n   * Applies all of the changes stored up in the onDisconnect_ tree.\n   * @private\n   */\n  private runOnDisconnectEvents_() {\n    this.log_('onDisconnectEvents');\n\n    const serverValues = this.generateServerValues();\n    const resolvedOnDisconnectTree = resolveDeferredValueTree(\n      this.onDisconnect_,\n      serverValues\n    );\n    let events: Event[] = [];\n\n    resolvedOnDisconnectTree.forEachTree(Path.Empty, (path, snap) => {\n      events = events.concat(\n        this.serverSyncTree_.applyServerOverwrite(path, snap)\n      );\n      const affectedPath = this.abortTransactions_(path);\n      this.rerunTransactions_(affectedPath);\n    });\n\n    this.onDisconnect_ = new SparseSnapshotTree();\n    this.eventQueue_.raiseEventsForChangedPath(Path.Empty, events);\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectCancel(\n    path: Path,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.server_.onDisconnectCancel(path.toString(), (status, errorReason) => {\n      if (status === 'ok') {\n        this.onDisconnect_.forget(path);\n      }\n      this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectSet(\n    path: Path,\n    value: any,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    const newNode = nodeFromJSON(value);\n    this.server_.onDisconnectPut(\n      path.toString(),\n      newNode.val(/*export=*/ true),\n      (status, errorReason) => {\n        if (status === 'ok') {\n          this.onDisconnect_.remember(path, newNode);\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {*} priority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectSetWithPriority(\n    path: Path,\n    value: any,\n    priority: any,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    const newNode = nodeFromJSON(value, priority);\n    this.server_.onDisconnectPut(\n      path.toString(),\n      newNode.val(/*export=*/ true),\n      (status, errorReason) => {\n        if (status === 'ok') {\n          this.onDisconnect_.remember(path, newNode);\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectUpdate(\n    path: Path,\n    childrenToMerge: { [k: string]: any },\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    if (isEmpty(childrenToMerge)) {\n      log(\n        \"onDisconnect().update() called with empty data.  Don't do anything.\"\n      );\n      this.callOnCompleteCallback(onComplete, 'ok');\n      return;\n    }\n\n    this.server_.onDisconnectMerge(\n      path.toString(),\n      childrenToMerge,\n      (status, errorReason) => {\n        if (status === 'ok') {\n          forEach(childrenToMerge, (childName: string, childNode: any) => {\n            const newChildNode = nodeFromJSON(childNode);\n            this.onDisconnect_.remember(path.child(childName), newChildNode);\n          });\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   */\n  addEventCallbackForQuery(query: Query, eventRegistration: EventRegistration) {\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.addEventRegistration(\n        query,\n        eventRegistration\n      );\n    } else {\n      events = this.serverSyncTree_.addEventRegistration(\n        query,\n        eventRegistration\n      );\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  /**\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration\n   */\n  removeEventCallbackForQuery(\n    query: Query,\n    eventRegistration: EventRegistration\n  ) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.removeEventRegistration(\n        query,\n        eventRegistration\n      );\n    } else {\n      events = this.serverSyncTree_.removeEventRegistration(\n        query,\n        eventRegistration\n      );\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  interrupt() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n  }\n\n  resume() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n  }\n\n  stats(showDelta: boolean = false) {\n    if (typeof console === 'undefined') return;\n\n    let stats: { [k: string]: any };\n    if (showDelta) {\n      if (!this.statsListener_)\n        this.statsListener_ = new StatsListener(this.stats_);\n      stats = this.statsListener_.get();\n    } else {\n      stats = this.stats_.get();\n    }\n\n    const longestName = Object.keys(stats).reduce(\n      (previousValue, currentValue) =>\n        Math.max(currentValue.length, previousValue),\n      0\n    );\n\n    forEach(stats, (stat: string, value: any) => {\n      // pad stat names to be the same length (plus 2 extra spaces).\n      for (let i = stat.length; i < longestName + 2; i++) stat += ' ';\n      console.log(stat + value);\n    });\n  }\n\n  statsIncrementCounter(metric: string) {\n    this.stats_.incrementCounter(metric);\n    this.statsReporter_.includeStat(metric);\n  }\n\n  /**\n   * @param {...*} var_args\n   * @private\n   */\n  private log_(...var_args: any[]) {\n    let prefix = '';\n    if (this.persistentConnection_) {\n      prefix = this.persistentConnection_.id + ':';\n    }\n    log(prefix, ...var_args);\n  }\n\n  /**\n   * @param {?function(?Error, *=)} callback\n   * @param {!string} status\n   * @param {?string=} errorReason\n   */\n  callOnCompleteCallback(\n    callback: ((status: Error | null, errorReason?: string) => void) | null,\n    status: string,\n    errorReason?: string | null\n  ) {\n    if (callback) {\n      exceptionGuard(function() {\n        if (status == 'ok') {\n          callback(null);\n        } else {\n          const code = (status || 'error').toUpperCase();\n          let message = code;\n          if (errorReason) message += ': ' + errorReason;\n\n          const error = new Error(message);\n          (error as any).code = code;\n          callback(error);\n        }\n      });\n    }\n  }\n\n  get database(): Database {\n    return this.__database || (this.__database = new Database(this));\n  }\n}\n"]},"metadata":{},"sourceType":"script"}