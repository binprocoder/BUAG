{"ast":null,"code":"import * as constants from './constants';\nimport * as errorsExports from './error';\nimport { FailRequest } from './failrequest';\nimport { Location } from './location';\nimport * as promiseimpl from './promise_external';\nimport { RequestMap } from './requestmap';\nimport * as type from './type';\n/**\r\n * @param app If null, getAuthToken always resolves with null.\r\n * @param service The storage service associated with this auth wrapper.\r\n *     Untyped to avoid circular type dependencies.\r\n * @struct\r\n */\n\nvar AuthWrapper =\n/** @class */\nfunction () {\n  function AuthWrapper(app, maker, requestMaker, service, pool) {\n    this.bucket_ = null;\n    this.deleted_ = false;\n    this.app_ = app;\n\n    if (this.app_ !== null) {\n      var options = this.app_.options;\n\n      if (type.isDef(options)) {\n        this.bucket_ = AuthWrapper.extractBucket_(options);\n      }\n    }\n\n    this.storageRefMaker_ = maker;\n    this.requestMaker_ = requestMaker;\n    this.pool_ = pool;\n    this.service_ = service;\n    this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n    this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n    this.requestMap_ = new RequestMap();\n  }\n\n  AuthWrapper.extractBucket_ = function (config) {\n    var bucketString = config[constants.configOption] || null;\n\n    if (bucketString == null) {\n      return null;\n    }\n\n    var loc = Location.makeFromBucketSpec(bucketString);\n    return loc.bucket;\n  };\n\n  AuthWrapper.prototype.getAuthToken = function () {\n    // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n    // (b/28673818).\n    if (this.app_ !== null && type.isDef(this.app_.INTERNAL) && type.isDef(this.app_.INTERNAL.getToken)) {\n      return this.app_.INTERNAL.getToken().then(function (response) {\n        if (response !== null) {\n          return response.accessToken;\n        } else {\n          return null;\n        }\n      }, function (_error) {\n        return null;\n      });\n    } else {\n      return promiseimpl.resolve(null);\n    }\n  };\n\n  AuthWrapper.prototype.bucket = function () {\n    if (this.deleted_) {\n      throw errorsExports.appDeleted();\n    } else {\n      return this.bucket_;\n    }\n  };\n  /**\r\n   * The service associated with this auth wrapper. Untyped to avoid circular\r\n   * type dependencies.\r\n   */\n\n\n  AuthWrapper.prototype.service = function () {\n    return this.service_;\n  };\n  /**\r\n   * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\r\n   * at the given Location.\r\n   * @param loc The Location.\r\n   * @return Actually a firebaseStorage.Reference, typing not allowed\r\n   *     because of circular dependency problems.\r\n   */\n\n\n  AuthWrapper.prototype.makeStorageReference = function (loc) {\n    return this.storageRefMaker_(this, loc);\n  };\n\n  AuthWrapper.prototype.makeRequest = function (requestInfo, authToken) {\n    if (!this.deleted_) {\n      var request = this.requestMaker_(requestInfo, authToken, this.pool_);\n      this.requestMap_.addRequest(request);\n      return request;\n    } else {\n      return new FailRequest(errorsExports.appDeleted());\n    }\n  };\n  /**\r\n   * Stop running requests and prevent more from being created.\r\n   */\n\n\n  AuthWrapper.prototype.deleteApp = function () {\n    this.deleted_ = true;\n    this.app_ = null;\n    this.requestMap_.clear();\n  };\n\n  AuthWrapper.prototype.maxUploadRetryTime = function () {\n    return this.maxUploadRetryTime_;\n  };\n\n  AuthWrapper.prototype.setMaxUploadRetryTime = function (time) {\n    this.maxUploadRetryTime_ = time;\n  };\n\n  AuthWrapper.prototype.maxOperationRetryTime = function () {\n    return this.maxOperationRetryTime_;\n  };\n\n  AuthWrapper.prototype.setMaxOperationRetryTime = function (time) {\n    this.maxOperationRetryTime_ = time;\n  };\n\n  return AuthWrapper;\n}();\n\nexport { AuthWrapper };","map":{"version":3,"mappings":"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","names":["constants","errorsExports","FailRequest","Location","promiseimpl","RequestMap","type","app","maker","requestMaker","service","pool","app_","options","isDef","bucket_","AuthWrapper","extractBucket_","storageRefMaker_","requestMaker_","pool_","service_","maxOperationRetryTime_","defaultMaxOperationRetryTime","maxUploadRetryTime_","defaultMaxUploadRetryTime","requestMap_","config","bucketString","configOption","loc","makeFromBucketSpec","bucket","INTERNAL","getToken","then","response","accessToken","_error","resolve","deleted_","appDeleted","requestInfo","authToken","request","addRequest","clear","time"],"sources":["../src/implementation/authwrapper.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Reference } from '../reference';\nimport { Service } from '../service';\nimport * as constants from './constants';\nimport * as errorsExports from './error';\nimport { errors } from './error';\nimport { FailRequest } from './failrequest';\nimport { Location } from './location';\nimport * as promiseimpl from './promise_external';\nimport { Request } from './request';\nimport { RequestInfo } from './requestinfo';\nimport { requestMaker } from './requestmaker';\nimport { RequestMap } from './requestmap';\nimport * as type from './type';\nimport { XhrIoPool } from './xhriopool';\nimport { FirebaseApp, FirebaseAuthTokenData } from '@firebase/app';\n\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nexport class AuthWrapper {\n  private app_: FirebaseApp | null;\n  private bucket_: string | null = null;\n\n  /**\n  maker\n     */\n  private storageRefMaker_: (p1: AuthWrapper, p2: Location) => Reference;\n  private requestMaker_: requestMaker;\n  private pool_: XhrIoPool;\n  private service_: Service;\n  private maxOperationRetryTime_: number;\n  private maxUploadRetryTime_: number;\n  private requestMap_: RequestMap;\n  private deleted_: boolean = false;\n\n  constructor(\n    app: FirebaseApp | null,\n    maker: (p1: AuthWrapper, p2: Location) => Reference,\n    requestMaker: requestMaker,\n    service: Service,\n    pool: XhrIoPool\n  ) {\n    this.app_ = app;\n    if (this.app_ !== null) {\n      let options = this.app_.options;\n      if (type.isDef(options)) {\n        this.bucket_ = AuthWrapper.extractBucket_(options);\n      }\n    }\n    this.storageRefMaker_ = maker;\n    this.requestMaker_ = requestMaker;\n    this.pool_ = pool;\n    this.service_ = service;\n    this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n    this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n    this.requestMap_ = new RequestMap();\n  }\n\n  private static extractBucket_(config: {\n    [prop: string]: any;\n  }): string | null {\n    let bucketString = config[constants.configOption] || null;\n    if (bucketString == null) {\n      return null;\n    }\n    let loc: Location = Location.makeFromBucketSpec(bucketString);\n    return loc.bucket;\n  }\n\n  getAuthToken(): Promise<string | null> {\n    // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n    // (b/28673818).\n    if (\n      this.app_ !== null &&\n      type.isDef(this.app_.INTERNAL) &&\n      type.isDef(this.app_.INTERNAL.getToken)\n    ) {\n      return this.app_.INTERNAL.getToken().then(\n        function(response: FirebaseAuthTokenData | null): string | null {\n          if (response !== null) {\n            return response.accessToken;\n          } else {\n            return null;\n          }\n        },\n        function(_error) {\n          return null;\n        }\n      );\n    } else {\n      return promiseimpl.resolve(null) as Promise<string | null>;\n    }\n  }\n\n  bucket(): string | null {\n    if (this.deleted_) {\n      throw errorsExports.appDeleted();\n    } else {\n      return this.bucket_;\n    }\n  }\n\n  /**\n   * The service associated with this auth wrapper. Untyped to avoid circular\n   * type dependencies.\n   */\n  service(): Service {\n    return this.service_;\n  }\n\n  /**\n   * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n   * at the given Location.\n   * @param loc The Location.\n   * @return Actually a firebaseStorage.Reference, typing not allowed\n   *     because of circular dependency problems.\n   */\n  makeStorageReference(loc: Location): Reference {\n    return this.storageRefMaker_(this, loc);\n  }\n\n  makeRequest<T>(\n    requestInfo: RequestInfo<T>,\n    authToken: string | null\n  ): Request<T> {\n    if (!this.deleted_) {\n      let request = this.requestMaker_(requestInfo, authToken, this.pool_);\n      this.requestMap_.addRequest(request);\n      return request;\n    } else {\n      return new FailRequest(errorsExports.appDeleted());\n    }\n  }\n\n  /**\n   * Stop running requests and prevent more from being created.\n   */\n  deleteApp() {\n    this.deleted_ = true;\n    this.app_ = null;\n    this.requestMap_.clear();\n  }\n\n  maxUploadRetryTime(): number {\n    return this.maxUploadRetryTime_;\n  }\n\n  setMaxUploadRetryTime(time: number) {\n    this.maxUploadRetryTime_ = time;\n  }\n\n  maxOperationRetryTime(): number {\n    return this.maxOperationRetryTime_;\n  }\n\n  setMaxOperationRetryTime(time: number) {\n    this.maxOperationRetryTime_ = time;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}