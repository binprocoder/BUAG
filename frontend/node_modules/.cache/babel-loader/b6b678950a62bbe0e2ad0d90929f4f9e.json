{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\n\nfunction createSubscribe(executor, onNoObservers) {\n  var proxy = new ObserverProxy(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\nexports.createSubscribe = createSubscribe;\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\n\nvar ObserverProxy =\n/** @class */\nfunction () {\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  function ObserverProxy(executor, onNoObservers) {\n    var _this = this;\n\n    this.observers = [];\n    this.unsubscribes = [];\n    this.observerCount = 0; // Micro-task scheduling by calling task.then().\n\n    this.task = Promise.resolve();\n    this.finalized = false;\n    this.onNoObservers = onNoObservers; // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n\n    this.task.then(function () {\n      executor(_this);\n    }).catch(function (e) {\n      _this.error(e);\n    });\n  }\n\n  ObserverProxy.prototype.next = function (value) {\n    this.forEachObserver(function (observer) {\n      observer.next(value);\n    });\n  };\n\n  ObserverProxy.prototype.error = function (error) {\n    this.forEachObserver(function (observer) {\n      observer.error(error);\n    });\n    this.close(error);\n  };\n\n  ObserverProxy.prototype.complete = function () {\n    this.forEachObserver(function (observer) {\n      observer.complete();\n    });\n    this.close();\n  };\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n\n\n  ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {\n    var _this = this;\n\n    var observer;\n\n    if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n      throw new Error('Missing Observer.');\n    } // Assemble an Observer object when passed as callback functions.\n\n\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver;\n    } else {\n      observer = {\n        next: nextOrObserver,\n        error: error,\n        complete: complete\n      };\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop;\n    }\n\n    if (observer.error === undefined) {\n      observer.error = noop;\n    }\n\n    if (observer.complete === undefined) {\n      observer.complete = noop;\n    }\n\n    var unsub = this.unsubscribeOne.bind(this, this.observers.length); // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n\n    if (this.finalized) {\n      this.task.then(function () {\n        try {\n          if (_this.finalError) {\n            observer.error(_this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {// nothing\n        }\n\n        return;\n      });\n    }\n\n    this.observers.push(observer);\n    return unsub;\n  }; // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n\n\n  ObserverProxy.prototype.unsubscribeOne = function (i) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n    this.observerCount -= 1;\n\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  };\n\n  ObserverProxy.prototype.forEachObserver = function (fn) {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    } // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n\n\n    for (var i = 0; i < this.observers.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }; // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n\n\n  ObserverProxy.prototype.sendOne = function (i, fn) {\n    var _this = this; // Execute the callback asynchronously\n\n\n    this.task.then(function () {\n      if (_this.observers !== undefined && _this.observers[i] !== undefined) {\n        try {\n          fn(_this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  };\n\n  ObserverProxy.prototype.close = function (err) {\n    var _this = this;\n\n    if (this.finalized) {\n      return;\n    }\n\n    this.finalized = true;\n\n    if (err !== undefined) {\n      this.finalError = err;\n    } // Proxy is no longer needed - garbage collect references\n\n\n    this.task.then(function () {\n      _this.observers = undefined;\n      _this.onNoObservers = undefined;\n    });\n  };\n\n  return ObserverProxy;\n}();\n/** Turn synchronous function into one called asynchronously. */\n\n\nfunction async(fn, onError) {\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    Promise.resolve(true).then(function () {\n      fn.apply(void 0, args);\n    }).catch(function (error) {\n      if (onError) {\n        onError(error);\n      }\n    });\n  };\n}\n\nexports.async = async;\n/**\n * Return true if the object passed in implements any of the named methods.\n */\n\nfunction implementsAnyMethods(obj, methods) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\n    var method = methods_1[_i];\n\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop() {// do nothing\n}","map":{"version":3,"mappings":"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","names":["executor","onNoObservers","proxy","ObserverProxy","subscribe","bind","exports","Promise","resolve","task","then","_this","catch","error","e","value","forEachObserver","observer","next","close","complete","nextOrObserver","undefined","Error","implementsAnyMethods","noop","unsub","unsubscribeOne","observers","length","finalized","finalError","push","i","observerCount","fn","sendOne","console","err","onError","args","obj","methods","_i","method"],"sources":["../src/subscribe.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: Error) => void;\nexport type CompleteFn = () => void;\n\nexport interface Observer<T> {\n  // Called once for each value in a stream of values.\n  next: NextFn<T>;\n\n  // A stream terminates by a single call to EITHER error() or complete().\n  error: ErrorFn;\n\n  // No events will be sent to next() once complete() is called.\n  complete: CompleteFn;\n}\n\n// Allow for any of the Observer methods to be undefined.\nexport interface PartialObserver<T> {\n  next?: NextFn<T>;\n  error?: ErrorFn;\n  complete?: CompleteFn;\n}\n\n// TODO: Support also Unsubscribe.unsubscribe?\nexport type Unsubscribe = () => void;\n\n/**\n * The Subscribe interface has two forms - passing the inline function\n * callbacks, or a object interface with callback properties.\n */\nexport interface Subscribe<T> {\n  (next?: NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;\n  (observer: PartialObserver<T>): Unsubscribe;\n}\n\nexport interface Observable<T> {\n  // Subscribe method\n  subscribe: Subscribe<T>;\n}\n\nexport type Executor<T> = (observer: Observer<T>) => void;\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe<T>(\n  executor: Executor<T>,\n  onNoObservers?: Executor<T>\n): Subscribe<T> {\n  let proxy = new ObserverProxy<T>(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy<T> implements Observer<T> {\n  private observers: Array<Observer<T>> | undefined = [];\n  private unsubscribes: Unsubscribe[] = [];\n  private onNoObservers: Executor<T> | undefined;\n  private observerCount = 0;\n  // Micro-task scheduling by calling task.then().\n  private task = Promise.resolve();\n  private finalized = false;\n  private finalError: Error;\n\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) {\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task\n      .then(() => {\n        executor(this);\n      })\n      .catch(e => {\n        this.error(e);\n      });\n  }\n\n  next(value: T) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.next(value);\n    });\n  }\n\n  error(error: Error) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete() {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.complete();\n    });\n    this.close();\n  }\n\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(\n    nextOrObserver: PartialObserver<T> | Function,\n    error?: ErrorFn,\n    complete?: CompleteFn\n  ): Unsubscribe {\n    let observer: Observer<T>;\n\n    if (\n      nextOrObserver === undefined &&\n      error === undefined &&\n      complete === undefined\n    ) {\n      throw new Error('Missing Observer.');\n    }\n\n    // Assemble an Observer object when passed as callback functions.\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver as Observer<T>;\n    } else {\n      observer = {\n        next: (nextOrObserver as any) as NextFn<T>,\n        error: error,\n        complete: complete\n      } as Observer<T>;\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop as NextFn<T>;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop as ErrorFn;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop as CompleteFn;\n    }\n\n    let unsub = this.unsubscribeOne.bind(this, this.observers!.length);\n\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n\n    this.observers!.push(observer as Observer<T>);\n\n    return unsub;\n  }\n\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  private unsubscribeOne(i: number) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  private forEachObserver(fn: (observer: Observer<T>) => void): void {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (let i = 0; i < this.observers!.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  private sendOne(i: number, fn: (observer: Observer<T>) => void): void {\n    // Execute the callback asynchronously\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  private close(err?: Error): void {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n}\n\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn: Function, onError?: ErrorFn): Function {\n  return (...args: any[]) => {\n    Promise.resolve(true)\n      .then(() => {\n        fn(...args);\n      })\n      .catch((error: Error) => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  };\n}\n\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj: any, methods: string[]): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (let method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop(): void {\n  // do nothing\n}\n"]},"metadata":{},"sourceType":"script"}