{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar onDisconnect_1 = require(\"./onDisconnect\");\n\nvar TransactionResult_1 = require(\"./TransactionResult\");\n\nvar util_1 = require(\"../core/util/util\");\n\nvar NextPushId_1 = require(\"../core/util/NextPushId\");\n\nvar Query_1 = require(\"./Query\");\n\nvar Repo_1 = require(\"../core/Repo\");\n\nvar Path_1 = require(\"../core/util/Path\");\n\nvar QueryParams_1 = require(\"../core/view/QueryParams\");\n\nvar validation_1 = require(\"../core/util/validation\");\n\nvar util_2 = require(\"@firebase/util\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar SyncPoint_1 = require(\"../core/SyncPoint\");\n\nvar Reference =\n/** @class */\nfunction (_super) {\n  __extends(Reference, _super);\n  /**\r\n   * Call options:\r\n   *   new Reference(Repo, Path) or\r\n   *   new Reference(url: string, string|RepoManager)\r\n   *\r\n   * Externally - this is the firebase.database.Reference type.\r\n   *\r\n   * @param {!Repo} repo\r\n   * @param {(!Path)} path\r\n   * @extends {Query}\r\n   */\n\n\n  function Reference(repo, path) {\n    var _this = this;\n\n    if (!(repo instanceof Repo_1.Repo)) {\n      throw new Error('new Reference() no longer supported - use app.database().');\n    } // call Query's constructor, passing in the repo and path.\n\n\n    _this = _super.call(this, repo, path, QueryParams_1.QueryParams.DEFAULT, false) || this;\n    return _this;\n  }\n  /** @return {?string} */\n\n\n  Reference.prototype.getKey = function () {\n    util_2.validateArgCount('Reference.key', 0, 0, arguments.length);\n    if (this.path.isEmpty()) return null;else return this.path.getBack();\n  };\n  /**\r\n   * @param {!(string|Path)} pathString\r\n   * @return {!Reference}\r\n   */\n\n\n  Reference.prototype.child = function (pathString) {\n    util_2.validateArgCount('Reference.child', 1, 1, arguments.length);\n\n    if (typeof pathString === 'number') {\n      pathString = String(pathString);\n    } else if (!(pathString instanceof Path_1.Path)) {\n      if (this.path.getFront() === null) validation_1.validateRootPathString('Reference.child', 1, pathString, false);else validation_1.validatePathString('Reference.child', 1, pathString, false);\n    }\n\n    return new Reference(this.repo, this.path.child(pathString));\n  };\n  /** @return {?Reference} */\n\n\n  Reference.prototype.getParent = function () {\n    util_2.validateArgCount('Reference.parent', 0, 0, arguments.length);\n    var parentPath = this.path.parent();\n    return parentPath === null ? null : new Reference(this.repo, parentPath);\n  };\n  /** @return {!Reference} */\n\n\n  Reference.prototype.getRoot = function () {\n    util_2.validateArgCount('Reference.root', 0, 0, arguments.length);\n    var ref = this;\n\n    while (ref.getParent() !== null) {\n      ref = ref.getParent();\n    }\n\n    return ref;\n  };\n  /** @return {!Database} */\n\n\n  Reference.prototype.databaseProp = function () {\n    return this.repo.database;\n  };\n  /**\r\n   * @param {*} newVal\r\n   * @param {function(?Error)=} onComplete\r\n   * @return {!Promise}\r\n   */\n\n\n  Reference.prototype.set = function (newVal, onComplete) {\n    util_2.validateArgCount('Reference.set', 1, 2, arguments.length);\n    validation_1.validateWritablePath('Reference.set', this.path);\n    validation_1.validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);\n    util_2.validateCallback('Reference.set', 2, onComplete, true);\n    var deferred = new util_3.Deferred();\n    this.repo.setWithPriority(this.path, newVal,\n    /*priority=*/\n    null, deferred.wrapCallback(onComplete));\n    return deferred.promise;\n  };\n  /**\r\n   * @param {!Object} objectToMerge\r\n   * @param {function(?Error)=} onComplete\r\n   * @return {!Promise}\r\n   */\n\n\n  Reference.prototype.update = function (objectToMerge, onComplete) {\n    util_2.validateArgCount('Reference.update', 1, 2, arguments.length);\n    validation_1.validateWritablePath('Reference.update', this.path);\n\n    if (Array.isArray(objectToMerge)) {\n      var newObjectToMerge = {};\n\n      for (var i = 0; i < objectToMerge.length; ++i) {\n        newObjectToMerge['' + i] = objectToMerge[i];\n      }\n\n      objectToMerge = newObjectToMerge;\n      util_1.warn('Passing an Array to Firebase.update() is deprecated. ' + 'Use set() if you want to overwrite the existing data, or ' + 'an Object with integer keys if you really do want to ' + 'only update some of the children.');\n    }\n\n    validation_1.validateFirebaseMergeDataArg('Reference.update', 1, objectToMerge, this.path, false);\n    util_2.validateCallback('Reference.update', 2, onComplete, true);\n    var deferred = new util_3.Deferred();\n    this.repo.update(this.path, objectToMerge, deferred.wrapCallback(onComplete));\n    return deferred.promise;\n  };\n  /**\r\n   * @param {*} newVal\r\n   * @param {string|number|null} newPriority\r\n   * @param {function(?Error)=} onComplete\r\n   * @return {!Promise}\r\n   */\n\n\n  Reference.prototype.setWithPriority = function (newVal, newPriority, onComplete) {\n    util_2.validateArgCount('Reference.setWithPriority', 2, 3, arguments.length);\n    validation_1.validateWritablePath('Reference.setWithPriority', this.path);\n    validation_1.validateFirebaseDataArg('Reference.setWithPriority', 1, newVal, this.path, false);\n    validation_1.validatePriority('Reference.setWithPriority', 2, newPriority, false);\n    util_2.validateCallback('Reference.setWithPriority', 3, onComplete, true);\n    if (this.getKey() === '.length' || this.getKey() === '.keys') throw 'Reference.setWithPriority failed: ' + this.getKey() + ' is a read-only object.';\n    var deferred = new util_3.Deferred();\n    this.repo.setWithPriority(this.path, newVal, newPriority, deferred.wrapCallback(onComplete));\n    return deferred.promise;\n  };\n  /**\r\n   * @param {function(?Error)=} onComplete\r\n   * @return {!Promise}\r\n   */\n\n\n  Reference.prototype.remove = function (onComplete) {\n    util_2.validateArgCount('Reference.remove', 0, 1, arguments.length);\n    validation_1.validateWritablePath('Reference.remove', this.path);\n    util_2.validateCallback('Reference.remove', 1, onComplete, true);\n    return this.set(null, onComplete);\n  };\n  /**\r\n   * @param {function(*):*} transactionUpdate\r\n   * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete\r\n   * @param {boolean=} applyLocally\r\n   * @return {!Promise}\r\n   */\n\n\n  Reference.prototype.transaction = function (transactionUpdate, onComplete, applyLocally) {\n    util_2.validateArgCount('Reference.transaction', 1, 3, arguments.length);\n    validation_1.validateWritablePath('Reference.transaction', this.path);\n    util_2.validateCallback('Reference.transaction', 1, transactionUpdate, false);\n    util_2.validateCallback('Reference.transaction', 2, onComplete, true); // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how\n    // to expose it.\n\n    validation_1.validateBoolean('Reference.transaction', 3, applyLocally, true);\n    if (this.getKey() === '.length' || this.getKey() === '.keys') throw 'Reference.transaction failed: ' + this.getKey() + ' is a read-only object.';\n    if (applyLocally === undefined) applyLocally = true;\n    var deferred = new util_3.Deferred();\n\n    if (typeof onComplete === 'function') {\n      deferred.promise.catch(function () {});\n    }\n\n    var promiseComplete = function (error, committed, snapshot) {\n      if (error) {\n        deferred.reject(error);\n      } else {\n        deferred.resolve(new TransactionResult_1.TransactionResult(committed, snapshot));\n      }\n\n      if (typeof onComplete === 'function') {\n        onComplete(error, committed, snapshot);\n      }\n    };\n\n    this.repo.startTransaction(this.path, transactionUpdate, promiseComplete, applyLocally);\n    return deferred.promise;\n  };\n  /**\r\n   * @param {string|number|null} priority\r\n   * @param {function(?Error)=} onComplete\r\n   * @return {!Promise}\r\n   */\n\n\n  Reference.prototype.setPriority = function (priority, onComplete) {\n    util_2.validateArgCount('Reference.setPriority', 1, 2, arguments.length);\n    validation_1.validateWritablePath('Reference.setPriority', this.path);\n    validation_1.validatePriority('Reference.setPriority', 1, priority, false);\n    util_2.validateCallback('Reference.setPriority', 2, onComplete, true);\n    var deferred = new util_3.Deferred();\n    this.repo.setWithPriority(this.path.child('.priority'), priority, null, deferred.wrapCallback(onComplete));\n    return deferred.promise;\n  };\n  /**\r\n   * @param {*=} value\r\n   * @param {function(?Error)=} onComplete\r\n   * @return {!Reference}\r\n   */\n\n\n  Reference.prototype.push = function (value, onComplete) {\n    util_2.validateArgCount('Reference.push', 0, 2, arguments.length);\n    validation_1.validateWritablePath('Reference.push', this.path);\n    validation_1.validateFirebaseDataArg('Reference.push', 1, value, this.path, true);\n    util_2.validateCallback('Reference.push', 2, onComplete, true);\n    var now = this.repo.serverTime();\n    var name = NextPushId_1.nextPushId(now); // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.\n    // We use child() to create handles to two different references. The first is turned into a\n    // ThennableReference below by adding then() and catch() methods and is used as the\n    // return value of push(). The second remains a regular Reference and is used as the fulfilled\n    // value of the first ThennableReference.\n\n    var thennablePushRef = this.child(name);\n    var pushRef = this.child(name);\n    var promise;\n\n    if (value != null) {\n      promise = thennablePushRef.set(value, onComplete).then(function () {\n        return pushRef;\n      });\n    } else {\n      promise = Promise.resolve(pushRef);\n    }\n\n    thennablePushRef.then = promise.then.bind(promise);\n    thennablePushRef.catch = promise.then.bind(promise, undefined);\n\n    if (typeof onComplete === 'function') {\n      promise.catch(function () {});\n    }\n\n    return thennablePushRef;\n  };\n  /**\r\n   * @return {!OnDisconnect}\r\n   */\n\n\n  Reference.prototype.onDisconnect = function () {\n    validation_1.validateWritablePath('Reference.onDisconnect', this.path);\n    return new onDisconnect_1.OnDisconnect(this.repo, this.path);\n  };\n\n  Object.defineProperty(Reference.prototype, \"database\", {\n    get: function () {\n      return this.databaseProp();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"key\", {\n    get: function () {\n      return this.getKey();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"parent\", {\n    get: function () {\n      return this.getParent();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"root\", {\n    get: function () {\n      return this.getRoot();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Reference;\n}(Query_1.Query);\n\nexports.Reference = Reference;\n/**\r\n * Define reference constructor in various modules\r\n *\r\n * We are doing this here to avoid several circular\r\n * dependency issues\r\n */\n\nQuery_1.Query.__referenceConstructor = Reference;\nSyncPoint_1.SyncPoint.__referenceConstructor = Reference;","map":{"version":3,"mappings":"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","names":["__extends","repo","path","Repo_1","Error","_this","QueryParams_1","DEFAULT","Reference","util_2","arguments","length","isEmpty","getBack","pathString","String","Path_1","getFront","validation_1","child","parentPath","parent","ref","getParent","database","newVal","onComplete","deferred","util_3","setWithPriority","wrapCallback","promise","objectToMerge","Array","isArray","newObjectToMerge","i","util_1","update","newPriority","getKey","set","transactionUpdate","applyLocally","undefined","catch","promiseComplete","error","committed","snapshot","reject","resolve","TransactionResult_1","startTransaction","priority","value","now","serverTime","name","NextPushId_1","thennablePushRef","pushRef","then","Promise","bind","onDisconnect_1","Object","databaseProp","getRoot","Query_1","exports","__referenceConstructor","SyncPoint_1"],"sources":["../src/api/Reference.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OnDisconnect } from './onDisconnect';\nimport { TransactionResult } from './TransactionResult';\nimport { warn } from '../core/util/util';\nimport { nextPushId } from '../core/util/NextPushId';\nimport { Query } from './Query';\nimport { Repo } from '../core/Repo';\nimport { Path } from '../core/util/Path';\nimport { QueryParams } from '../core/view/QueryParams';\nimport {\n  validateRootPathString,\n  validatePathString,\n  validateFirebaseMergeDataArg,\n  validateBoolean,\n  validatePriority,\n  validateFirebaseDataArg,\n  validateWritablePath\n} from '../core/util/validation';\nimport { validateArgCount, validateCallback } from '@firebase/util';\nimport { Deferred } from '@firebase/util';\nimport { SyncPoint } from '../core/SyncPoint';\nimport { Database } from './Database';\nimport { DataSnapshot } from './DataSnapshot';\n\nexport interface ReferenceConstructor {\n  new (repo: Repo, path: Path): Reference;\n}\n\nexport class Reference extends Query {\n  public then: (a?: any) => Promise<any>;\n  public catch: (a?: Error) => Promise<any>;\n\n  /**\n   * Call options:\n   *   new Reference(Repo, Path) or\n   *   new Reference(url: string, string|RepoManager)\n   *\n   * Externally - this is the firebase.database.Reference type.\n   *\n   * @param {!Repo} repo\n   * @param {(!Path)} path\n   * @extends {Query}\n   */\n  constructor(repo: Repo, path: Path) {\n    if (!(repo instanceof Repo)) {\n      throw new Error(\n        'new Reference() no longer supported - use app.database().'\n      );\n    }\n\n    // call Query's constructor, passing in the repo and path.\n    super(repo, path, QueryParams.DEFAULT, false);\n  }\n\n  /** @return {?string} */\n  getKey(): string | null {\n    validateArgCount('Reference.key', 0, 0, arguments.length);\n\n    if (this.path.isEmpty()) return null;\n    else return this.path.getBack();\n  }\n\n  /**\n   * @param {!(string|Path)} pathString\n   * @return {!Reference}\n   */\n  child(pathString: string | Path): Reference {\n    validateArgCount('Reference.child', 1, 1, arguments.length);\n    if (typeof pathString === 'number') {\n      pathString = String(pathString);\n    } else if (!(pathString instanceof Path)) {\n      if (this.path.getFront() === null)\n        validateRootPathString('Reference.child', 1, pathString, false);\n      else validatePathString('Reference.child', 1, pathString, false);\n    }\n\n    return new Reference(this.repo, this.path.child(pathString));\n  }\n\n  /** @return {?Reference} */\n  getParent(): Reference | null {\n    validateArgCount('Reference.parent', 0, 0, arguments.length);\n\n    const parentPath = this.path.parent();\n    return parentPath === null ? null : new Reference(this.repo, parentPath);\n  }\n\n  /** @return {!Reference} */\n  getRoot(): Reference {\n    validateArgCount('Reference.root', 0, 0, arguments.length);\n\n    let ref = this as any;\n    while (ref.getParent() !== null) {\n      ref = ref.getParent();\n    }\n    return ref;\n  }\n\n  /** @return {!Database} */\n  databaseProp(): Database {\n    return this.repo.database;\n  }\n\n  /**\n   * @param {*} newVal\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  set(newVal: any, onComplete?: (a: Error | null) => void): Promise<any> {\n    validateArgCount('Reference.set', 1, 2, arguments.length);\n    validateWritablePath('Reference.set', this.path);\n    validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);\n    validateCallback('Reference.set', 2, onComplete, true);\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path,\n      newVal,\n      /*priority=*/ null,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {!Object} objectToMerge\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  update(\n    objectToMerge: Object,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.update', 1, 2, arguments.length);\n    validateWritablePath('Reference.update', this.path);\n\n    if (Array.isArray(objectToMerge)) {\n      const newObjectToMerge: { [k: string]: any } = {};\n      for (let i = 0; i < objectToMerge.length; ++i) {\n        newObjectToMerge['' + i] = objectToMerge[i];\n      }\n      objectToMerge = newObjectToMerge;\n      warn(\n        'Passing an Array to Firebase.update() is deprecated. ' +\n          'Use set() if you want to overwrite the existing data, or ' +\n          'an Object with integer keys if you really do want to ' +\n          'only update some of the children.'\n      );\n    }\n    validateFirebaseMergeDataArg(\n      'Reference.update',\n      1,\n      objectToMerge,\n      this.path,\n      false\n    );\n    validateCallback('Reference.update', 2, onComplete, true);\n    const deferred = new Deferred();\n    this.repo.update(\n      this.path,\n      objectToMerge,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {*} newVal\n   * @param {string|number|null} newPriority\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  setWithPriority(\n    newVal: any,\n    newPriority: string | number | null,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.setWithPriority', 2, 3, arguments.length);\n    validateWritablePath('Reference.setWithPriority', this.path);\n    validateFirebaseDataArg(\n      'Reference.setWithPriority',\n      1,\n      newVal,\n      this.path,\n      false\n    );\n    validatePriority('Reference.setWithPriority', 2, newPriority, false);\n    validateCallback('Reference.setWithPriority', 3, onComplete, true);\n\n    if (this.getKey() === '.length' || this.getKey() === '.keys')\n      throw 'Reference.setWithPriority failed: ' +\n        this.getKey() +\n        ' is a read-only object.';\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path,\n      newVal,\n      newPriority,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  remove(onComplete?: (a: Error | null) => void): Promise<any> {\n    validateArgCount('Reference.remove', 0, 1, arguments.length);\n    validateWritablePath('Reference.remove', this.path);\n    validateCallback('Reference.remove', 1, onComplete, true);\n\n    return this.set(null, onComplete);\n  }\n\n  /**\n   * @param {function(*):*} transactionUpdate\n   * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete\n   * @param {boolean=} applyLocally\n   * @return {!Promise}\n   */\n  transaction(\n    transactionUpdate: (a: any) => any,\n    onComplete?: (a: Error | null, b: boolean, c: DataSnapshot | null) => void,\n    applyLocally?: boolean\n  ): Promise<TransactionResult> {\n    validateArgCount('Reference.transaction', 1, 3, arguments.length);\n    validateWritablePath('Reference.transaction', this.path);\n    validateCallback('Reference.transaction', 1, transactionUpdate, false);\n    validateCallback('Reference.transaction', 2, onComplete, true);\n    // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how\n    // to expose it.\n    validateBoolean('Reference.transaction', 3, applyLocally, true);\n\n    if (this.getKey() === '.length' || this.getKey() === '.keys')\n      throw 'Reference.transaction failed: ' +\n        this.getKey() +\n        ' is a read-only object.';\n\n    if (applyLocally === undefined) applyLocally = true;\n\n    const deferred = new Deferred<TransactionResult>();\n    if (typeof onComplete === 'function') {\n      deferred.promise.catch(() => {});\n    }\n\n    const promiseComplete = function(\n      error: Error,\n      committed: boolean,\n      snapshot: DataSnapshot\n    ) {\n      if (error) {\n        deferred.reject(error);\n      } else {\n        deferred.resolve(new TransactionResult(committed, snapshot));\n      }\n      if (typeof onComplete === 'function') {\n        onComplete(error, committed, snapshot);\n      }\n    };\n    this.repo.startTransaction(\n      this.path,\n      transactionUpdate,\n      promiseComplete,\n      applyLocally\n    );\n\n    return deferred.promise;\n  }\n\n  /**\n   * @param {string|number|null} priority\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  setPriority(\n    priority: string | number | null,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.setPriority', 1, 2, arguments.length);\n    validateWritablePath('Reference.setPriority', this.path);\n    validatePriority('Reference.setPriority', 1, priority, false);\n    validateCallback('Reference.setPriority', 2, onComplete, true);\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path.child('.priority'),\n      priority,\n      null,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {*=} value\n   * @param {function(?Error)=} onComplete\n   * @return {!Reference}\n   */\n  push(value?: any, onComplete?: (a: Error | null) => void): Reference {\n    validateArgCount('Reference.push', 0, 2, arguments.length);\n    validateWritablePath('Reference.push', this.path);\n    validateFirebaseDataArg('Reference.push', 1, value, this.path, true);\n    validateCallback('Reference.push', 2, onComplete, true);\n\n    const now = this.repo.serverTime();\n    const name = nextPushId(now);\n\n    // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.\n    // We use child() to create handles to two different references. The first is turned into a\n    // ThennableReference below by adding then() and catch() methods and is used as the\n    // return value of push(). The second remains a regular Reference and is used as the fulfilled\n    // value of the first ThennableReference.\n    const thennablePushRef = this.child(name);\n    const pushRef = this.child(name);\n\n    let promise;\n    if (value != null) {\n      promise = thennablePushRef.set(value, onComplete).then(() => pushRef);\n    } else {\n      promise = Promise.resolve(pushRef);\n    }\n\n    thennablePushRef.then = promise.then.bind(promise);\n    thennablePushRef.catch = promise.then.bind(promise, undefined);\n\n    if (typeof onComplete === 'function') {\n      promise.catch(() => {});\n    }\n\n    return thennablePushRef;\n  }\n\n  /**\n   * @return {!OnDisconnect}\n   */\n  onDisconnect(): OnDisconnect {\n    validateWritablePath('Reference.onDisconnect', this.path);\n    return new OnDisconnect(this.repo, this.path);\n  }\n\n  get database(): Database {\n    return this.databaseProp();\n  }\n\n  get key(): string | null {\n    return this.getKey();\n  }\n\n  get parent(): Reference | null {\n    return this.getParent();\n  }\n\n  get root(): Reference {\n    return this.getRoot();\n  }\n}\n\n/**\n * Define reference constructor in various modules\n *\n * We are doing this here to avoid several circular\n * dependency issues\n */\nQuery.__referenceConstructor = Reference;\nSyncPoint.__referenceConstructor = Reference;\n"]},"metadata":{},"sourceType":"script"}