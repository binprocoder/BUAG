{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"../core/util/util\");\n\nvar storage_1 = require(\"../core/storage/storage\");\n\nvar Constants_1 = require(\"./Constants\");\n\nvar TransportManager_1 = require(\"./TransportManager\"); // Abort upgrade attempt if it takes longer than 60s.\n\n\nvar UPGRADE_TIMEOUT = 60000; // For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\n\nvar DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000; // If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\n\nvar BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nvar BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\nvar MESSAGE_TYPE = 't';\nvar MESSAGE_DATA = 'd';\nvar CONTROL_SHUTDOWN = 's';\nvar CONTROL_RESET = 'r';\nvar CONTROL_ERROR = 'e';\nvar CONTROL_PONG = 'o';\nvar SWITCH_ACK = 'a';\nvar END_TRANSMISSION = 'n';\nvar PING = 'p';\nvar SERVER_HELLO = 'h';\n/**\r\n * Creates a new real-time connection to the server using whichever method works\r\n * best in the current browser.\r\n *\r\n * @constructor\r\n */\n\nvar Connection =\n/** @class */\nfunction () {\n  /**\r\n   * @param {!string} id - an id for this connection\r\n   * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to\r\n   * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives\r\n   * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.\r\n   * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost\r\n   * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.\r\n   * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\r\n   */\n  function Connection(id, repoInfo_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {\n    this.id = id;\n    this.repoInfo_ = repoInfo_;\n    this.onMessage_ = onMessage_;\n    this.onReady_ = onReady_;\n    this.onDisconnect_ = onDisconnect_;\n    this.onKill_ = onKill_;\n    this.lastSessionId = lastSessionId;\n    this.connectionCount = 0;\n    this.pendingDataMessages = [];\n    this.state_ = 0\n    /* CONNECTING */\n    ;\n    this.log_ = util_1.logWrapper('c:' + this.id + ':');\n    this.transportManager_ = new TransportManager_1.TransportManager(repoInfo_);\n    this.log_('Connection created');\n    this.start_();\n  }\n  /**\r\n   * Starts a connection attempt\r\n   * @private\r\n   */\n\n\n  Connection.prototype.start_ = function () {\n    var _this = this;\n\n    var conn = this.transportManager_.initialTransport();\n    this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, undefined, this.lastSessionId); // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n\n    this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\n    var onMessageReceived = this.connReceiver_(this.conn_);\n    var onConnectionLost = this.disconnReceiver_(this.conn_);\n    this.tx_ = this.conn_;\n    this.rx_ = this.conn_;\n    this.secondaryConn_ = null;\n    this.isHealthy_ = false;\n    /*\r\n     * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\r\n     * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\r\n     * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\r\n     * still have the context of your originating frame.\r\n     */\n\n    setTimeout(function () {\n      // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n      _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);\n    }, Math.floor(0));\n    var healthyTimeout_ms = conn['healthyTimeout'] || 0;\n\n    if (healthyTimeout_ms > 0) {\n      this.healthyTimeout_ = util_1.setTimeoutNonBlocking(function () {\n        _this.healthyTimeout_ = null;\n\n        if (!_this.isHealthy_) {\n          if (_this.conn_ && _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {\n            _this.log_('Connection exceeded healthy timeout but has received ' + _this.conn_.bytesReceived + ' bytes.  Marking connection healthy.');\n\n            _this.isHealthy_ = true;\n\n            _this.conn_.markConnectionHealthy();\n          } else if (_this.conn_ && _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {\n            _this.log_('Connection exceeded healthy timeout but has sent ' + _this.conn_.bytesSent + ' bytes.  Leaving connection alive.'); // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n            // the server.\n\n          } else {\n            _this.log_('Closing unhealthy connection after timeout.');\n\n            _this.close();\n          }\n        }\n      }, Math.floor(healthyTimeout_ms));\n    }\n  };\n  /**\r\n   * @return {!string}\r\n   * @private\r\n   */\n\n\n  Connection.prototype.nextTransportId_ = function () {\n    return 'c:' + this.id + ':' + this.connectionCount++;\n  };\n\n  Connection.prototype.disconnReceiver_ = function (conn) {\n    var _this = this;\n\n    return function (everConnected) {\n      if (conn === _this.conn_) {\n        _this.onConnectionLost_(everConnected);\n      } else if (conn === _this.secondaryConn_) {\n        _this.log_('Secondary connection lost.');\n\n        _this.onSecondaryConnectionLost_();\n      } else {\n        _this.log_('closing an old connection');\n      }\n    };\n  };\n\n  Connection.prototype.connReceiver_ = function (conn) {\n    var _this = this;\n\n    return function (message) {\n      if (_this.state_ != 2\n      /* DISCONNECTED */\n      ) {\n        if (conn === _this.rx_) {\n          _this.onPrimaryMessageReceived_(message);\n        } else if (conn === _this.secondaryConn_) {\n          _this.onSecondaryMessageReceived_(message);\n        } else {\n          _this.log_('message on old connection');\n        }\n      }\n    };\n  };\n  /**\r\n   *\r\n   * @param {Object} dataMsg An arbitrary data message to be sent to the server\r\n   */\n\n\n  Connection.prototype.sendRequest = function (dataMsg) {\n    // wrap in a data message envelope and send it on\n    var msg = {\n      t: 'd',\n      d: dataMsg\n    };\n    this.sendData_(msg);\n  };\n\n  Connection.prototype.tryCleanupConnection = function () {\n    if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n      this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);\n      this.conn_ = this.secondaryConn_;\n      this.secondaryConn_ = null; // the server will shutdown the old connection\n    }\n  };\n\n  Connection.prototype.onSecondaryControl_ = function (controlData) {\n    if (MESSAGE_TYPE in controlData) {\n      var cmd = controlData[MESSAGE_TYPE];\n\n      if (cmd === SWITCH_ACK) {\n        this.upgradeIfSecondaryHealthy_();\n      } else if (cmd === CONTROL_RESET) {\n        // Most likely the session wasn't valid. Abandon the switch attempt\n        this.log_('Got a reset on secondary, closing it');\n        this.secondaryConn_.close(); // If we were already using this connection for something, than we need to fully close\n\n        if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {\n          this.close();\n        }\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on secondary.');\n        this.secondaryResponsesRequired_--;\n        this.upgradeIfSecondaryHealthy_();\n      }\n    }\n  };\n\n  Connection.prototype.onSecondaryMessageReceived_ = function (parsedData) {\n    var layer = util_1.requireKey('t', parsedData);\n    var data = util_1.requireKey('d', parsedData);\n\n    if (layer == 'c') {\n      this.onSecondaryControl_(data);\n    } else if (layer == 'd') {\n      // got a data message, but we're still second connection. Need to buffer it up\n      this.pendingDataMessages.push(data);\n    } else {\n      throw new Error('Unknown protocol layer: ' + layer);\n    }\n  };\n\n  Connection.prototype.upgradeIfSecondaryHealthy_ = function () {\n    if (this.secondaryResponsesRequired_ <= 0) {\n      this.log_('Secondary connection is healthy.');\n      this.isHealthy_ = true;\n      this.secondaryConn_.markConnectionHealthy();\n      this.proceedWithUpgrade_();\n    } else {\n      // Send a ping to make sure the connection is healthy.\n      this.log_('sending ping on secondary.');\n      this.secondaryConn_.send({\n        t: 'c',\n        d: {\n          t: PING,\n          d: {}\n        }\n      });\n    }\n  };\n\n  Connection.prototype.proceedWithUpgrade_ = function () {\n    // tell this connection to consider itself open\n    this.secondaryConn_.start(); // send ack\n\n    this.log_('sending client ack on secondary');\n    this.secondaryConn_.send({\n      t: 'c',\n      d: {\n        t: SWITCH_ACK,\n        d: {}\n      }\n    }); // send end packet on primary transport, switch to sending on this one\n    // can receive on this one, buffer responses until end received on primary transport\n\n    this.log_('Ending transmission on primary');\n    this.conn_.send({\n      t: 'c',\n      d: {\n        t: END_TRANSMISSION,\n        d: {}\n      }\n    });\n    this.tx_ = this.secondaryConn_;\n    this.tryCleanupConnection();\n  };\n\n  Connection.prototype.onPrimaryMessageReceived_ = function (parsedData) {\n    // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n    var layer = util_1.requireKey('t', parsedData);\n    var data = util_1.requireKey('d', parsedData);\n\n    if (layer == 'c') {\n      this.onControl_(data);\n    } else if (layer == 'd') {\n      this.onDataMessage_(data);\n    }\n  };\n\n  Connection.prototype.onDataMessage_ = function (message) {\n    this.onPrimaryResponse_(); // We don't do anything with data messages, just kick them up a level\n\n    this.onMessage_(message);\n  };\n\n  Connection.prototype.onPrimaryResponse_ = function () {\n    if (!this.isHealthy_) {\n      this.primaryResponsesRequired_--;\n\n      if (this.primaryResponsesRequired_ <= 0) {\n        this.log_('Primary connection is healthy.');\n        this.isHealthy_ = true;\n        this.conn_.markConnectionHealthy();\n      }\n    }\n  };\n\n  Connection.prototype.onControl_ = function (controlData) {\n    var cmd = util_1.requireKey(MESSAGE_TYPE, controlData);\n\n    if (MESSAGE_DATA in controlData) {\n      var payload = controlData[MESSAGE_DATA];\n\n      if (cmd === SERVER_HELLO) {\n        this.onHandshake_(payload);\n      } else if (cmd === END_TRANSMISSION) {\n        this.log_('recvd end transmission on primary');\n        this.rx_ = this.secondaryConn_;\n\n        for (var i = 0; i < this.pendingDataMessages.length; ++i) {\n          this.onDataMessage_(this.pendingDataMessages[i]);\n        }\n\n        this.pendingDataMessages = [];\n        this.tryCleanupConnection();\n      } else if (cmd === CONTROL_SHUTDOWN) {\n        // This was previously the 'onKill' callback passed to the lower-level connection\n        // payload in this case is the reason for the shutdown. Generally a human-readable error\n        this.onConnectionShutdown_(payload);\n      } else if (cmd === CONTROL_RESET) {\n        // payload in this case is the host we should contact\n        this.onReset_(payload);\n      } else if (cmd === CONTROL_ERROR) {\n        util_1.error('Server Error: ' + payload);\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on primary.');\n        this.onPrimaryResponse_();\n        this.sendPingOnPrimaryIfNecessary_();\n      } else {\n        util_1.error('Unknown control packet command: ' + cmd);\n      }\n    }\n  };\n  /**\r\n   *\r\n   * @param {Object} handshake The handshake data returned from the server\r\n   * @private\r\n   */\n\n\n  Connection.prototype.onHandshake_ = function (handshake) {\n    var timestamp = handshake.ts;\n    var version = handshake.v;\n    var host = handshake.h;\n    this.sessionId = handshake.s;\n    this.repoInfo_.updateHost(host); // if we've already closed the connection, then don't bother trying to progress further\n\n    if (this.state_ == 0\n    /* CONNECTING */\n    ) {\n      this.conn_.start();\n      this.onConnectionEstablished_(this.conn_, timestamp);\n\n      if (Constants_1.PROTOCOL_VERSION !== version) {\n        util_1.warn('Protocol version mismatch detected');\n      } // TODO: do we want to upgrade? when? maybe a delay?\n\n\n      this.tryStartUpgrade_();\n    }\n  };\n\n  Connection.prototype.tryStartUpgrade_ = function () {\n    var conn = this.transportManager_.upgradeTransport();\n\n    if (conn) {\n      this.startUpgrade_(conn);\n    }\n  };\n\n  Connection.prototype.startUpgrade_ = function (conn) {\n    var _this = this;\n\n    this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.sessionId); // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n\n    this.secondaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\n    var onMessage = this.connReceiver_(this.secondaryConn_);\n    var onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n    this.secondaryConn_.open(onMessage, onDisconnect); // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n\n    util_1.setTimeoutNonBlocking(function () {\n      if (_this.secondaryConn_) {\n        _this.log_('Timed out trying to upgrade.');\n\n        _this.secondaryConn_.close();\n      }\n    }, Math.floor(UPGRADE_TIMEOUT));\n  };\n\n  Connection.prototype.onReset_ = function (host) {\n    this.log_('Reset packet received.  New host: ' + host);\n    this.repoInfo_.updateHost(host); // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n    // We don't currently support resets after the connection has already been established\n\n    if (this.state_ === 1\n    /* CONNECTED */\n    ) {\n      this.close();\n    } else {\n      // Close whatever connections we have open and start again.\n      this.closeConnections_();\n      this.start_();\n    }\n  };\n\n  Connection.prototype.onConnectionEstablished_ = function (conn, timestamp) {\n    var _this = this;\n\n    this.log_('Realtime connection established.');\n    this.conn_ = conn;\n    this.state_ = 1\n    /* CONNECTED */\n    ;\n\n    if (this.onReady_) {\n      this.onReady_(timestamp, this.sessionId);\n      this.onReady_ = null;\n    } // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n    // send some pings.\n\n\n    if (this.primaryResponsesRequired_ === 0) {\n      this.log_('Primary connection is healthy.');\n      this.isHealthy_ = true;\n    } else {\n      util_1.setTimeoutNonBlocking(function () {\n        _this.sendPingOnPrimaryIfNecessary_();\n      }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n    }\n  };\n\n  Connection.prototype.sendPingOnPrimaryIfNecessary_ = function () {\n    // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n    if (!this.isHealthy_ && this.state_ === 1\n    /* CONNECTED */\n    ) {\n      this.log_('sending ping on primary.');\n      this.sendData_({\n        t: 'c',\n        d: {\n          t: PING,\n          d: {}\n        }\n      });\n    }\n  };\n\n  Connection.prototype.onSecondaryConnectionLost_ = function () {\n    var conn = this.secondaryConn_;\n    this.secondaryConn_ = null;\n\n    if (this.tx_ === conn || this.rx_ === conn) {\n      // we are relying on this connection already in some capacity. Therefore, a failure is real\n      this.close();\n    }\n  };\n  /**\r\n   *\r\n   * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if\r\n   * we should flush the host cache\r\n   * @private\r\n   */\n\n\n  Connection.prototype.onConnectionLost_ = function (everConnected) {\n    this.conn_ = null; // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n    // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n\n    if (!everConnected && this.state_ === 0\n    /* CONNECTING */\n    ) {\n      this.log_('Realtime connection failed.'); // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n\n      if (this.repoInfo_.isCacheableHost()) {\n        storage_1.PersistentStorage.remove('host:' + this.repoInfo_.host); // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n\n        this.repoInfo_.internalHost = this.repoInfo_.host;\n      }\n    } else if (this.state_ === 1\n    /* CONNECTED */\n    ) {\n      this.log_('Realtime connection lost.');\n    }\n\n    this.close();\n  };\n  /**\r\n   *\r\n   * @param {string} reason\r\n   * @private\r\n   */\n\n\n  Connection.prototype.onConnectionShutdown_ = function (reason) {\n    this.log_('Connection shutdown command received. Shutting down...');\n\n    if (this.onKill_) {\n      this.onKill_(reason);\n      this.onKill_ = null;\n    } // We intentionally don't want to fire onDisconnect (kill is a different case),\n    // so clear the callback.\n\n\n    this.onDisconnect_ = null;\n    this.close();\n  };\n\n  Connection.prototype.sendData_ = function (data) {\n    if (this.state_ !== 1\n    /* CONNECTED */\n    ) {\n      throw 'Connection is not connected';\n    } else {\n      this.tx_.send(data);\n    }\n  };\n  /**\r\n   * Cleans up this connection, calling the appropriate callbacks\r\n   */\n\n\n  Connection.prototype.close = function () {\n    if (this.state_ !== 2\n    /* DISCONNECTED */\n    ) {\n      this.log_('Closing realtime connection.');\n      this.state_ = 2\n      /* DISCONNECTED */\n      ;\n      this.closeConnections_();\n\n      if (this.onDisconnect_) {\n        this.onDisconnect_();\n        this.onDisconnect_ = null;\n      }\n    }\n  };\n  /**\r\n   *\r\n   * @private\r\n   */\n\n\n  Connection.prototype.closeConnections_ = function () {\n    this.log_('Shutting down all connections');\n\n    if (this.conn_) {\n      this.conn_.close();\n      this.conn_ = null;\n    }\n\n    if (this.secondaryConn_) {\n      this.secondaryConn_.close();\n      this.secondaryConn_ = null;\n    }\n\n    if (this.healthyTimeout_) {\n      clearTimeout(this.healthyTimeout_);\n      this.healthyTimeout_ = null;\n    }\n  };\n\n  return Connection;\n}();\n\nexports.Connection = Connection;","map":{"version":3,"mappings":"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","names":["UPGRADE_TIMEOUT","DELAY_BEFORE_SENDING_EXTRA_REQUESTS","BYTES_SENT_HEALTHY_OVERRIDE","BYTES_RECEIVED_HEALTHY_OVERRIDE","MESSAGE_TYPE","MESSAGE_DATA","CONTROL_SHUTDOWN","CONTROL_RESET","CONTROL_ERROR","CONTROL_PONG","SWITCH_ACK","END_TRANSMISSION","PING","SERVER_HELLO","id","repoInfo_","onMessage_","onReady_","onDisconnect_","onKill_","lastSessionId","log_","util_1","transportManager_","TransportManager_1","start_","Connection","conn","initialTransport","conn_","nextTransportId_","undefined","primaryResponsesRequired_","onMessageReceived","connReceiver_","onConnectionLost","disconnReceiver_","tx_","rx_","secondaryConn_","isHealthy_","setTimeout","_this","open","Math","floor","healthyTimeout_ms","healthyTimeout_","bytesReceived","markConnectionHealthy","bytesSent","close","connectionCount","onConnectionLost_","everConnected","onSecondaryConnectionLost_","message","state_","onPrimaryMessageReceived_","onSecondaryMessageReceived_","dataMsg","msg","t","d","sendData_","connId","controlData","cmd","upgradeIfSecondaryHealthy_","secondaryResponsesRequired_","parsedData","layer","data","onSecondaryControl_","pendingDataMessages","push","Error","proceedWithUpgrade_","send","start","tryCleanupConnection","onControl_","onDataMessage_","onPrimaryResponse_","payload","onHandshake_","i","length","onConnectionShutdown_","onReset_","sendPingOnPrimaryIfNecessary_","handshake","timestamp","ts","version","v","host","h","sessionId","s","updateHost","onConnectionEstablished_","Constants_1","tryStartUpgrade_","upgradeTransport","startUpgrade_","onMessage","onDisconnect","closeConnections_","isCacheableHost","storage_1","remove","internalHost","reason","clearTimeout","exports"],"sources":["../src/realtime/Connection.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  error,\n  logWrapper,\n  requireKey,\n  setTimeoutNonBlocking,\n  warn\n} from '../core/util/util';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { PROTOCOL_VERSION } from './Constants';\nimport { TransportManager } from './TransportManager';\nimport { RepoInfo } from '../core/RepoInfo';\nimport { Transport, TransportConstructor } from './Transport';\n\n// Abort upgrade attempt if it takes longer than 60s.\nconst UPGRADE_TIMEOUT = 60000;\n\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nconst DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\n\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nconst BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nconst BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\n\nconst enum RealtimeState {\n  CONNECTING,\n  CONNECTED,\n  DISCONNECTED\n}\n\nconst MESSAGE_TYPE = 't';\nconst MESSAGE_DATA = 'd';\nconst CONTROL_SHUTDOWN = 's';\nconst CONTROL_RESET = 'r';\nconst CONTROL_ERROR = 'e';\nconst CONTROL_PONG = 'o';\nconst SWITCH_ACK = 'a';\nconst END_TRANSMISSION = 'n';\nconst PING = 'p';\n\nconst SERVER_HELLO = 'h';\n\n/**\n * Creates a new real-time connection to the server using whichever method works\n * best in the current browser.\n *\n * @constructor\n */\nexport class Connection {\n  connectionCount = 0;\n  pendingDataMessages: any[] = [];\n  sessionId: string;\n\n  private conn_: Transport;\n  private healthyTimeout_: number;\n  private isHealthy_: boolean;\n  private log_: (...args: any[]) => void;\n  private primaryResponsesRequired_: number;\n  private rx_: Transport;\n  private secondaryConn_: Transport;\n  private secondaryResponsesRequired_: number;\n  private state_ = RealtimeState.CONNECTING;\n  private transportManager_: TransportManager;\n  private tx_: Transport;\n\n  /**\n   * @param {!string} id - an id for this connection\n   * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to\n   * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives\n   * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.\n   * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost\n   * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.\n   * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\n   */\n  constructor(\n    public id: string,\n    private repoInfo_: RepoInfo,\n    private onMessage_: (a: Object) => void,\n    private onReady_: (a: number, b: string) => void,\n    private onDisconnect_: () => void,\n    private onKill_: (a: string) => void,\n    public lastSessionId?: string\n  ) {\n    this.log_ = logWrapper('c:' + this.id + ':');\n    this.transportManager_ = new TransportManager(repoInfo_);\n    this.log_('Connection created');\n    this.start_();\n  }\n\n  /**\n   * Starts a connection attempt\n   * @private\n   */\n  private start_() {\n    const conn = this.transportManager_.initialTransport();\n    this.conn_ = new conn(\n      this.nextTransportId_(),\n      this.repoInfo_,\n      undefined,\n      this.lastSessionId\n    );\n\n    // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n    this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\n\n    const onMessageReceived = this.connReceiver_(this.conn_);\n    const onConnectionLost = this.disconnReceiver_(this.conn_);\n    this.tx_ = this.conn_;\n    this.rx_ = this.conn_;\n    this.secondaryConn_ = null;\n    this.isHealthy_ = false;\n\n    /*\n     * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\n     * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\n     * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\n     * still have the context of your originating frame.\n     */\n    setTimeout(() => {\n      // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n      this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);\n    }, Math.floor(0));\n\n    const healthyTimeout_ms = conn['healthyTimeout'] || 0;\n    if (healthyTimeout_ms > 0) {\n      this.healthyTimeout_ = setTimeoutNonBlocking(() => {\n        this.healthyTimeout_ = null;\n        if (!this.isHealthy_) {\n          if (\n            this.conn_ &&\n            this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE\n          ) {\n            this.log_(\n              'Connection exceeded healthy timeout but has received ' +\n                this.conn_.bytesReceived +\n                ' bytes.  Marking connection healthy.'\n            );\n            this.isHealthy_ = true;\n            this.conn_.markConnectionHealthy();\n          } else if (\n            this.conn_ &&\n            this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE\n          ) {\n            this.log_(\n              'Connection exceeded healthy timeout but has sent ' +\n                this.conn_.bytesSent +\n                ' bytes.  Leaving connection alive.'\n            );\n            // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n            // the server.\n          } else {\n            this.log_('Closing unhealthy connection after timeout.');\n            this.close();\n          }\n        }\n      }, Math.floor(healthyTimeout_ms)) as any;\n    }\n  }\n\n  /**\n   * @return {!string}\n   * @private\n   */\n  private nextTransportId_(): string {\n    return 'c:' + this.id + ':' + this.connectionCount++;\n  }\n\n  private disconnReceiver_(conn) {\n    return everConnected => {\n      if (conn === this.conn_) {\n        this.onConnectionLost_(everConnected);\n      } else if (conn === this.secondaryConn_) {\n        this.log_('Secondary connection lost.');\n        this.onSecondaryConnectionLost_();\n      } else {\n        this.log_('closing an old connection');\n      }\n    };\n  }\n\n  private connReceiver_(conn: Transport) {\n    return (message: object) => {\n      if (this.state_ != RealtimeState.DISCONNECTED) {\n        if (conn === this.rx_) {\n          this.onPrimaryMessageReceived_(message);\n        } else if (conn === this.secondaryConn_) {\n          this.onSecondaryMessageReceived_(message);\n        } else {\n          this.log_('message on old connection');\n        }\n      }\n    };\n  }\n\n  /**\n   *\n   * @param {Object} dataMsg An arbitrary data message to be sent to the server\n   */\n  sendRequest(dataMsg: object) {\n    // wrap in a data message envelope and send it on\n    const msg = { t: 'd', d: dataMsg };\n    this.sendData_(msg);\n  }\n\n  tryCleanupConnection() {\n    if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n      this.log_(\n        'cleaning up and promoting a connection: ' + this.secondaryConn_.connId\n      );\n      this.conn_ = this.secondaryConn_;\n      this.secondaryConn_ = null;\n      // the server will shutdown the old connection\n    }\n  }\n\n  private onSecondaryControl_(controlData: { [k: string]: any }) {\n    if (MESSAGE_TYPE in controlData) {\n      const cmd = controlData[MESSAGE_TYPE] as string;\n      if (cmd === SWITCH_ACK) {\n        this.upgradeIfSecondaryHealthy_();\n      } else if (cmd === CONTROL_RESET) {\n        // Most likely the session wasn't valid. Abandon the switch attempt\n        this.log_('Got a reset on secondary, closing it');\n        this.secondaryConn_.close();\n        // If we were already using this connection for something, than we need to fully close\n        if (\n          this.tx_ === this.secondaryConn_ ||\n          this.rx_ === this.secondaryConn_\n        ) {\n          this.close();\n        }\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on secondary.');\n        this.secondaryResponsesRequired_--;\n        this.upgradeIfSecondaryHealthy_();\n      }\n    }\n  }\n\n  private onSecondaryMessageReceived_(parsedData: object) {\n    const layer: string = requireKey('t', parsedData);\n    const data: any = requireKey('d', parsedData);\n    if (layer == 'c') {\n      this.onSecondaryControl_(data);\n    } else if (layer == 'd') {\n      // got a data message, but we're still second connection. Need to buffer it up\n      this.pendingDataMessages.push(data);\n    } else {\n      throw new Error('Unknown protocol layer: ' + layer);\n    }\n  }\n\n  private upgradeIfSecondaryHealthy_() {\n    if (this.secondaryResponsesRequired_ <= 0) {\n      this.log_('Secondary connection is healthy.');\n      this.isHealthy_ = true;\n      this.secondaryConn_.markConnectionHealthy();\n      this.proceedWithUpgrade_();\n    } else {\n      // Send a ping to make sure the connection is healthy.\n      this.log_('sending ping on secondary.');\n      this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });\n    }\n  }\n\n  private proceedWithUpgrade_() {\n    // tell this connection to consider itself open\n    this.secondaryConn_.start();\n    // send ack\n    this.log_('sending client ack on secondary');\n    this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });\n\n    // send end packet on primary transport, switch to sending on this one\n    // can receive on this one, buffer responses until end received on primary transport\n    this.log_('Ending transmission on primary');\n    this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });\n    this.tx_ = this.secondaryConn_;\n\n    this.tryCleanupConnection();\n  }\n\n  private onPrimaryMessageReceived_(parsedData: { [k: string]: any }) {\n    // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n    const layer: string = requireKey('t', parsedData);\n    const data: any = requireKey('d', parsedData);\n    if (layer == 'c') {\n      this.onControl_(data);\n    } else if (layer == 'd') {\n      this.onDataMessage_(data);\n    }\n  }\n\n  private onDataMessage_(message: any) {\n    this.onPrimaryResponse_();\n\n    // We don't do anything with data messages, just kick them up a level\n    this.onMessage_(message);\n  }\n\n  private onPrimaryResponse_() {\n    if (!this.isHealthy_) {\n      this.primaryResponsesRequired_--;\n      if (this.primaryResponsesRequired_ <= 0) {\n        this.log_('Primary connection is healthy.');\n        this.isHealthy_ = true;\n        this.conn_.markConnectionHealthy();\n      }\n    }\n  }\n\n  private onControl_(controlData: { [k: string]: any }) {\n    const cmd: string = requireKey(MESSAGE_TYPE, controlData);\n    if (MESSAGE_DATA in controlData) {\n      const payload = controlData[MESSAGE_DATA];\n      if (cmd === SERVER_HELLO) {\n        this.onHandshake_(payload);\n      } else if (cmd === END_TRANSMISSION) {\n        this.log_('recvd end transmission on primary');\n        this.rx_ = this.secondaryConn_;\n        for (let i = 0; i < this.pendingDataMessages.length; ++i) {\n          this.onDataMessage_(this.pendingDataMessages[i]);\n        }\n        this.pendingDataMessages = [];\n        this.tryCleanupConnection();\n      } else if (cmd === CONTROL_SHUTDOWN) {\n        // This was previously the 'onKill' callback passed to the lower-level connection\n        // payload in this case is the reason for the shutdown. Generally a human-readable error\n        this.onConnectionShutdown_(payload);\n      } else if (cmd === CONTROL_RESET) {\n        // payload in this case is the host we should contact\n        this.onReset_(payload);\n      } else if (cmd === CONTROL_ERROR) {\n        error('Server Error: ' + payload);\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on primary.');\n        this.onPrimaryResponse_();\n        this.sendPingOnPrimaryIfNecessary_();\n      } else {\n        error('Unknown control packet command: ' + cmd);\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {Object} handshake The handshake data returned from the server\n   * @private\n   */\n  private onHandshake_(handshake: {\n    ts: number;\n    v: string;\n    h: string;\n    s: string;\n  }) {\n    const timestamp = handshake.ts;\n    const version = handshake.v;\n    const host = handshake.h;\n    this.sessionId = handshake.s;\n    this.repoInfo_.updateHost(host);\n    // if we've already closed the connection, then don't bother trying to progress further\n    if (this.state_ == RealtimeState.CONNECTING) {\n      this.conn_.start();\n      this.onConnectionEstablished_(this.conn_, timestamp);\n      if (PROTOCOL_VERSION !== version) {\n        warn('Protocol version mismatch detected');\n      }\n      // TODO: do we want to upgrade? when? maybe a delay?\n      this.tryStartUpgrade_();\n    }\n  }\n\n  private tryStartUpgrade_() {\n    const conn = this.transportManager_.upgradeTransport();\n    if (conn) {\n      this.startUpgrade_(conn);\n    }\n  }\n\n  private startUpgrade_(conn: TransportConstructor) {\n    this.secondaryConn_ = new conn(\n      this.nextTransportId_(),\n      this.repoInfo_,\n      this.sessionId\n    );\n    // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n    this.secondaryResponsesRequired_ =\n      conn['responsesRequiredToBeHealthy'] || 0;\n\n    const onMessage = this.connReceiver_(this.secondaryConn_);\n    const onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n    this.secondaryConn_.open(onMessage, onDisconnect);\n\n    // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n    setTimeoutNonBlocking(() => {\n      if (this.secondaryConn_) {\n        this.log_('Timed out trying to upgrade.');\n        this.secondaryConn_.close();\n      }\n    }, Math.floor(UPGRADE_TIMEOUT));\n  }\n\n  private onReset_(host: string) {\n    this.log_('Reset packet received.  New host: ' + host);\n    this.repoInfo_.updateHost(host);\n    // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n    // We don't currently support resets after the connection has already been established\n    if (this.state_ === RealtimeState.CONNECTED) {\n      this.close();\n    } else {\n      // Close whatever connections we have open and start again.\n      this.closeConnections_();\n      this.start_();\n    }\n  }\n\n  private onConnectionEstablished_(conn: Transport, timestamp: number) {\n    this.log_('Realtime connection established.');\n    this.conn_ = conn;\n    this.state_ = RealtimeState.CONNECTED;\n\n    if (this.onReady_) {\n      this.onReady_(timestamp, this.sessionId);\n      this.onReady_ = null;\n    }\n\n    // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n    // send some pings.\n    if (this.primaryResponsesRequired_ === 0) {\n      this.log_('Primary connection is healthy.');\n      this.isHealthy_ = true;\n    } else {\n      setTimeoutNonBlocking(() => {\n        this.sendPingOnPrimaryIfNecessary_();\n      }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n    }\n  }\n\n  private sendPingOnPrimaryIfNecessary_() {\n    // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n    if (!this.isHealthy_ && this.state_ === RealtimeState.CONNECTED) {\n      this.log_('sending ping on primary.');\n      this.sendData_({ t: 'c', d: { t: PING, d: {} } });\n    }\n  }\n\n  private onSecondaryConnectionLost_() {\n    const conn = this.secondaryConn_;\n    this.secondaryConn_ = null;\n    if (this.tx_ === conn || this.rx_ === conn) {\n      // we are relying on this connection already in some capacity. Therefore, a failure is real\n      this.close();\n    }\n  }\n\n  /**\n   *\n   * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if\n   * we should flush the host cache\n   * @private\n   */\n  private onConnectionLost_(everConnected: boolean) {\n    this.conn_ = null;\n\n    // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n    // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n    if (!everConnected && this.state_ === RealtimeState.CONNECTING) {\n      this.log_('Realtime connection failed.');\n      // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n      if (this.repoInfo_.isCacheableHost()) {\n        PersistentStorage.remove('host:' + this.repoInfo_.host);\n        // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n        this.repoInfo_.internalHost = this.repoInfo_.host;\n      }\n    } else if (this.state_ === RealtimeState.CONNECTED) {\n      this.log_('Realtime connection lost.');\n    }\n\n    this.close();\n  }\n\n  /**\n   *\n   * @param {string} reason\n   * @private\n   */\n  private onConnectionShutdown_(reason: string) {\n    this.log_('Connection shutdown command received. Shutting down...');\n\n    if (this.onKill_) {\n      this.onKill_(reason);\n      this.onKill_ = null;\n    }\n\n    // We intentionally don't want to fire onDisconnect (kill is a different case),\n    // so clear the callback.\n    this.onDisconnect_ = null;\n\n    this.close();\n  }\n\n  private sendData_(data: object) {\n    if (this.state_ !== RealtimeState.CONNECTED) {\n      throw 'Connection is not connected';\n    } else {\n      this.tx_.send(data);\n    }\n  }\n\n  /**\n   * Cleans up this connection, calling the appropriate callbacks\n   */\n  close() {\n    if (this.state_ !== RealtimeState.DISCONNECTED) {\n      this.log_('Closing realtime connection.');\n      this.state_ = RealtimeState.DISCONNECTED;\n\n      this.closeConnections_();\n\n      if (this.onDisconnect_) {\n        this.onDisconnect_();\n        this.onDisconnect_ = null;\n      }\n    }\n  }\n\n  /**\n   *\n   * @private\n   */\n  private closeConnections_() {\n    this.log_('Shutting down all connections');\n    if (this.conn_) {\n      this.conn_.close();\n      this.conn_ = null;\n    }\n\n    if (this.secondaryConn_) {\n      this.secondaryConn_.close();\n      this.secondaryConn_ = null;\n    }\n\n    if (this.healthyTimeout_) {\n      clearTimeout(this.healthyTimeout_);\n      this.healthyTimeout_ = null;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}