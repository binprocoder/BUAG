{"ast":null,"code":"'use strict';\n\nmodule.exports = MonkeyLearnResponse;\n\nconst isArray = require('lodash/isArray');\n\nconst isPlainObject = require('lodash/isPlainObject');\n\nfunction MonkeyLearnResponse(raw_responses) {\n  this.body = null;\n  this.request_queries_used = 0;\n  this.plan_queries_allowed = null;\n  this.plan_queries_remaining = null;\n  this.raw_responses = [];\n\n  if (isPlainObject(raw_responses)) {\n    this._add_raw_response(raw_responses);\n  } else if (isArray(raw_responses)) {\n    raw_responses.map(raw_response => this._add_raw_response(raw_response));\n  }\n} // raw_response is an object with body, status, headers as returned by request\n// it will break if you add more than one raw response that has an error\n\n\nMonkeyLearnResponse.prototype._add_raw_response = function (raw_response) {\n  if (this.raw_responses.length === 0) {\n    this.body = raw_response.body;\n  } else if (raw_response.status === 200) {\n    // this response is aggregating more than one request, so assume that the raw_response body is a list\n    this.body = this.body.concat(raw_response.body);\n  } else {\n    // if there was an exception, replace the current concatenated body with the error body\n    // all the other responses are still available in this.raw_responses\n    this.body = raw_response.body;\n  } // TODO: consider what to do if the status isn't valid\n\n\n  this.raw_responses.push(raw_response);\n\n  if (raw_response.status === 200) {\n    // the headers come as all lowercase apparently\n    this.plan_queries_allowed = parseInt(raw_response.headers['x-query-limit-limit']);\n    this.plan_queries_remaining = parseInt(raw_response.headers['x-query-limit-remaining']);\n    this.request_queries_used += parseInt(raw_response.headers['x-query-limit-request-queries']);\n  }\n};","map":{"version":3,"sources":["D:/Download/BUAG-tienPush/frontend/node_modules/monkeylearn/lib/response.js"],"names":["module","exports","MonkeyLearnResponse","isArray","require","isPlainObject","raw_responses","body","request_queries_used","plan_queries_allowed","plan_queries_remaining","_add_raw_response","map","raw_response","prototype","length","status","concat","push","parseInt","headers"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,mBAAjB;;AAEA,MAAMC,OAAO,GAAGC,OAAO,CAAC,gBAAD,CAAvB;;AACA,MAAMC,aAAa,GAAGD,OAAO,CAAC,sBAAD,CAA7B;;AAEA,SAASF,mBAAT,CAA6BI,aAA7B,EAA4C;AAC1C,OAAKC,IAAL,GAAY,IAAZ;AACA,OAAKC,oBAAL,GAA4B,CAA5B;AACA,OAAKC,oBAAL,GAA4B,IAA5B;AACA,OAAKC,sBAAL,GAA8B,IAA9B;AAEA,OAAKJ,aAAL,GAAqB,EAArB;;AACA,MAAID,aAAa,CAACC,aAAD,CAAjB,EAAkC;AAChC,SAAKK,iBAAL,CAAuBL,aAAvB;AACD,GAFD,MAEO,IAAIH,OAAO,CAACG,aAAD,CAAX,EAA2B;AAChCA,IAAAA,aAAa,CAACM,GAAd,CAAkBC,YAAY,IAAI,KAAKF,iBAAL,CAAuBE,YAAvB,CAAlC;AACD;AACF,C,CAED;AACA;;;AACAX,mBAAmB,CAACY,SAApB,CAA8BH,iBAA9B,GAAkD,UAASE,YAAT,EAAuB;AACvE,MAAI,KAAKP,aAAL,CAAmBS,MAAnB,KAA8B,CAAlC,EAAqC;AACnC,SAAKR,IAAL,GAAYM,YAAY,CAACN,IAAzB;AACD,GAFD,MAEO,IAAIM,YAAY,CAACG,MAAb,KAAwB,GAA5B,EAAgC;AACrC;AACA,SAAKT,IAAL,GAAY,KAAKA,IAAL,CAAUU,MAAV,CAAiBJ,YAAY,CAACN,IAA9B,CAAZ;AACD,GAHM,MAGA;AACL;AACA;AACA,SAAKA,IAAL,GAAYM,YAAY,CAACN,IAAzB;AACD,GAVsE,CAWvE;;;AACA,OAAKD,aAAL,CAAmBY,IAAnB,CAAwBL,YAAxB;;AAEA,MAAIA,YAAY,CAACG,MAAb,KAAwB,GAA5B,EAAiC;AAC/B;AACA,SAAKP,oBAAL,GAA4BU,QAAQ,CAACN,YAAY,CAACO,OAAb,CAAqB,qBAArB,CAAD,CAApC;AACA,SAAKV,sBAAL,GAA8BS,QAAQ,CAACN,YAAY,CAACO,OAAb,CAAqB,yBAArB,CAAD,CAAtC;AACA,SAAKZ,oBAAL,IAA6BW,QAAQ,CAACN,YAAY,CAACO,OAAb,CAAqB,+BAArB,CAAD,CAArC;AACD;AACF,CApBD","sourcesContent":["'use strict';\n\nmodule.exports = MonkeyLearnResponse;\n\nconst isArray = require('lodash/isArray');\nconst isPlainObject = require('lodash/isPlainObject');\n\nfunction MonkeyLearnResponse(raw_responses) {\n  this.body = null;\n  this.request_queries_used = 0;\n  this.plan_queries_allowed = null;\n  this.plan_queries_remaining = null;\n\n  this.raw_responses = [];\n  if (isPlainObject(raw_responses)) {\n    this._add_raw_response(raw_responses)\n  } else if (isArray(raw_responses)){\n    raw_responses.map(raw_response => this._add_raw_response(raw_response))\n  }\n}\n\n// raw_response is an object with body, status, headers as returned by request\n// it will break if you add more than one raw response that has an error\nMonkeyLearnResponse.prototype._add_raw_response = function(raw_response) {\n  if (this.raw_responses.length === 0) {\n    this.body = raw_response.body;\n  } else if (raw_response.status === 200){\n    // this response is aggregating more than one request, so assume that the raw_response body is a list\n    this.body = this.body.concat(raw_response.body)\n  } else {\n    // if there was an exception, replace the current concatenated body with the error body\n    // all the other responses are still available in this.raw_responses\n    this.body = raw_response.body;\n  }\n  // TODO: consider what to do if the status isn't valid\n  this.raw_responses.push(raw_response);\n\n  if (raw_response.status === 200) {\n    // the headers come as all lowercase apparently\n    this.plan_queries_allowed = parseInt(raw_response.headers['x-query-limit-limit']);\n    this.plan_queries_remaining = parseInt(raw_response.headers['x-query-limit-remaining']);\n    this.request_queries_used += parseInt(raw_response.headers['x-query-limit-request-queries']);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}