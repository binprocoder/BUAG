{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BrowserPollConnection_1 = require(\"./BrowserPollConnection\");\n\nvar WebSocketConnection_1 = require(\"./WebSocketConnection\");\n\nvar util_1 = require(\"../core/util/util\");\n/**\r\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\r\n * lifecycle.\r\n *\r\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\r\n * they are available.\r\n * @constructor\r\n */\n\n\nvar TransportManager =\n/** @class */\nfunction () {\n  /**\r\n   * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to\r\n   */\n  function TransportManager(repoInfo) {\n    this.initTransports_(repoInfo);\n  }\n\n  Object.defineProperty(TransportManager, \"ALL_TRANSPORTS\", {\n    /**\r\n     * @const\r\n     * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}\r\n     */\n    get: function () {\n      return [BrowserPollConnection_1.BrowserPollConnection, WebSocketConnection_1.WebSocketConnection];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @param {!RepoInfo} repoInfo\r\n   * @private\r\n   */\n\n  TransportManager.prototype.initTransports_ = function (repoInfo) {\n    var isWebSocketsAvailable = WebSocketConnection_1.WebSocketConnection && WebSocketConnection_1.WebSocketConnection['isAvailable']();\n    var isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection_1.WebSocketConnection.previouslyFailed();\n\n    if (repoInfo.webSocketOnly) {\n      if (!isWebSocketsAvailable) util_1.warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");\n      isSkipPollConnection = true;\n    }\n\n    if (isSkipPollConnection) {\n      this.transports_ = [WebSocketConnection_1.WebSocketConnection];\n    } else {\n      var transports_1 = this.transports_ = [];\n      util_1.each(TransportManager.ALL_TRANSPORTS, function (i, transport) {\n        if (transport && transport['isAvailable']()) {\n          transports_1.push(transport);\n        }\n      });\n    }\n  };\n  /**\r\n   * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the\r\n   * initial transport to use\r\n   */\n\n\n  TransportManager.prototype.initialTransport = function () {\n    if (this.transports_.length > 0) {\n      return this.transports_[0];\n    } else {\n      throw new Error('No transports available');\n    }\n  };\n  /**\r\n   * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next\r\n   * transport, or null\r\n   */\n\n\n  TransportManager.prototype.upgradeTransport = function () {\n    if (this.transports_.length > 1) {\n      return this.transports_[1];\n    } else {\n      return null;\n    }\n  };\n\n  return TransportManager;\n}();\n\nexports.TransportManager = TransportManager;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA;;AACA;;AACA;AAIA;;;;;;;;;;AAQA;AAAA;AAAA;AAWE;;;AAGA,4BAAYA,QAAZ,EAA8B;AAC5B,SAAKC,eAAL,CAAqBD,QAArB;AACD;;AATDE,wBAAWC,gBAAX,EAAW,gBAAX,EAAyB;AAJzB;;;;SAIA;AACE,aAAO,CAACC,6CAAD,EAAwBC,yCAAxB,CAAP;AACD,KAFwB;oBAAA;;AAAA,GAAzB;AAWA;;;;;AAIQF,+CAAR,UAAwBH,QAAxB,EAA0C;AACxC,QAAMM,qBAAqB,GACzBD,6CAAuBA,0CAAoB,aAApB,GADzB;AAEA,QAAIE,oBAAoB,GACtBD,qBAAqB,IAAI,CAACD,0CAAoBG,gBAApB,EAD5B;;AAGA,QAAIR,QAAQ,CAACS,aAAb,EAA4B;AAC1B,UAAI,CAACH,qBAAL,EACEI,YACE,iFADF;AAIFH,0BAAoB,GAAG,IAAvB;AACD;;AAED,QAAIA,oBAAJ,EAA0B;AACxB,WAAKI,WAAL,GAAmB,CAACN,yCAAD,CAAnB;AACD,KAFD,MAEO;AACL,UAAMO,YAAU,GAAI,KAAKD,WAAL,GAAmB,EAAvC;AACAD,kBACEP,gBAAgB,CAACU,cADnB,EAEE,UAACC,CAAD,EAAYC,SAAZ,EAA2C;AACzC,YAAIA,SAAS,IAAIA,SAAS,CAAC,aAAD,CAAT,EAAjB,EAA6C;AAC3CH,sBAAU,CAACI,IAAX,CAAgBD,SAAhB;AACD;AACF,OANH;AAQD;AACF,GA5BO;AA8BR;;;;;;AAIAZ;AACE,QAAI,KAAKQ,WAAL,CAAiBM,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B,aAAO,KAAKN,WAAL,CAAiB,CAAjB,CAAP;AACD,KAFD,MAEO;AACL,YAAM,IAAIO,KAAJ,CAAU,yBAAV,CAAN;AACD;AACF,GAND;AAQA;;;;;;AAIAf;AACE,QAAI,KAAKQ,WAAL,CAAiBM,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B,aAAO,KAAKN,WAAL,CAAiB,CAAjB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,IAAP;AACD;AACF,GAND;;AAOF;AA3EA;;AAAaQ","names":["repoInfo","initTransports_","Object","TransportManager","BrowserPollConnection_1","WebSocketConnection_1","isWebSocketsAvailable","isSkipPollConnection","previouslyFailed","webSocketOnly","util_1","transports_","transports_1","ALL_TRANSPORTS","i","transport","push","length","Error","exports"],"sources":["../src/realtime/TransportManager.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BrowserPollConnection } from './BrowserPollConnection';\nimport { WebSocketConnection } from './WebSocketConnection';\nimport { warn, each } from '../core/util/util';\nimport { TransportConstructor } from './Transport';\nimport { RepoInfo } from '../core/RepoInfo';\n\n/**\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\n * lifecycle.\n *\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\n * they are available.\n * @constructor\n */\nexport class TransportManager {\n  private transports_: TransportConstructor[];\n\n  /**\n   * @const\n   * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}\n   */\n  static get ALL_TRANSPORTS() {\n    return [BrowserPollConnection, WebSocketConnection];\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to\n   */\n  constructor(repoInfo: RepoInfo) {\n    this.initTransports_(repoInfo);\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo\n   * @private\n   */\n  private initTransports_(repoInfo: RepoInfo) {\n    const isWebSocketsAvailable: boolean =\n      WebSocketConnection && WebSocketConnection['isAvailable']();\n    let isSkipPollConnection =\n      isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\n\n    if (repoInfo.webSocketOnly) {\n      if (!isWebSocketsAvailable)\n        warn(\n          \"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\"\n        );\n\n      isSkipPollConnection = true;\n    }\n\n    if (isSkipPollConnection) {\n      this.transports_ = [WebSocketConnection];\n    } else {\n      const transports = (this.transports_ = [] as TransportConstructor[]);\n      each(\n        TransportManager.ALL_TRANSPORTS,\n        (i: number, transport: TransportConstructor) => {\n          if (transport && transport['isAvailable']()) {\n            transports.push(transport);\n          }\n        }\n      );\n    }\n  }\n\n  /**\n   * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the\n   * initial transport to use\n   */\n  initialTransport(): TransportConstructor {\n    if (this.transports_.length > 0) {\n      return this.transports_[0];\n    } else {\n      throw new Error('No transports available');\n    }\n  }\n\n  /**\n   * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next\n   * transport, or null\n   */\n  upgradeTransport(): TransportConstructor | null {\n    if (this.transports_.length > 1) {\n      return this.transports_[1];\n    } else {\n      return null;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}