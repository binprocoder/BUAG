{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar CacheNode_1 = require(\"./view/CacheNode\");\n\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"@firebase/util\");\n\nvar ViewCache_1 = require(\"./view/ViewCache\");\n\nvar View_1 = require(\"./view/View\");\n\nvar __referenceConstructor;\n/**\r\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\r\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\r\n * and user writes (set, transaction, update).\r\n *\r\n * It's responsible for:\r\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\r\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\r\n *    applyUserOverwrite, etc.)\r\n */\n\n\nvar SyncPoint =\n/** @class */\nfunction () {\n  function SyncPoint() {\n    /**\r\n     * The Views being tracked at this location in the tree, stored as a map where the key is a\r\n     * queryId and the value is the View for that query.\r\n     *\r\n     * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\r\n     *\r\n     * @type {!Object.<!string, !View>}\r\n     * @private\r\n     */\n    this.views_ = {};\n  }\n\n  Object.defineProperty(SyncPoint, \"__referenceConstructor\", {\n    get: function () {\n      util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');\n      return __referenceConstructor;\n    },\n    set: function (val) {\n      util_1.assert(!__referenceConstructor, '__referenceConstructor has already been defined');\n      __referenceConstructor = val;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @return {boolean}\r\n   */\n\n  SyncPoint.prototype.isEmpty = function () {\n    return util_2.isEmpty(this.views_);\n  };\n  /**\r\n   *\r\n   * @param {!Operation} operation\r\n   * @param {!WriteTreeRef} writesCache\r\n   * @param {?Node} optCompleteServerCache\r\n   * @return {!Array.<!Event>}\r\n   */\n\n\n  SyncPoint.prototype.applyOperation = function (operation, writesCache, optCompleteServerCache) {\n    var queryId = operation.source.queryId;\n\n    if (queryId !== null) {\n      var view = util_2.safeGet(this.views_, queryId);\n      util_1.assert(view != null, 'SyncTree gave us an op for an invalid query.');\n      return view.applyOperation(operation, writesCache, optCompleteServerCache);\n    } else {\n      var events_1 = [];\n      util_2.forEach(this.views_, function (key, view) {\n        events_1 = events_1.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));\n      });\n      return events_1;\n    }\n  };\n  /**\r\n   * Add an event callback for the specified query.\r\n   *\r\n   * @param {!Query} query\r\n   * @param {!EventRegistration} eventRegistration\r\n   * @param {!WriteTreeRef} writesCache\r\n   * @param {?Node} serverCache Complete server cache, if we have it.\r\n   * @param {boolean} serverCacheComplete\r\n   * @return {!Array.<!Event>} Events to raise.\r\n   */\n\n\n  SyncPoint.prototype.addEventRegistration = function (query, eventRegistration, writesCache, serverCache, serverCacheComplete) {\n    var queryId = query.queryIdentifier();\n    var view = util_2.safeGet(this.views_, queryId);\n\n    if (!view) {\n      // TODO: make writesCache take flag for complete server node\n      var eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);\n      var eventCacheComplete = false;\n\n      if (eventCache) {\n        eventCacheComplete = true;\n      } else if (serverCache instanceof ChildrenNode_1.ChildrenNode) {\n        eventCache = writesCache.calcCompleteEventChildren(serverCache);\n        eventCacheComplete = false;\n      } else {\n        eventCache = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n        eventCacheComplete = false;\n      }\n\n      var viewCache = new ViewCache_1.ViewCache(new CacheNode_1.CacheNode(\n      /** @type {!Node} */\n      eventCache, eventCacheComplete, false), new CacheNode_1.CacheNode(\n      /** @type {!Node} */\n      serverCache, serverCacheComplete, false));\n      view = new View_1.View(query, viewCache);\n      this.views_[queryId] = view;\n    } // This is guaranteed to exist now, we just created anything that was missing\n\n\n    view.addEventRegistration(eventRegistration);\n    return view.getInitialEvents(eventRegistration);\n  };\n  /**\r\n   * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\r\n   *\r\n   * If query is the default query, we'll check all views for the specified eventRegistration.\r\n   * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\r\n   *\r\n   * @param {!Query} query\r\n   * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\r\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\r\n   * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events\r\n   */\n\n\n  SyncPoint.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {\n    var queryId = query.queryIdentifier();\n    var removed = [];\n    var cancelEvents = [];\n    var hadCompleteView = this.hasCompleteView();\n\n    if (queryId === 'default') {\n      // When you do ref.off(...), we search all views for the registration to remove.\n      var self_1 = this;\n      util_2.forEach(this.views_, function (viewQueryId, view) {\n        cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\n\n        if (view.isEmpty()) {\n          delete self_1.views_[viewQueryId]; // We'll deal with complete views later.\n\n          if (!view.getQuery().getQueryParams().loadsAllData()) {\n            removed.push(view.getQuery());\n          }\n        }\n      });\n    } else {\n      // remove the callback from the specific view.\n      var view = util_2.safeGet(this.views_, queryId);\n\n      if (view) {\n        cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\n\n        if (view.isEmpty()) {\n          delete this.views_[queryId]; // We'll deal with complete views later.\n\n          if (!view.getQuery().getQueryParams().loadsAllData()) {\n            removed.push(view.getQuery());\n          }\n        }\n      }\n    }\n\n    if (hadCompleteView && !this.hasCompleteView()) {\n      // We removed our last complete view.\n      removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));\n    }\n\n    return {\n      removed: removed,\n      events: cancelEvents\n    };\n  };\n  /**\r\n   * @return {!Array.<!View>}\r\n   */\n\n\n  SyncPoint.prototype.getQueryViews = function () {\n    var _this = this;\n\n    var values = Object.keys(this.views_).map(function (key) {\n      return _this.views_[key];\n    });\n    return values.filter(function (view) {\n      return !view.getQuery().getQueryParams().loadsAllData();\n    });\n  };\n  /**\r\n   *\r\n   * @param {!Path} path The path to the desired complete snapshot\r\n   * @return {?Node} A complete cache, if it exists\r\n   */\n\n\n  SyncPoint.prototype.getCompleteServerCache = function (path) {\n    var serverCache = null;\n    util_2.forEach(this.views_, function (key, view) {\n      serverCache = serverCache || view.getCompleteServerCache(path);\n    });\n    return serverCache;\n  };\n  /**\r\n   * @param {!Query} query\r\n   * @return {?View}\r\n   */\n\n\n  SyncPoint.prototype.viewForQuery = function (query) {\n    var params = query.getQueryParams();\n\n    if (params.loadsAllData()) {\n      return this.getCompleteView();\n    } else {\n      var queryId = query.queryIdentifier();\n      return util_2.safeGet(this.views_, queryId);\n    }\n  };\n  /**\r\n   * @param {!Query} query\r\n   * @return {boolean}\r\n   */\n\n\n  SyncPoint.prototype.viewExistsForQuery = function (query) {\n    return this.viewForQuery(query) != null;\n  };\n  /**\r\n   * @return {boolean}\r\n   */\n\n\n  SyncPoint.prototype.hasCompleteView = function () {\n    return this.getCompleteView() != null;\n  };\n  /**\r\n   * @return {?View}\r\n   */\n\n\n  SyncPoint.prototype.getCompleteView = function () {\n    var completeView = util_2.findValue(this.views_, function (view) {\n      return view.getQuery().getQueryParams().loadsAllData();\n    });\n    return completeView || null;\n  };\n\n  return SyncPoint;\n}();\n\nexports.SyncPoint = SyncPoint;","map":{"version":3,"mappings":"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","names":["__referenceConstructor","Object","SyncPoint","util_1","val","util_2","views_","operation","writesCache","optCompleteServerCache","queryId","source","view","applyOperation","events_1","key","concat","query","eventRegistration","serverCache","serverCacheComplete","queryIdentifier","eventCache","calcCompleteEventCache","eventCacheComplete","ChildrenNode_1","calcCompleteEventChildren","EMPTY_NODE","viewCache","ViewCache_1","CacheNode_1","View_1","addEventRegistration","getInitialEvents","cancelError","removed","cancelEvents","hadCompleteView","hasCompleteView","self_1","viewQueryId","removeEventRegistration","isEmpty","getQuery","getQueryParams","loadsAllData","push","repo","path","events","values","keys","map","filter","getCompleteServerCache","params","getCompleteView","viewForQuery","completeView","exports"],"sources":["../src/core/SyncPoint.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CacheNode } from './view/CacheNode';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { assert } from '@firebase/util';\nimport { isEmpty, forEach, findValue, safeGet } from '@firebase/util';\nimport { ViewCache } from './view/ViewCache';\nimport { View } from './view/View';\nimport { Operation } from './operation/Operation';\nimport { WriteTreeRef } from './WriteTree';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { Node } from './snap/Node';\nimport { Path } from './util/Path';\nimport { Event } from './view/Event';\nimport { Reference, ReferenceConstructor } from '../api/Reference';\n\nlet __referenceConstructor: ReferenceConstructor;\n\n/**\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\n * and user writes (set, transaction, update).\n *\n * It's responsible for:\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\n *    applyUserOverwrite, etc.)\n */\nexport class SyncPoint {\n  static set __referenceConstructor(val: ReferenceConstructor) {\n    assert(\n      !__referenceConstructor,\n      '__referenceConstructor has already been defined'\n    );\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  /**\n   * The Views being tracked at this location in the tree, stored as a map where the key is a\n   * queryId and the value is the View for that query.\n   *\n   * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\n   *\n   * @type {!Object.<!string, !View>}\n   * @private\n   */\n  private views_: { [k: string]: View } = {};\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty(): boolean {\n    return isEmpty(this.views_);\n  }\n\n  /**\n   *\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} optCompleteServerCache\n   * @return {!Array.<!Event>}\n   */\n  applyOperation(\n    operation: Operation,\n    writesCache: WriteTreeRef,\n    optCompleteServerCache: Node | null\n  ): Event[] {\n    const queryId = operation.source.queryId;\n    if (queryId !== null) {\n      const view = safeGet(this.views_, queryId);\n      assert(view != null, 'SyncTree gave us an op for an invalid query.');\n      return view.applyOperation(\n        operation,\n        writesCache,\n        optCompleteServerCache\n      );\n    } else {\n      let events: Event[] = [];\n\n      forEach(this.views_, function(key: string, view: View) {\n        events = events.concat(\n          view.applyOperation(operation, writesCache, optCompleteServerCache)\n        );\n      });\n\n      return events;\n    }\n  }\n\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache Complete server cache, if we have it.\n   * @param {boolean} serverCacheComplete\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  addEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    serverCacheComplete: boolean\n  ): Event[] {\n    const queryId = query.queryIdentifier();\n    let view = safeGet(this.views_, queryId);\n    if (!view) {\n      // TODO: make writesCache take flag for complete server node\n      let eventCache = writesCache.calcCompleteEventCache(\n        serverCacheComplete ? serverCache : null\n      );\n      let eventCacheComplete = false;\n      if (eventCache) {\n        eventCacheComplete = true;\n      } else if (serverCache instanceof ChildrenNode) {\n        eventCache = writesCache.calcCompleteEventChildren(serverCache);\n        eventCacheComplete = false;\n      } else {\n        eventCache = ChildrenNode.EMPTY_NODE;\n        eventCacheComplete = false;\n      }\n      const viewCache = new ViewCache(\n        new CacheNode(\n          /** @type {!Node} */ (eventCache),\n          eventCacheComplete,\n          false\n        ),\n        new CacheNode(\n          /** @type {!Node} */ (serverCache),\n          serverCacheComplete,\n          false\n        )\n      );\n      view = new View(query, viewCache);\n      this.views_[queryId] = view;\n    }\n\n    // This is guaranteed to exist now, we just created anything that was missing\n    view.addEventRegistration(eventRegistration);\n    return view.getInitialEvents(eventRegistration);\n  }\n\n  /**\n   * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\n   *\n   * If query is the default query, we'll check all views for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events\n   */\n  removeEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration | null,\n    cancelError?: Error\n  ): { removed: Query[]; events: Event[] } {\n    const queryId = query.queryIdentifier();\n    const removed: Query[] = [];\n    let cancelEvents: Event[] = [];\n    const hadCompleteView = this.hasCompleteView();\n    if (queryId === 'default') {\n      // When you do ref.off(...), we search all views for the registration to remove.\n      const self = this;\n      forEach(this.views_, function(viewQueryId: string, view: View) {\n        cancelEvents = cancelEvents.concat(\n          view.removeEventRegistration(eventRegistration, cancelError)\n        );\n        if (view.isEmpty()) {\n          delete self.views_[viewQueryId];\n\n          // We'll deal with complete views later.\n          if (\n            !view\n              .getQuery()\n              .getQueryParams()\n              .loadsAllData()\n          ) {\n            removed.push(view.getQuery());\n          }\n        }\n      });\n    } else {\n      // remove the callback from the specific view.\n      const view = safeGet(this.views_, queryId);\n      if (view) {\n        cancelEvents = cancelEvents.concat(\n          view.removeEventRegistration(eventRegistration, cancelError)\n        );\n        if (view.isEmpty()) {\n          delete this.views_[queryId];\n\n          // We'll deal with complete views later.\n          if (\n            !view\n              .getQuery()\n              .getQueryParams()\n              .loadsAllData()\n          ) {\n            removed.push(view.getQuery());\n          }\n        }\n      }\n    }\n\n    if (hadCompleteView && !this.hasCompleteView()) {\n      // We removed our last complete view.\n      removed.push(\n        new SyncPoint.__referenceConstructor(query.repo, query.path)\n      );\n    }\n\n    return { removed: removed, events: cancelEvents };\n  }\n\n  /**\n   * @return {!Array.<!View>}\n   */\n  getQueryViews(): View[] {\n    const values = Object.keys(this.views_).map(key => this.views_[key]);\n    return values.filter(function(view) {\n      return !view\n        .getQuery()\n        .getQueryParams()\n        .loadsAllData();\n    });\n  }\n\n  /**\n   *\n   * @param {!Path} path The path to the desired complete snapshot\n   * @return {?Node} A complete cache, if it exists\n   */\n  getCompleteServerCache(path: Path): Node | null {\n    let serverCache: Node | null = null;\n    forEach(this.views_, (key: string, view: View) => {\n      serverCache = serverCache || view.getCompleteServerCache(path);\n    });\n    return serverCache;\n  }\n\n  /**\n   * @param {!Query} query\n   * @return {?View}\n   */\n  viewForQuery(query: Query): View | null {\n    const params = query.getQueryParams();\n    if (params.loadsAllData()) {\n      return this.getCompleteView();\n    } else {\n      const queryId = query.queryIdentifier();\n      return safeGet(this.views_, queryId);\n    }\n  }\n\n  /**\n   * @param {!Query} query\n   * @return {boolean}\n   */\n  viewExistsForQuery(query: Query): boolean {\n    return this.viewForQuery(query) != null;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasCompleteView(): boolean {\n    return this.getCompleteView() != null;\n  }\n\n  /**\n   * @return {?View}\n   */\n  getCompleteView(): View | null {\n    const completeView = findValue(this.views_, (view: View) =>\n      view\n        .getQuery()\n        .getQueryParams()\n        .loadsAllData()\n    );\n    return completeView || null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}