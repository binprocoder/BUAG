{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Operation_1 = require(\"../operation/Operation\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar ChildChangeAccumulator_1 = require(\"./ChildChangeAccumulator\");\n\nvar Change_1 = require(\"./Change\");\n\nvar ChildrenNode_1 = require(\"../snap/ChildrenNode\");\n\nvar KeyIndex_1 = require(\"../snap/indexes/KeyIndex\");\n\nvar ImmutableTree_1 = require(\"../util/ImmutableTree\");\n\nvar Path_1 = require(\"../util/Path\");\n\nvar CompleteChildSource_1 = require(\"./CompleteChildSource\");\n/**\n * @constructor\n * @struct\n */\n\n\nvar ProcessorResult =\n/** @class */\nfunction () {\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Array.<!Change>} changes\n   */\n  function ProcessorResult(viewCache, changes) {\n    this.viewCache = viewCache;\n    this.changes = changes;\n  }\n\n  return ProcessorResult;\n}();\n\nexports.ProcessorResult = ProcessorResult;\n/**\n * @constructor\n */\n\nvar ViewProcessor =\n/** @class */\nfunction () {\n  /**\n   * @param {!NodeFilter} filter_\n   */\n  function ViewProcessor(filter_) {\n    this.filter_ = filter_;\n  }\n  /**\n   * @param {!ViewCache} viewCache\n   */\n\n\n  ViewProcessor.prototype.assertIndexed = function (viewCache) {\n    util_1.assert(viewCache.getEventCache().getNode().isIndexed(this.filter_.getIndex()), 'Event snap not indexed');\n    util_1.assert(viewCache.getServerCache().getNode().isIndexed(this.filter_.getIndex()), 'Server snap not indexed');\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @return {!ProcessorResult}\n   */\n\n\n  ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) {\n    var accumulator = new ChildChangeAccumulator_1.ChildChangeAccumulator();\n    var newViewCache, filterServerNode;\n\n    if (operation.type === Operation_1.OperationType.OVERWRITE) {\n      var overwrite = operation;\n\n      if (overwrite.source.fromUser) {\n        newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\n      } else {\n        util_1.assert(overwrite.source.fromServer, 'Unknown source.'); // We filter the node if it's a tagged update or the node has been previously filtered  and the\n        // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n        // again\n\n        filterServerNode = overwrite.source.tagged || oldViewCache.getServerCache().isFiltered() && !overwrite.path.isEmpty();\n        newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\n      }\n    } else if (operation.type === Operation_1.OperationType.MERGE) {\n      var merge = operation;\n\n      if (merge.source.fromUser) {\n        newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\n      } else {\n        util_1.assert(merge.source.fromServer, 'Unknown source.'); // We filter the node if it's a tagged update or the node has been previously filtered\n\n        filterServerNode = merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n        newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\n      }\n    } else if (operation.type === Operation_1.OperationType.ACK_USER_WRITE) {\n      var ackUserWrite = operation;\n\n      if (!ackUserWrite.revert) {\n        newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\n      } else {\n        newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\n      }\n    } else if (operation.type === Operation_1.OperationType.LISTEN_COMPLETE) {\n      newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);\n    } else {\n      throw util_1.assertionError('Unknown operation type: ' + operation.type);\n    }\n\n    var changes = accumulator.getChanges();\n    ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n    return new ProcessorResult(newViewCache, changes);\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!ViewCache} newViewCache\n   * @param {!Array.<!Change>} accumulator\n   * @private\n   */\n\n\n  ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) {\n    var eventSnap = newViewCache.getEventCache();\n\n    if (eventSnap.isFullyInitialized()) {\n      var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n      var oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n\n      if (accumulator.length > 0 || !oldViewCache.getEventCache().isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(\n      /** @type {!Node} */\n      oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\n        accumulator.push(Change_1.Change.valueChange(\n        /** @type {!Node} */\n        newViewCache.getCompleteEventSnap()));\n      }\n    }\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} changePath\n   * @param {!WriteTreeRef} writesCache\n   * @param {!CompleteChildSource} source\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) {\n    var oldEventSnap = viewCache.getEventCache();\n\n    if (writesCache.shadowingWrite(changePath) != null) {\n      // we have a shadowing write, ignore changes\n      return viewCache;\n    } else {\n      var newEventCache = void 0,\n          serverNode = void 0;\n\n      if (changePath.isEmpty()) {\n        // TODO: figure out how this plays with \"sliding ack windows\"\n        util_1.assert(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');\n\n        if (viewCache.getServerCache().isFiltered()) {\n          // We need to special case this, because we need to only apply writes to complete children, or\n          // we might end up raising events for incomplete children. If the server data is filtered deep\n          // writes cannot be guaranteed to be complete\n          var serverCache = viewCache.getCompleteServerSnap();\n          var completeChildren = serverCache instanceof ChildrenNode_1.ChildrenNode ? serverCache : ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);\n          newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);\n        } else {\n          var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n          newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);\n        }\n      } else {\n        var childKey = changePath.getFront();\n\n        if (childKey == '.priority') {\n          util_1.assert(changePath.getLength() == 1, \"Can't have a priority with additional path components\");\n          var oldEventNode = oldEventSnap.getNode();\n          serverNode = viewCache.getServerCache().getNode(); // we might have overwrites for this priority\n\n          var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);\n\n          if (updatedPriority != null) {\n            newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);\n          } else {\n            // priority didn't change, keep old node\n            newEventCache = oldEventSnap.getNode();\n          }\n        } else {\n          var childChangePath = changePath.popFront(); // update child\n\n          var newEventChild = void 0;\n\n          if (oldEventSnap.isCompleteForChild(childKey)) {\n            serverNode = viewCache.getServerCache().getNode();\n            var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);\n\n            if (eventChildUpdate != null) {\n              newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);\n            } else {\n              // Nothing changed, just keep the old child\n              newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);\n            }\n          } else {\n            newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n          }\n\n          if (newEventChild != null) {\n            newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\n          } else {\n            // no complete child available or no change\n            newEventCache = oldEventSnap.getNode();\n          }\n        }\n      }\n\n      return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());\n    }\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\n    var oldServerSnap = oldViewCache.getServerCache();\n    var newServerCache;\n    var serverFilter = filterServerNode ? this.filter_ : this.filter_.getIndexedFilter();\n\n    if (changePath.isEmpty()) {\n      newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n      // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n      var newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);\n      newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\n    } else {\n      var childKey = changePath.getFront();\n\n      if (!oldServerSnap.isCompleteForPath(changePath) && changePath.getLength() > 1) {\n        // We don't update incomplete nodes with updates intended for other listeners\n        return oldViewCache;\n      }\n\n      var childChangePath = changePath.popFront();\n      var childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n      var newChildNode = childNode.updateChild(childChangePath, changedSnap);\n\n      if (childKey == '.priority') {\n        newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\n      } else {\n        newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, null);\n      }\n    }\n\n    var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());\n    var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\n    return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\n    var oldEventSnap = oldViewCache.getEventCache();\n    var newViewCache, newEventCache;\n    var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\n\n    if (changePath.isEmpty()) {\n      newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);\n      newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());\n    } else {\n      var childKey = changePath.getFront();\n\n      if (childKey === '.priority') {\n        newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);\n        newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\n      } else {\n        var childChangePath = changePath.popFront();\n        var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n        var newChild = void 0;\n\n        if (childChangePath.isEmpty()) {\n          // Child overwrite, we can replace the child\n          newChild = changedSnap;\n        } else {\n          var childNode = source.getCompleteChild(childKey);\n\n          if (childNode != null) {\n            if (childChangePath.getBack() === '.priority' && childNode.getChild(childChangePath.parent()).isEmpty()) {\n              // This is a priority update on an empty node. If this node exists on the server, the\n              // server will send down the priority in the update, so ignore for now\n              newChild = childNode;\n            } else {\n              newChild = childNode.updateChild(childChangePath, changedSnap);\n            }\n          } else {\n            // There is no complete child node available\n            newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          }\n        }\n\n        if (!oldChild.equals(newChild)) {\n          var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\n          newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());\n        } else {\n          newViewCache = oldViewCache;\n        }\n      }\n    }\n\n    return newViewCache;\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {string} childKey\n   * @return {boolean}\n   * @private\n   */\n\n\n  ViewProcessor.cacheHasChild_ = function (viewCache, childKey) {\n    return viewCache.getEventCache().isCompleteForChild(childKey);\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\n    var _this = this; // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n\n\n    var curViewCache = viewCache;\n    changedChildren.foreach(function (relativePath, childNode) {\n      var writePath = path.child(relativePath);\n\n      if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n      }\n    });\n    changedChildren.foreach(function (relativePath, childNode) {\n      var writePath = path.child(relativePath);\n\n      if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n      }\n    });\n    return curViewCache;\n  };\n  /**\n   * @param {!Node} node\n   * @param {ImmutableTree.<!Node>} merge\n   * @return {!Node}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.applyMerge_ = function (node, merge) {\n    merge.foreach(function (relativePath, childNode) {\n      node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\n    var _this = this; // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n\n\n    if (viewCache.getServerCache().getNode().isEmpty() && !viewCache.getServerCache().isFullyInitialized()) {\n      return viewCache;\n    } // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n\n\n    var curViewCache = viewCache;\n    var viewMergeTree;\n\n    if (path.isEmpty()) {\n      viewMergeTree = changedChildren;\n    } else {\n      viewMergeTree = ImmutableTree_1.ImmutableTree.Empty.setTree(path, changedChildren);\n    }\n\n    var serverNode = viewCache.getServerCache().getNode();\n    viewMergeTree.children.inorderTraversal(function (childKey, childTree) {\n      if (serverNode.hasChild(childKey)) {\n        var serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);\n\n        var newChild = _this.applyMerge_(serverChild, childTree);\n\n        curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n      }\n    });\n    viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {\n      var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) && childMergeTree.value == null;\n\n      if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n        var serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);\n\n        var newChild = _this.applyMerge_(serverChild, childMergeTree);\n\n        curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n      }\n    });\n    return curViewCache;\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} ackPath\n   * @param {!ImmutableTree<!boolean>} affectedTree\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\n    if (writesCache.shadowingWrite(ackPath) != null) {\n      return viewCache;\n    } // Only filter server node if it is currently filtered\n\n\n    var filterServerNode = viewCache.getServerCache().isFiltered(); // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n\n    var serverCache = viewCache.getServerCache();\n\n    if (affectedTree.value != null) {\n      // This is an overwrite.\n      if (ackPath.isEmpty() && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {\n        return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\n      } else if (ackPath.isEmpty()) {\n        // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n        // should just re-apply whatever we have in our cache as a merge.\n        var changedChildren_1 = ImmutableTree_1.ImmutableTree.Empty;\n        serverCache.getNode().forEachChild(KeyIndex_1.KEY_INDEX, function (name, node) {\n          changedChildren_1 = changedChildren_1.set(new Path_1.Path(name), node);\n        });\n        return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);\n      } else {\n        return viewCache;\n      }\n    } else {\n      // This is a merge.\n      var changedChildren_2 = ImmutableTree_1.ImmutableTree.Empty;\n      affectedTree.foreach(function (mergePath, value) {\n        var serverCachePath = ackPath.child(mergePath);\n\n        if (serverCache.isCompleteForPath(serverCachePath)) {\n          changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));\n        }\n      });\n      return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);\n    }\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) {\n    var oldServerNode = viewCache.getServerCache();\n    var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());\n    return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, accumulator);\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeServerCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) {\n    var complete;\n\n    if (writesCache.shadowingWrite(path) != null) {\n      return viewCache;\n    } else {\n      var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\n      var oldEventCache = viewCache.getEventCache().getNode();\n      var newEventCache = void 0;\n\n      if (path.isEmpty() || path.getFront() === '.priority') {\n        var newNode = void 0;\n\n        if (viewCache.getServerCache().isFullyInitialized()) {\n          newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n        } else {\n          var serverChildren = viewCache.getServerCache().getNode();\n          util_1.assert(serverChildren instanceof ChildrenNode_1.ChildrenNode, 'serverChildren would be complete if leaf node');\n          newNode = writesCache.calcCompleteEventChildren(serverChildren);\n        }\n\n        newNode = newNode;\n        newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);\n      } else {\n        var childKey = path.getFront();\n        var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n\n        if (newChild == null && viewCache.getServerCache().isCompleteForChild(childKey)) {\n          newChild = oldEventCache.getImmediateChild(childKey);\n        }\n\n        if (newChild != null) {\n          newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);\n        } else if (viewCache.getEventCache().getNode().hasChild(childKey)) {\n          // No complete child available, delete the existing one, if any\n          newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator);\n        } else {\n          newEventCache = oldEventCache;\n        }\n\n        if (newEventCache.isEmpty() && viewCache.getServerCache().isFullyInitialized()) {\n          // We might have reverted all child writes. Maybe the old event was a leaf node\n          complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n\n          if (complete.isLeafNode()) {\n            newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);\n          }\n        }\n      }\n\n      complete = viewCache.getServerCache().isFullyInitialized() || writesCache.shadowingWrite(Path_1.Path.Empty) != null;\n      return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());\n    }\n  };\n\n  return ViewProcessor;\n}();\n\nexports.ViewProcessor = ViewProcessor;","map":{"version":3,"mappings":"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","names":["viewCache","changes","exports","filter_","ViewProcessor","util_1","getEventCache","getNode","isIndexed","getIndex","getServerCache","oldViewCache","operation","writesCache","completeCache","accumulator","ChildChangeAccumulator_1","newViewCache","filterServerNode","type","Operation_1","OVERWRITE","overwrite","source","fromUser","applyUserOverwrite_","path","snap","fromServer","tagged","isFiltered","isEmpty","applyServerOverwrite_","MERGE","merge","applyUserMerge_","children","applyServerMerge_","ACK_USER_WRITE","ackUserWrite","revert","ackUserWrite_","affectedTree","revertUserWrite_","LISTEN_COMPLETE","listenComplete_","getChanges","maybeAddValueEvent_","ProcessorResult","eventSnap","isFullyInitialized","isLeafOrEmpty","isLeafNode","oldCompleteSnap","getCompleteEventSnap","length","equals","getPriority","push","Change_1","valueChange","changePath","oldEventSnap","shadowingWrite","newEventCache","serverNode","serverCache","getCompleteServerSnap","completeChildren","ChildrenNode_1","EMPTY_NODE","completeEventChildren","calcCompleteEventChildren","updateFullNode","completeNode","calcCompleteEventCache","childKey","getFront","getLength","oldEventNode","updatedPriority","calcEventCacheAfterServerOverwrite","updatePriority","childChangePath","popFront","newEventChild","isCompleteForChild","eventChildUpdate","getImmediateChild","updateChild","calcCompleteChild","updateEventSnap","filtersNodes","changedSnap","oldServerSnap","newServerCache","serverFilter","getIndexedFilter","newServerNode","isCompleteForPath","childNode","newChildNode","CompleteChildSource_1","updateServerSnap","generateEventCacheAfterServerEvent_","oldChild","newChild","getCompleteChild","getBack","getChild","parent","newEventSnap","changedChildren","curViewCache","foreach","relativePath","writePath","child","cacheHasChild_","_this","node","viewMergeTree","ImmutableTree_1","Empty","setTree","inorderTraversal","childTree","hasChild","serverChild","applyMerge_","Path_1","childMergeTree","isUnknownDeepMerge","value","ackPath","changedChildren_1","forEachChild","KeyIndex_1","name","set","changedChildren_2","mergePath","serverCachePath","oldServerNode","completeServerCache","complete","oldEventCache","newNode","serverChildren"],"sources":["../src/core/view/ViewProcessor.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Operation, OperationType } from '../operation/Operation';\nimport { assert, assertionError } from '@firebase/util';\nimport { ChildChangeAccumulator } from './ChildChangeAccumulator';\nimport { Change } from './Change';\nimport { ChildrenNode } from '../snap/ChildrenNode';\nimport { KEY_INDEX } from '../snap/indexes/KeyIndex';\nimport { ImmutableTree } from '../util/ImmutableTree';\nimport { Path } from '../util/Path';\nimport {\n  WriteTreeCompleteChildSource,\n  NO_COMPLETE_CHILD_SOURCE,\n  CompleteChildSource\n} from './CompleteChildSource';\nimport { ViewCache } from './ViewCache';\nimport { NodeFilter } from './filter/NodeFilter';\nimport { WriteTreeRef } from '../WriteTree';\nimport { Overwrite } from '../operation/Overwrite';\nimport { Merge } from '../operation/Merge';\nimport { AckUserWrite } from '../operation/AckUserWrite';\nimport { Node } from '../snap/Node';\n\n/**\n * @constructor\n * @struct\n */\nexport class ProcessorResult {\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Array.<!Change>} changes\n   */\n  constructor(\n    public readonly viewCache: ViewCache,\n    public readonly changes: Change[]\n  ) {}\n}\n\n/**\n * @constructor\n */\nexport class ViewProcessor {\n  /**\n   * @param {!NodeFilter} filter_\n   */\n  constructor(private readonly filter_: NodeFilter) {}\n\n  /**\n   * @param {!ViewCache} viewCache\n   */\n  assertIndexed(viewCache: ViewCache) {\n    assert(\n      viewCache\n        .getEventCache()\n        .getNode()\n        .isIndexed(this.filter_.getIndex()),\n      'Event snap not indexed'\n    );\n    assert(\n      viewCache\n        .getServerCache()\n        .getNode()\n        .isIndexed(this.filter_.getIndex()),\n      'Server snap not indexed'\n    );\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @return {!ProcessorResult}\n   */\n  applyOperation(\n    oldViewCache: ViewCache,\n    operation: Operation,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null\n  ): ProcessorResult {\n    const accumulator = new ChildChangeAccumulator();\n    let newViewCache, filterServerNode;\n    if (operation.type === OperationType.OVERWRITE) {\n      const overwrite = operation as Overwrite;\n      if (overwrite.source.fromUser) {\n        newViewCache = this.applyUserOverwrite_(\n          oldViewCache,\n          overwrite.path,\n          overwrite.snap,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        assert(overwrite.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered  and the\n        // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n        // again\n        filterServerNode =\n          overwrite.source.tagged ||\n          (oldViewCache.getServerCache().isFiltered() &&\n            !overwrite.path.isEmpty());\n        newViewCache = this.applyServerOverwrite_(\n          oldViewCache,\n          overwrite.path,\n          overwrite.snap,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.MERGE) {\n      const merge = operation as Merge;\n      if (merge.source.fromUser) {\n        newViewCache = this.applyUserMerge_(\n          oldViewCache,\n          merge.path,\n          merge.children,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        assert(merge.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered\n        filterServerNode =\n          merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n        newViewCache = this.applyServerMerge_(\n          oldViewCache,\n          merge.path,\n          merge.children,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.ACK_USER_WRITE) {\n      const ackUserWrite = operation as AckUserWrite;\n      if (!ackUserWrite.revert) {\n        newViewCache = this.ackUserWrite_(\n          oldViewCache,\n          ackUserWrite.path,\n          ackUserWrite.affectedTree,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        newViewCache = this.revertUserWrite_(\n          oldViewCache,\n          ackUserWrite.path,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.LISTEN_COMPLETE) {\n      newViewCache = this.listenComplete_(\n        oldViewCache,\n        operation.path,\n        writesCache,\n        accumulator\n      );\n    } else {\n      throw assertionError('Unknown operation type: ' + operation.type);\n    }\n    const changes = accumulator.getChanges();\n    ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n    return new ProcessorResult(newViewCache, changes);\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!ViewCache} newViewCache\n   * @param {!Array.<!Change>} accumulator\n   * @private\n   */\n  private static maybeAddValueEvent_(\n    oldViewCache: ViewCache,\n    newViewCache: ViewCache,\n    accumulator: Change[]\n  ) {\n    const eventSnap = newViewCache.getEventCache();\n    if (eventSnap.isFullyInitialized()) {\n      const isLeafOrEmpty =\n        eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n      const oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n      if (\n        accumulator.length > 0 ||\n        !oldViewCache.getEventCache().isFullyInitialized() ||\n        (isLeafOrEmpty &&\n          !eventSnap\n            .getNode()\n            .equals(/** @type {!Node} */ (oldCompleteSnap))) ||\n        !eventSnap\n          .getNode()\n          .getPriority()\n          .equals(oldCompleteSnap.getPriority())\n      ) {\n        accumulator.push(\n          Change.valueChange(\n            /** @type {!Node} */ newViewCache.getCompleteEventSnap()\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} changePath\n   * @param {!WriteTreeRef} writesCache\n   * @param {!CompleteChildSource} source\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private generateEventCacheAfterServerEvent_(\n    viewCache: ViewCache,\n    changePath: Path,\n    writesCache: WriteTreeRef,\n    source: CompleteChildSource,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldEventSnap = viewCache.getEventCache();\n    if (writesCache.shadowingWrite(changePath) != null) {\n      // we have a shadowing write, ignore changes\n      return viewCache;\n    } else {\n      let newEventCache, serverNode;\n      if (changePath.isEmpty()) {\n        // TODO: figure out how this plays with \"sliding ack windows\"\n        assert(\n          viewCache.getServerCache().isFullyInitialized(),\n          'If change path is empty, we must have complete server data'\n        );\n        if (viewCache.getServerCache().isFiltered()) {\n          // We need to special case this, because we need to only apply writes to complete children, or\n          // we might end up raising events for incomplete children. If the server data is filtered deep\n          // writes cannot be guaranteed to be complete\n          const serverCache = viewCache.getCompleteServerSnap();\n          const completeChildren =\n            serverCache instanceof ChildrenNode\n              ? serverCache\n              : ChildrenNode.EMPTY_NODE;\n          const completeEventChildren = writesCache.calcCompleteEventChildren(\n            completeChildren\n          );\n          newEventCache = this.filter_.updateFullNode(\n            viewCache.getEventCache().getNode(),\n            completeEventChildren,\n            accumulator\n          );\n        } else {\n          const completeNode = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n          newEventCache = this.filter_.updateFullNode(\n            viewCache.getEventCache().getNode(),\n            completeNode,\n            accumulator\n          );\n        }\n      } else {\n        const childKey = changePath.getFront();\n        if (childKey == '.priority') {\n          assert(\n            changePath.getLength() == 1,\n            \"Can't have a priority with additional path components\"\n          );\n          const oldEventNode = oldEventSnap.getNode();\n          serverNode = viewCache.getServerCache().getNode();\n          // we might have overwrites for this priority\n          const updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(\n            changePath,\n            oldEventNode,\n            serverNode\n          );\n          if (updatedPriority != null) {\n            newEventCache = this.filter_.updatePriority(\n              oldEventNode,\n              updatedPriority\n            );\n          } else {\n            // priority didn't change, keep old node\n            newEventCache = oldEventSnap.getNode();\n          }\n        } else {\n          const childChangePath = changePath.popFront();\n          // update child\n          let newEventChild;\n          if (oldEventSnap.isCompleteForChild(childKey)) {\n            serverNode = viewCache.getServerCache().getNode();\n            const eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(\n              changePath,\n              oldEventSnap.getNode(),\n              serverNode\n            );\n            if (eventChildUpdate != null) {\n              newEventChild = oldEventSnap\n                .getNode()\n                .getImmediateChild(childKey)\n                .updateChild(childChangePath, eventChildUpdate);\n            } else {\n              // Nothing changed, just keep the old child\n              newEventChild = oldEventSnap\n                .getNode()\n                .getImmediateChild(childKey);\n            }\n          } else {\n            newEventChild = writesCache.calcCompleteChild(\n              childKey,\n              viewCache.getServerCache()\n            );\n          }\n          if (newEventChild != null) {\n            newEventCache = this.filter_.updateChild(\n              oldEventSnap.getNode(),\n              childKey,\n              newEventChild,\n              childChangePath,\n              source,\n              accumulator\n            );\n          } else {\n            // no complete child available or no change\n            newEventCache = oldEventSnap.getNode();\n          }\n        }\n      }\n      return viewCache.updateEventSnap(\n        newEventCache,\n        oldEventSnap.isFullyInitialized() || changePath.isEmpty(),\n        this.filter_.filtersNodes()\n      );\n    }\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyServerOverwrite_(\n    oldViewCache: ViewCache,\n    changePath: Path,\n    changedSnap: Node,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    filterServerNode: boolean,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldServerSnap = oldViewCache.getServerCache();\n    let newServerCache;\n    const serverFilter = filterServerNode\n      ? this.filter_\n      : this.filter_.getIndexedFilter();\n    if (changePath.isEmpty()) {\n      newServerCache = serverFilter.updateFullNode(\n        oldServerSnap.getNode(),\n        changedSnap,\n        null\n      );\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n      // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n      const newServerNode = oldServerSnap\n        .getNode()\n        .updateChild(changePath, changedSnap);\n      newServerCache = serverFilter.updateFullNode(\n        oldServerSnap.getNode(),\n        newServerNode,\n        null\n      );\n    } else {\n      const childKey = changePath.getFront();\n      if (\n        !oldServerSnap.isCompleteForPath(changePath) &&\n        changePath.getLength() > 1\n      ) {\n        // We don't update incomplete nodes with updates intended for other listeners\n        return oldViewCache;\n      }\n      const childChangePath = changePath.popFront();\n      const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n      const newChildNode = childNode.updateChild(childChangePath, changedSnap);\n      if (childKey == '.priority') {\n        newServerCache = serverFilter.updatePriority(\n          oldServerSnap.getNode(),\n          newChildNode\n        );\n      } else {\n        newServerCache = serverFilter.updateChild(\n          oldServerSnap.getNode(),\n          childKey,\n          newChildNode,\n          childChangePath,\n          NO_COMPLETE_CHILD_SOURCE,\n          null\n        );\n      }\n    }\n    const newViewCache = oldViewCache.updateServerSnap(\n      newServerCache,\n      oldServerSnap.isFullyInitialized() || changePath.isEmpty(),\n      serverFilter.filtersNodes()\n    );\n    const source = new WriteTreeCompleteChildSource(\n      writesCache,\n      newViewCache,\n      completeCache\n    );\n    return this.generateEventCacheAfterServerEvent_(\n      newViewCache,\n      changePath,\n      writesCache,\n      source,\n      accumulator\n    );\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyUserOverwrite_(\n    oldViewCache: ViewCache,\n    changePath: Path,\n    changedSnap: Node,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldEventSnap = oldViewCache.getEventCache();\n    let newViewCache, newEventCache;\n    const source = new WriteTreeCompleteChildSource(\n      writesCache,\n      oldViewCache,\n      completeCache\n    );\n    if (changePath.isEmpty()) {\n      newEventCache = this.filter_.updateFullNode(\n        oldViewCache.getEventCache().getNode(),\n        changedSnap,\n        accumulator\n      );\n      newViewCache = oldViewCache.updateEventSnap(\n        newEventCache,\n        true,\n        this.filter_.filtersNodes()\n      );\n    } else {\n      const childKey = changePath.getFront();\n      if (childKey === '.priority') {\n        newEventCache = this.filter_.updatePriority(\n          oldViewCache.getEventCache().getNode(),\n          changedSnap\n        );\n        newViewCache = oldViewCache.updateEventSnap(\n          newEventCache,\n          oldEventSnap.isFullyInitialized(),\n          oldEventSnap.isFiltered()\n        );\n      } else {\n        const childChangePath = changePath.popFront();\n        const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n        let newChild;\n        if (childChangePath.isEmpty()) {\n          // Child overwrite, we can replace the child\n          newChild = changedSnap;\n        } else {\n          const childNode = source.getCompleteChild(childKey);\n          if (childNode != null) {\n            if (\n              childChangePath.getBack() === '.priority' &&\n              childNode.getChild(childChangePath.parent()).isEmpty()\n            ) {\n              // This is a priority update on an empty node. If this node exists on the server, the\n              // server will send down the priority in the update, so ignore for now\n              newChild = childNode;\n            } else {\n              newChild = childNode.updateChild(childChangePath, changedSnap);\n            }\n          } else {\n            // There is no complete child node available\n            newChild = ChildrenNode.EMPTY_NODE;\n          }\n        }\n        if (!oldChild.equals(newChild)) {\n          const newEventSnap = this.filter_.updateChild(\n            oldEventSnap.getNode(),\n            childKey,\n            newChild,\n            childChangePath,\n            source,\n            accumulator\n          );\n          newViewCache = oldViewCache.updateEventSnap(\n            newEventSnap,\n            oldEventSnap.isFullyInitialized(),\n            this.filter_.filtersNodes()\n          );\n        } else {\n          newViewCache = oldViewCache;\n        }\n      }\n    }\n    return newViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {string} childKey\n   * @return {boolean}\n   * @private\n   */\n  private static cacheHasChild_(\n    viewCache: ViewCache,\n    childKey: string\n  ): boolean {\n    return viewCache.getEventCache().isCompleteForChild(childKey);\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyUserMerge_(\n    viewCache: ViewCache,\n    path: Path,\n    changedChildren: ImmutableTree<Node>,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(\n          curViewCache,\n          writePath,\n          childNode,\n          writesCache,\n          serverCache,\n          accumulator\n        );\n      }\n    });\n\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(\n          curViewCache,\n          writePath,\n          childNode,\n          writesCache,\n          serverCache,\n          accumulator\n        );\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!Node} node\n   * @param {ImmutableTree.<!Node>} merge\n   * @return {!Node}\n   * @private\n   */\n  private applyMerge_(node: Node, merge: ImmutableTree<Node>): Node {\n    merge.foreach(function(relativePath, childNode) {\n      node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyServerMerge_(\n    viewCache: ViewCache,\n    path: Path,\n    changedChildren: ImmutableTree<Node>,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    filterServerNode: boolean,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n    if (\n      viewCache\n        .getServerCache()\n        .getNode()\n        .isEmpty() &&\n      !viewCache.getServerCache().isFullyInitialized()\n    ) {\n      return viewCache;\n    }\n\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    let viewMergeTree;\n    if (path.isEmpty()) {\n      viewMergeTree = changedChildren;\n    } else {\n      viewMergeTree = ImmutableTree.Empty.setTree(path, changedChildren);\n    }\n    const serverNode = viewCache.getServerCache().getNode();\n    viewMergeTree.children.inorderTraversal((childKey, childTree) => {\n      if (serverNode.hasChild(childKey)) {\n        const serverChild = viewCache\n          .getServerCache()\n          .getNode()\n          .getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childTree);\n        curViewCache = this.applyServerOverwrite_(\n          curViewCache,\n          new Path(childKey),\n          newChild,\n          writesCache,\n          serverCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    });\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {\n      const isUnknownDeepMerge =\n        !viewCache.getServerCache().isCompleteForChild(childKey) &&\n        childMergeTree.value == null;\n      if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n        const serverChild = viewCache\n          .getServerCache()\n          .getNode()\n          .getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childMergeTree);\n        curViewCache = this.applyServerOverwrite_(\n          curViewCache,\n          new Path(childKey),\n          newChild,\n          writesCache,\n          serverCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} ackPath\n   * @param {!ImmutableTree<!boolean>} affectedTree\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private ackUserWrite_(\n    viewCache: ViewCache,\n    ackPath: Path,\n    affectedTree: ImmutableTree<boolean>,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    if (writesCache.shadowingWrite(ackPath) != null) {\n      return viewCache;\n    }\n\n    // Only filter server node if it is currently filtered\n    const filterServerNode = viewCache.getServerCache().isFiltered();\n\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n    const serverCache = viewCache.getServerCache();\n    if (affectedTree.value != null) {\n      // This is an overwrite.\n      if (\n        (ackPath.isEmpty() && serverCache.isFullyInitialized()) ||\n        serverCache.isCompleteForPath(ackPath)\n      ) {\n        return this.applyServerOverwrite_(\n          viewCache,\n          ackPath,\n          serverCache.getNode().getChild(ackPath),\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      } else if (ackPath.isEmpty()) {\n        // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n        // should just re-apply whatever we have in our cache as a merge.\n        let changedChildren = ImmutableTree.Empty;\n        serverCache.getNode().forEachChild(KEY_INDEX, function(name, node) {\n          changedChildren = changedChildren.set(new Path(name), node);\n        });\n        return this.applyServerMerge_(\n          viewCache,\n          ackPath,\n          changedChildren,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      } else {\n        return viewCache;\n      }\n    } else {\n      // This is a merge.\n      let changedChildren = ImmutableTree.Empty;\n      affectedTree.foreach(function(mergePath, value) {\n        const serverCachePath = ackPath.child(mergePath);\n        if (serverCache.isCompleteForPath(serverCachePath)) {\n          changedChildren = changedChildren.set(\n            mergePath,\n            serverCache.getNode().getChild(serverCachePath)\n          );\n        }\n      });\n      return this.applyServerMerge_(\n        viewCache,\n        ackPath,\n        changedChildren,\n        writesCache,\n        completeCache,\n        filterServerNode,\n        accumulator\n      );\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private listenComplete_(\n    viewCache: ViewCache,\n    path: Path,\n    writesCache: WriteTreeRef,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldServerNode = viewCache.getServerCache();\n    const newViewCache = viewCache.updateServerSnap(\n      oldServerNode.getNode(),\n      oldServerNode.isFullyInitialized() || path.isEmpty(),\n      oldServerNode.isFiltered()\n    );\n    return this.generateEventCacheAfterServerEvent_(\n      newViewCache,\n      path,\n      writesCache,\n      NO_COMPLETE_CHILD_SOURCE,\n      accumulator\n    );\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeServerCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private revertUserWrite_(\n    viewCache: ViewCache,\n    path: Path,\n    writesCache: WriteTreeRef,\n    completeServerCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    let complete;\n    if (writesCache.shadowingWrite(path) != null) {\n      return viewCache;\n    } else {\n      const source = new WriteTreeCompleteChildSource(\n        writesCache,\n        viewCache,\n        completeServerCache\n      );\n      const oldEventCache = viewCache.getEventCache().getNode();\n      let newEventCache;\n      if (path.isEmpty() || path.getFront() === '.priority') {\n        let newNode;\n        if (viewCache.getServerCache().isFullyInitialized()) {\n          newNode = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n        } else {\n          const serverChildren = viewCache.getServerCache().getNode();\n          assert(\n            serverChildren instanceof ChildrenNode,\n            'serverChildren would be complete if leaf node'\n          );\n          newNode = writesCache.calcCompleteEventChildren(\n            serverChildren as ChildrenNode\n          );\n        }\n        newNode = newNode as Node;\n        newEventCache = this.filter_.updateFullNode(\n          oldEventCache,\n          newNode,\n          accumulator\n        );\n      } else {\n        const childKey = path.getFront();\n        let newChild = writesCache.calcCompleteChild(\n          childKey,\n          viewCache.getServerCache()\n        );\n        if (\n          newChild == null &&\n          viewCache.getServerCache().isCompleteForChild(childKey)\n        ) {\n          newChild = oldEventCache.getImmediateChild(childKey);\n        }\n        if (newChild != null) {\n          newEventCache = this.filter_.updateChild(\n            oldEventCache,\n            childKey,\n            newChild,\n            path.popFront(),\n            source,\n            accumulator\n          );\n        } else if (\n          viewCache\n            .getEventCache()\n            .getNode()\n            .hasChild(childKey)\n        ) {\n          // No complete child available, delete the existing one, if any\n          newEventCache = this.filter_.updateChild(\n            oldEventCache,\n            childKey,\n            ChildrenNode.EMPTY_NODE,\n            path.popFront(),\n            source,\n            accumulator\n          );\n        } else {\n          newEventCache = oldEventCache;\n        }\n        if (\n          newEventCache.isEmpty() &&\n          viewCache.getServerCache().isFullyInitialized()\n        ) {\n          // We might have reverted all child writes. Maybe the old event was a leaf node\n          complete = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n          if (complete.isLeafNode()) {\n            newEventCache = this.filter_.updateFullNode(\n              newEventCache,\n              complete,\n              accumulator\n            );\n          }\n        }\n      }\n      complete =\n        viewCache.getServerCache().isFullyInitialized() ||\n        writesCache.shadowingWrite(Path.Empty) != null;\n      return viewCache.updateEventSnap(\n        newEventCache,\n        complete,\n        this.filter_.filtersNodes()\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}