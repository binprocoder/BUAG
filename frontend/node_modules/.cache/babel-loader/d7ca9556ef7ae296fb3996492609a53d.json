{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert_1 = require(\"./assert\"); // Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n\n/**\n * @param {string} str\n * @return {Array}\n */\n\n\nexports.stringToByteArray = function (str) {\n  var out = [],\n      p = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i); // Is this the lead surrogate in a surrogate pair?\n\n    if (c >= 0xd800 && c <= 0xdbff) {\n      var high = c - 0xd800; // the high 10 bits.\n\n      i++;\n      assert_1.assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n      var low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n\n      c = 0x10000 + (high << 10) + low;\n    }\n\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = c >> 6 | 192;\n      out[p++] = c & 63 | 128;\n    } else if (c < 65536) {\n      out[p++] = c >> 12 | 224;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    } else {\n      out[p++] = c >> 18 | 240;\n      out[p++] = c >> 12 & 63 | 128;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    }\n  }\n\n  return out;\n};\n/**\n * Calculate length without actually converting; useful for doing cheaper validation.\n * @param {string} str\n * @return {number}\n */\n\n\nexports.stringLength = function (str) {\n  var p = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n\n    if (c < 128) {\n      p++;\n    } else if (c < 2048) {\n      p += 2;\n    } else if (c >= 0xd800 && c <= 0xdbff) {\n      // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n      p += 4;\n      i++; // skip trail surrogate.\n    } else {\n      p += 3;\n    }\n  }\n\n  return p;\n};","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA,mC,CAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;AAIaA,4BAAoB,UAASC,GAAT,EAAY;AAC3C,MAAIC,GAAG,GAAG,EAAV;AAAA,MACEC,CAAC,GAAG,CADN;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACI,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACnC,QAAIE,CAAC,GAAGL,GAAG,CAACM,UAAJ,CAAeH,CAAf,CAAR,CADmC,CAGnC;;AACA,QAAIE,CAAC,IAAI,MAAL,IAAeA,CAAC,IAAI,MAAxB,EAAgC;AAC9B,UAAIE,IAAI,GAAGF,CAAC,GAAG,MAAf,CAD8B,CACP;;AACvBF,OAAC;AACDK,sBAAOL,CAAC,GAAGH,GAAG,CAACI,MAAf,EAAuB,yCAAvB;AACA,UAAIK,GAAG,GAAGT,GAAG,CAACM,UAAJ,CAAeH,CAAf,IAAoB,MAA9B,CAJ8B,CAIQ;;AACtCE,OAAC,GAAG,WAAWE,IAAI,IAAI,EAAnB,IAAyBE,GAA7B;AACD;;AAED,QAAIJ,CAAC,GAAG,GAAR,EAAa;AACXJ,SAAG,CAACC,CAAC,EAAF,CAAH,GAAWG,CAAX;AACD,KAFD,MAEO,IAAIA,CAAC,GAAG,IAAR,EAAc;AACnBJ,SAAG,CAACC,CAAC,EAAF,CAAH,GAAYG,CAAC,IAAI,CAAN,GAAW,GAAtB;AACAJ,SAAG,CAACC,CAAC,EAAF,CAAH,GAAYG,CAAC,GAAG,EAAL,GAAW,GAAtB;AACD,KAHM,MAGA,IAAIA,CAAC,GAAG,KAAR,EAAe;AACpBJ,SAAG,CAACC,CAAC,EAAF,CAAH,GAAYG,CAAC,IAAI,EAAN,GAAY,GAAvB;AACAJ,SAAG,CAACC,CAAC,EAAF,CAAH,GAAaG,CAAC,IAAI,CAAN,GAAW,EAAZ,GAAkB,GAA7B;AACAJ,SAAG,CAACC,CAAC,EAAF,CAAH,GAAYG,CAAC,GAAG,EAAL,GAAW,GAAtB;AACD,KAJM,MAIA;AACLJ,SAAG,CAACC,CAAC,EAAF,CAAH,GAAYG,CAAC,IAAI,EAAN,GAAY,GAAvB;AACAJ,SAAG,CAACC,CAAC,EAAF,CAAH,GAAaG,CAAC,IAAI,EAAN,GAAY,EAAb,GAAmB,GAA9B;AACAJ,SAAG,CAACC,CAAC,EAAF,CAAH,GAAaG,CAAC,IAAI,CAAN,GAAW,EAAZ,GAAkB,GAA7B;AACAJ,SAAG,CAACC,CAAC,EAAF,CAAH,GAAYG,CAAC,GAAG,EAAL,GAAW,GAAtB;AACD;AACF;;AACD,SAAOJ,GAAP;AACD,CAhCY;AAkCb;;;;;;;AAKaF,uBAAe,UAASC,GAAT,EAAY;AACtC,MAAIE,CAAC,GAAG,CAAR;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACI,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACnC,QAAIE,CAAC,GAAGL,GAAG,CAACM,UAAJ,CAAeH,CAAf,CAAR;;AACA,QAAIE,CAAC,GAAG,GAAR,EAAa;AACXH,OAAC;AACF,KAFD,MAEO,IAAIG,CAAC,GAAG,IAAR,EAAc;AACnBH,OAAC,IAAI,CAAL;AACD,KAFM,MAEA,IAAIG,CAAC,IAAI,MAAL,IAAeA,CAAC,IAAI,MAAxB,EAAgC;AACrC;AACAH,OAAC,IAAI,CAAL;AACAC,OAAC,GAHoC,CAGhC;AACN,KAJM,MAIA;AACLD,OAAC,IAAI,CAAL;AACD;AACF;;AACD,SAAOA,CAAP;AACD,CAjBY","names":["exports","str","out","p","i","length","c","charCodeAt","high","assert_1","low"],"sources":["../src/utf8.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from './assert';\n\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n\n/**\n * @param {string} str\n * @return {Array}\n */\nexport const stringToByteArray = function(str) {\n  var out = [],\n    p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n\n    // Is this the lead surrogate in a surrogate pair?\n    if (c >= 0xd800 && c <= 0xdbff) {\n      var high = c - 0xd800; // the high 10 bits.\n      i++;\n      assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n      var low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n      c = 0x10000 + (high << 10) + low;\n    }\n\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192;\n      out[p++] = (c & 63) | 128;\n    } else if (c < 65536) {\n      out[p++] = (c >> 12) | 224;\n      out[p++] = ((c >> 6) & 63) | 128;\n      out[p++] = (c & 63) | 128;\n    } else {\n      out[p++] = (c >> 18) | 240;\n      out[p++] = ((c >> 12) & 63) | 128;\n      out[p++] = ((c >> 6) & 63) | 128;\n      out[p++] = (c & 63) | 128;\n    }\n  }\n  return out;\n};\n\n/**\n * Calculate length without actually converting; useful for doing cheaper validation.\n * @param {string} str\n * @return {number}\n */\nexport const stringLength = function(str) {\n  var p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    if (c < 128) {\n      p++;\n    } else if (c < 2048) {\n      p += 2;\n    } else if (c >= 0xd800 && c <= 0xdbff) {\n      // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n      p += 4;\n      i++; // skip trail surrogate.\n    } else {\n      p += 3;\n    }\n  }\n  return p;\n};\n"]},"metadata":{},"sourceType":"script"}